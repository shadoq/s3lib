[{"ver":"0.1","info":{"id":"XsSXzR","date":"1408123373","viewed":90,"name":"Circuit Board","username":"demofox","description":"via wang tiling and a very lame shading multiplier that varies over distance","likes":2,"published":1,"tags":["2d","tiling","wangtiling"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/*\n\nWritten by Alan Wolfe\nhttp:\/\/demofox.org\/\nhttp:\/\/blog.demofox.org\/\n\nWang tiling is a method for creating organic looking images with 2d tiles\n\nMore info on wang tiling:\nhttp:\/\/research.microsoft.com\/en-us\/um\/people\/cohen\/WangFinal.pdf\nhttp:\/\/procworld.blogspot.ca\/2013\/01\/introduction-to-wang-tiles.html\n*\/\n\n\/\/ unscaled tile size\n#define TILE_SIZE 0.15\n\n\/\/ used when displaying the individual tiles\n#define TILE_PADDING 0.05\n\n\/\/ used when displaying the tile grid\n#define TILE_SCALE 1.5\n#define TILE_SCROLL vec2(0.25, 0.1)*5.0\n\nfloat SDFHorizLine( in vec2 coords, float offsetY )\n{\n    float v = offsetY-coords.y;\n    vec2  g = vec2(0.0,-1.0);\n    return abs(v)\/length(g);\n}\n\nfloat SDFVertLine( in vec2 coords, float offsetX )\n{\n    float v = coords.x - offsetX;\n    vec2  g = vec2(1.0,0.0);\n    return abs(v)\/length(g);\n}\n\nfloat SDFCircle( in vec2 coords, float offsetX, float offsetY, float radius )\n{\n    coords.x -= offsetX;\n    coords.y -= offsetY;\n    float v = coords.x * coords.x + coords.y * coords.y - radius;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v\/length(g); \n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 RenderTilePixelLevel1 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 1 && percentX < 0.5) ||\n        (rightType == 1 && percentX > 0.5))\n    {\n        float newCol = smoothstep(0.0,0.05,SDFHorizLine(vec2(percentX,percentY), 0.5));\n    \tcol = min(col, newCol);\n    }\n    \n\n    if ((topType == 1 && percentY < 0.5) ||\n        (bottomType == 1 && percentY > 0.5))\n    {\n        float newCol = smoothstep(0.1,0.15,SDFVertLine(vec2(percentX,percentY),0.5));\n    \tcol = min(col, newCol);\n    }\n    \n    if (leftType != rightType || topType != bottomType)\n    {\n        float newCol = smoothstep(0.048,0.068,SDFCircle(vec2(percentX,percentY),0.5,0.5,0.001));\n    \tcol = min(col, newCol);    \n    }\n    \n    return mix(vec3(0.125,0.125,0.125),incolor,col);\n}\n\nvec3 RenderTilePixelLevel2 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 0 && percentX < 0.75) ||\n        (rightType == 0 && percentX > 0.75))\n    {\n        float newCol = smoothstep(0.03,0.08,SDFHorizLine(vec2(percentX,percentY), 0.75));\n    \tcol = min(col, newCol);\n    }\n    \n\n    if ((topType == 1 && percentY < 0.75) ||\n        (bottomType == 1 && percentY > 0.75))\n    {\n        float newCol = smoothstep(0.0,0.05,SDFVertLine(vec2(percentX,percentY),0.75));\n    \tcol = min(col, newCol);\n    }\n    \n    if (leftType != rightType || topType != bottomType)\n    {\n        float newCol = smoothstep(0.01,0.03,SDFCircle(vec2(percentX,percentY),0.75,0.75,0.001));\n    \tcol = min(col, newCol);    \n    }\n    \n    return mix(vec3(0.125,0.125,0.5),incolor,col);\n}\n\nvec3 RenderTilePixelLevel3 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 1 && percentX < 0.25) ||\n        (rightType == 1 && percentX > 0.25))\n    {\n        float newCol = smoothstep(0.02,0.07,SDFHorizLine(vec2(percentX,percentY), 0.25));\n    \tcol = min(col, newCol);\n    }\n    \n\n    if ((topType == 0 && percentY < 0.25) ||\n        (bottomType == 0 && percentY > 0.25))\n    {\n        float newCol = smoothstep(0.0,0.05,SDFVertLine(vec2(percentX,percentY),0.25));\n    \tcol = min(col, newCol);\n    }\n    \n    if (leftType != rightType || topType != bottomType)\n    {\n        float newCol = smoothstep(0.03,0.05,SDFCircle(vec2(percentX,percentY),0.25,0.25,0.001));\n    \tcol = min(col, newCol);    \n    }\n    \n    return mix(vec3(0.5,0.125,0.125),incolor,col);\n}\n\nvec3 RenderTilePixelLevel4 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if (leftType == 0 && leftType == rightType)\n    {\n        float newCol = smoothstep(0.05,0.1,SDFHorizLine(vec2(percentX,percentY), 0.5));\n    \tcol = min(col, newCol);        \n    }\n    \n    if (topType == 0 && topType == bottomType)\n    {\n        float newCol = smoothstep(0.05,0.1,SDFVertLine(vec2(percentX,percentY), 0.5));\n    \tcol = min(col, newCol);        \n    }    \n    \n    if (leftType == 0 && leftType == topType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 0.0, 0.0,0.25)));\n    \tcol = min(col, newCol);        \n    }\n    \n    if (leftType == 0 && leftType == bottomType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 0.0, 1.0,0.25)));\n    \tcol = min(col, newCol);        \n    }    \n    \n    if (rightType == 0 && rightType == topType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 1.0, 0.0,0.25)));\n    \tcol = min(col, newCol);        \n    }\n        \n    if (rightType == 0 && rightType == bottomType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 1.0, 1.0,0.25)));\n    \tcol = min(col, newCol);        \n    }    \n    \n    return mix(vec3(0.85,0.85,0.125),incolor,col);\n}\n\nvec3 RenderTilePixel (int leftType, int topType, int rightType, int bottomType, float percentX, float percentY, vec3 bgColor)\n{\n    vec3 color = bgColor;    \n    color = RenderTilePixelLevel4(color,leftType,topType,rightType,bottomType,percentX,percentY);        \n    color = RenderTilePixelLevel3(color,leftType,topType,rightType,bottomType,percentX,percentY);    \n    color = RenderTilePixelLevel2(color,leftType,topType,rightType,bottomType,percentX,percentY);    \n    color = RenderTilePixelLevel1(color,leftType,topType,rightType,bottomType,percentX,percentY);\n    return color;\n}\n\nvec3 RenderAllTiles (vec2 pixel)\n{\n    float tileX = floor(pixel.x \/ (TILE_SIZE + TILE_PADDING));\n    float tileY = floor(pixel.y \/ (TILE_SIZE + TILE_PADDING));\n        \n    if (tileX < 0.0 || tileY < 0.0 || tileX > 3.0 || tileY > 3.0)\n        return vec3(0,0,0);\n        \n    float tileOffsetX = pixel.x - tileX * (TILE_SIZE + TILE_PADDING) - TILE_PADDING;\n    float tileOffsetY = pixel.y - tileY * (TILE_SIZE + TILE_PADDING) - TILE_PADDING;\n    \n    if (tileOffsetX < 0.0 || tileOffsetY < 0.0)\n        return vec3(0,0,0);\n    \n    tileOffsetX \/= TILE_SIZE;\n    tileOffsetY \/= TILE_SIZE;\n    \n    float tile = tileY * 4.0 + tileX;   \n    int leftType = int(mod(tile \/ 8.0,2.0));\n    int topType = int(mod(tile \/ 4.0,2.0));\n    int rightType = int(mod(tile \/ 2.0,2.0));    \n    int bottomType = int(mod(tile,2.0));\n\n    return RenderTilePixel(leftType,topType,rightType,bottomType,tileOffsetX,tileOffsetY, vec3(0,1,0));\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\n\nint CoinFlip (vec2 sampleAt, vec2 seed)\n{\n    return noise(sampleAt \/ seed) > 0.5 ? 1 : 0;\n}\n\nvec3 RenderScreen(vec2 pixel)\n{   \n    float shading = (sin(pixel.x)+1.0) \/ 2.0 * 0.2 + 0.8;\n    shading *= (sin(pixel.x*2.0)+1.0) \/ 2.0 * 0.2 + 0.8;\n    vec3 bgColor = vec3(0,1,0);\n    \n    float tileX = floor(pixel.x \/ TILE_SIZE);\n    float tileY = floor(pixel.y \/ TILE_SIZE);\n  \n  \tfloat tileOffsetX = fract(pixel.x \/ TILE_SIZE);\n    float tileOffsetY = fract(pixel.y \/ TILE_SIZE);\n    \n    \/\/ calculate our tile edges, making sure to be coherent with our neighbors!\n    int leftType   = CoinFlip(vec2(tileX-1.0,tileY    ), vec2(0.12,0.37));\n    int rightType  = CoinFlip(vec2(tileX,    tileY    ), vec2(0.12,0.37));\n\tint topType    = CoinFlip(vec2(tileX,    tileY-1.0), vec2(0.41,0.73));\n    int bottomType = CoinFlip(vec2(tileX,    tileY    ), vec2(0.41,0.73));\n\n\t\/\/ render the tile pixel!\n    return RenderTilePixel(leftType,topType,rightType,bottomType,tileOffsetX,tileOffsetY, bgColor) * shading;\n}\n    \nvoid main (void)\n{\n    \/\/ calculate our pixel's location in X,Y percent of the resolution of the screen\n    \/\/ and apply the aspect ratio to get rid of distortion. Also make y = 0 be at the\n    \/\/ top of the screen and center the display\n\tvec2 pixel = gl_FragCoord.xy \/ iResolution.xy;\n    pixel.y = 1.0 - pixel.y;\n    pixel.y = pixel.y - 0.5 + (TILE_SIZE + TILE_PADDING) * 2.0 + TILE_PADDING * 0.5;\n\n    float aspectRatio = iResolution.x \/ iResolution.y;\n    pixel.x -= 0.5;\n    pixel.x *= aspectRatio;\n    pixel.x += (TILE_SIZE + TILE_PADDING)*2.0 + TILE_PADDING * 0.5;\n    \n    vec3 color = vec3(0,0,0);\n\tif (iMouse.z > 0.0)\n    {\n    \tcolor = RenderAllTiles(pixel);\n    }\n    else\n    {\n    \tfloat scale = 0.5 + TILE_SCALE * (sin(iGlobalTime*0.33) * 0.5 + 0.5);\t\n  \t\tcolor = RenderScreen(pixel*scale + iGlobalTime * TILE_SCROLL);\n    }\n    \n    gl_FragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsBSRz","date":"1408116249","viewed":49,"name":"N Tunel","username":"Wingrime","description":"Well, thats my first raymach shader","likes":0,"published":1,"tags":["raymach"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\nvec3 l = normalize( vec3(1.0,1.0 ,-2.0) );\n\nfloat sdFloat(vec3 p, float s) {\n\treturn length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n        return length(max (abs(p) -b ,0.0) );\n}\n\nfloat lambert(vec3 n , vec3 l) {\n\treturn max(dot(n, l) , 0.0);\n}\nvec2 rot(vec2 r,float ang) {\n    return vec2(r.x* cos(ang) - r.y * sin(ang),  r.x*sin(ang) + r.y* cos(ang) ) ;\n}\nfloat obj(vec3 rp) {\nvec2 rotx =   rot(vec2(rp.x,rp.z) ,0.04*sin(iGlobalTime));\n\nvec3 trn = vec3(1.0,1.0,1.0);\n\nvec3 nrp1 = vec3(rotx.x ,rp.y , rotx.y + 5.0*iGlobalTime);\n\nvec3 nrp1_2 = nrp1+ vec3(0.5,0.5,0.0);\n\nvec3 nrp2= mod( nrp1_2,trn)-0.5*trn;\n\n\nfloat nrp3 = max(-sdFloat(nrp2,0.55), sdBox(nrp2, vec3(0.5,0.5 ,0.5 )  ) );\n\n\nreturn  nrp3;\n}\n\nvec3 est_normal(vec3 rp ) {\n\nconst float diff = 0.0001;\n\nvec3 x_p = vec3(diff ,0.0,0.0);\nvec3 x_m = vec3(-diff ,0.0,0.0);\n\nvec3 y_p = vec3(0.0,diff ,0.0);\nvec3 y_m = vec3(0.0,-diff ,0.0);\n\nvec3 z_p = vec3(0.0,0.0 ,diff);\nvec3 z_m = vec3(0.0,0.0,-diff);\n\n\nfloat x_diff = obj(rp+x_p) - obj(rp+x_m);\nfloat y_diff = obj(rp+y_p) - obj(rp+y_m);\nfloat z_diff = obj(rp+z_p) - obj(rp+z_m);\n\nreturn normalize(vec3(x_diff,y_diff,z_diff));\n\n}\n\n\nvec3 raymatch_iter2(vec3 ro , vec3 rd ) {\n\n        vec3 rp = ro;\n        float s = 0.0;\n        const int mstep = 20;\n        const float eps = 0.0001;\n        for (int i = 0; i < mstep ; i++) {\n\n                s = obj(rp);\n\n                rp = rp + rd*s;\n        }\n\n        vec3 n = est_normal(rp);\n        vec3 ret = vec3(0.0);\n\n        if (abs(s) < eps) {\n            ret = vec3(1.0)*lambert(n, l);\n         }\n\n        return ret;\n\n}\n\nvec3 raymatch(vec3 ro , vec3 rd ) {\n\n        vec3 rp = ro;\n        float s = 0.0;\n        const int mstep = 80;\n        const float eps = 0.0001;\n\tfor (int i = 0; i < mstep ; i++) {\n\n\t\n                s = obj(rp);\n\n                rp = rp + rd*s;\n                if (abs(s) < eps ) break;\n\t\n\t}\n\n        \/\/vec3 n = normalize(vec3 (rp));\n\n        vec3 n = est_normal(rp);\n        vec3 ret = vec3(0.0);\n\n        if (abs(s) < eps) {\n            \/\/ret = vec3(1.0)*lambert(n, l) ;\/\/+0.6*raymatch_iter2(rp+vec3(0.1), normalize(-reflect((rp-ro),n)));\n        ret = 0.5+0.5*n;\n        }\n\n        return ret;\n\n}\n\n\nvoid main ()\n{\n\n        vec2 uv = 2.0*(gl_FragCoord.xy \/ iResolution.xy)-1.0;\n        \/* projective*\/\n        vec3 ro = vec3(0.0 , 0.0 , -5.0 );\n        \/*ortogonal*\/\n        \/\/vec3 ro = vec3(uv.x , uv.y , -2.0 );\n\n        vec3 proj_plane = vec3 (uv.x , uv.y , -1.0 );\n\n\tvec3 rd = normalize( proj_plane - ro);\n\n\n\tvec3 res = raymatch(ro,rd);\n\n\tgl_FragColor = vec4(res,1.0);\n}\n\n\n\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdXXWl","date":"1408113078","viewed":121,"name":"Formant Synthesis","username":"WouterVanNifterick","description":"It says \"ShaderToy\" :) Very basic first version. To make it sound better, it still needs a correctly synced phase, filtered consonants, and a parametrized bandwidth, skirt and level per formant.  Any ideas or suggestions are welcome.","likes":2,"published":1,"tags":["audio","speech","formant","formants","voice","vocal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Formant Synthesizer\n\/\/\n\/\/ Wouter van Nifterick, 15 august 2014\n\/\/\n\/\/ 15 aug 2014\n\/\/\n\/\/ Original code for graphics taken from https:\/\/www.shadertoy.com\/view\/XdXGRB by Davis Hoskins\n\/\/ Just something to look at, while your graphics card talks to you :)\n\n#define font_size 15. \n#define font_spacing .08\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n#define E_ vec2(1.,1.)\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define STOP(p) t(N_,N_,p)\n\t\nvec2 caret_origin = vec2(2.0, .7);\nvec2 caret;\nfloat sp = 1.4; \/\/ speed\nfloat time = mod(1.+iGlobalTime,sp);    \n\n\n\/\/-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t\/\/ Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); \/\/length_squared(v, w);  \/\/ i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   \/\/ v == w case\n\t}\n\t\n\t\/\/ Consider the line extending the segment, parameterized as v + t (w - v).\n  \t\/\/ We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] \/ |w-v|^2\n  \tfloat t = dot(p - v, w - v) \/ l2;\n  \tif(t < 0.0) {\n\t\t\/\/ Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  \/\/ Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  \/\/ Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n\/\/-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); \/\/ basic distance from segment, thanks http:\/\/glsl.heroku.com\/e#6140.0\n\tinkNess += smoothstep(0., 1. , 1.- 14.*(nearLine - STROKEWIDTH)); \/\/ ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); \/\/ glow\n\treturn inkNess;\n}\n\n\/\/-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x \/ 2.) * .65 , 1.0-((letterspace.y \/ 2.) * .95) ));\n}\n\n\/\/-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > time*30.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n\/\/-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = gl_FragCoord.xy\/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n\/\/-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n\/\/-----------------------------------------------------------------------------------\n\n\/\/-----------------------------------------------------------------------------------\nvoid main(void)\n{\n\tfloat d = 0.;\n\tvec3 col = vec3(0);\n\t\n\tcaret = caret_origin;\n    \n    \n\n\t\/\/ the quick brown fox jumps over the lazy dog...\n\td += S(r()); add(); \n    d += H(r()); add(); \n    d += A(r()); add(); \n    d += D(r()); add(); \n    d += E(r()); add(); \n    d += R(r()); add(); \n    d += T(r()); add(); \n    d += O(r()); add(); \n    d += Y(r()); add(); \n        \n\t\/\/ d = clamp(d* (.75+sin(gl_FragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n    \n    d *= clamp(time+0.5,0.3,1.0);\n    d = clamp(d,0.,1.);\n    d = 1.5*d - iGlobalTime*0.15;\n      \n    col += vec3(d*.5, d*.85, d);\n\tvec2 xy = gl_FragCoord.xy \/ iResolution.xy;\n\tgl_FragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ Formant Synthesizer\n\/\/\n\/\/ Wouter van Nifterick, 15 august 2014\n\/\/\n\/\/ 15 aug 2014\n\n#define PI 3.1415926535897932384626433832795\n#define PI2 PI*2.0\n\nfloat formant(float pitch, float freq, float time)\n{   \n    \n    time += 0.07;\n    time = mod( time, PI \/ pitch);    \n    return  sin((2.0*PI)*freq*time)*exp(-30.0*time);\n\n}\n\n\nfloat s(float pitch, vec4 f, float time)\n{\n  return (\n    formant(pitch,f.x, time)*1.00+\n    formant(pitch,f.y, time)*0.96+\n    formant(pitch,f.z, time)*0.90+\n    formant(pitch,f.w, time)*0.85\n  ) * .25;\n}\n\nstruct Frame\n{\n  float time;\n  vec4 formants;\n};\n  \nvec2 mainSound(float time)\n{    \n    float env = exp(-.5*time)*.5;\n    float sp = 1.4; \/\/ speed\n    float t = mod(time,sp);\n    float pitch = 250.0+sin(time*2.6)*20.; \/\/ fundamental freq\n    \n    \n    float sample = 0.0;\n    #define fmt(tm,v) if(t>tm*sp)sample=s(pitch,v,t);\n   \n    Frame frames[63];\n    frames[ 0] = Frame(0.046, vec4(2358.0,2820.0,3844.0,4854.0));\n    frames[ 1] = Frame(0.055, vec4(2246.0,2846.0,3964.0,4898.0));\n    frames[ 2] = Frame(0.064, vec4(2202.0,2628.0,3786.0,4482.0));\n    frames[ 3] = Frame(0.073, vec4(1969.0,2568.0,3815.0,4668.0));\n    frames[ 4] = Frame(0.082, vec4(1944.0,2499.0,3620.0,4708.0));\n    frames[ 5] = Frame(0.091, vec4(2046.0,2537.0,3420.0,4696.0));\n    frames[ 6] = Frame(0.100, vec4(2449.0,2700.0,3883.0,4773.0));\n    frames[ 7] = Frame(0.109, vec4(2185.0,2636.0,3839.0,4846.0));\n    frames[ 8] = Frame(0.118, vec4(2025.0,2672.0,3585.0,4685.0));\n    frames[ 9] = Frame(0.127, vec4(2259.0,2705.0,3193.0,4501.0));\n    frames[10] = Frame(0.136, vec4(2251.0,2628.0,3488.0,4610.0));\n    frames[11] = Frame(0.154, vec4(2110.0,2680.0,3322.0,4603.0));\n    frames[12] = Frame(0.163, vec4( 714.0,2168.0,2987.0,4354.0));\n    frames[13] = Frame(0.172, vec4( 678.0,2048.0,2877.0,3544.0));\n    frames[14] = Frame(0.181, vec4( 664.0,1965.0,2510.0,3473.0));\n    frames[15] = Frame(0.199, vec4( 659.0,1867.0,2450.0,3474.0));\n    frames[16] = Frame(0.244, vec4( 596.0,1836.0,2482.0,3419.0));\n    frames[17] = Frame(0.271, vec4( 491.0,1992.0,2579.0,3438.0));\n    frames[18] = Frame(0.280, vec4( 451.0,2059.0,2622.0,3446.0));\n    frames[19] = Frame(0.334, vec4( 341.0,2114.0,2739.0,3505.0));\n    frames[20] = Frame(0.343, vec4( 327.0,2096.0,2799.0,3561.0));\n    frames[21] = Frame(0.352, vec4( 265.0,1876.0,2904.0,3706.0));\n    frames[22] = Frame(0.361, vec4( 263.0,1681.0,2969.0,3937.0));\n    frames[23] = Frame(0.388, vec4( 254.0,1828.0,3149.0,4153.0));\n    frames[24] = Frame(0.397, vec4( 290.0,1859.0,3234.0,4100.0));\n    frames[25] = Frame(0.406, vec4( 320.0,1867.0,3106.0,4013.0));\n    frames[26] = Frame(0.415, vec4( 340.0,1823.0,3044.0,4028.0));\n    frames[27] = Frame(0.424, vec4( 365.0,1626.0,2994.0,3937.0));\n    frames[28] = Frame(0.433, vec4( 467.0,1586.0,2767.0,3420.0));\n    frames[29] = Frame(0.442, vec4( 480.0,1548.0,2570.0,3364.0));\n    frames[30] = Frame(0.451, vec4( 497.0,1509.0,2462.0,3307.0));\n    frames[31] = Frame(0.559, vec4( 565.0,1456.0,2508.0,3433.0));\n    frames[32] = Frame(0.568, vec4( 614.0,1484.0,2705.0,3569.0));\n    frames[33] = Frame(0.577, vec4( 614.0,1488.0,2511.0,3517.0));\n    frames[34] = Frame(0.586, vec4( 800.0,1459.0,2786.0,5437.0));\n    frames[35] = Frame(0.604, vec4(1267.0,2153.0,3075.0,4030.0));\n    frames[36] = Frame(0.613, vec4(1458.0,2456.0,3438.0,4313.0));\n    frames[37] = Frame(0.622, vec4(1319.0,2342.0,3386.0,4337.0));\n    frames[38] = Frame(0.631, vec4(1181.0,2238.0,3311.0,4216.0));\n    frames[39] = Frame(0.640, vec4(1151.0,2229.0,3417.0,4407.0));\n    frames[40] = Frame(0.649, vec4(1089.0,2217.0,3435.0,4328.0));\n    frames[41] = Frame(0.658, vec4(1010.0,2418.0,3451.0,3979.0));\n    frames[42] = Frame(0.667, vec4(1183.0,2601.0,3922.0,4878.0));\n    frames[43] = Frame(0.676, vec4(1271.0,2505.0,2803.0,3966.0));\n    frames[44] = Frame(0.685, vec4( 739.0,2109.0,3046.0,3919.0));\n    frames[45] = Frame(0.694, vec4( 708.0,1298.0,2695.0,3944.0));\n    frames[46] = Frame(0.703, vec4( 491.0, 883.0,2741.0,3620.0));\n    frames[47] = Frame(0.712, vec4( 585.0, 941.0,2721.0,3140.0));\n    frames[48] = Frame(0.757, vec4( 708.0,2723.0,3042.0,3951.0));\n    frames[49] = Frame(0.766, vec4( 242.0, 714.0,2712.0,3053.0));\n    frames[50] = Frame(0.775, vec4( 518.0, 718.0,2705.0,3051.0));\n    frames[51] = Frame(0.793, vec4( 593.0, 771.0,2674.0,3059.0));\n    frames[52] = Frame(0.829, vec4( 522.0, 822.0,2620.0,3074.0));\n    frames[53] = Frame(0.838, vec4( 567.0, 880.0,2596.0,3079.0));\n    frames[54] = Frame(0.847, vec4( 541.0, 975.0,2532.0,3091.0));\n    frames[55] = Frame(0.856, vec4( 540.0,1044.0,2484.0,3108.0));\n    frames[56] = Frame(0.874, vec4( 519.0,1167.0,2403.0,3142.0));\n    frames[57] = Frame(0.892, vec4( 492.0,1309.0,2312.0,3160.0));\n    frames[58] = Frame(0.910, vec4( 476.0,1467.0,2239.0,3180.0));\n    frames[59] = Frame(0.928, vec4( 438.0,1720.0,2226.0,3229.0));\n    frames[60] = Frame(0.946, vec4( 406.0,1920.0,2250.0,3307.0));\n    frames[61] = Frame(0.982, vec4( 350.0,1973.0,2374.0,3390.0));\n    frames[62] = Frame(1.000, vec4( 322.0,2031.0,2474.0,3430.0));\n           \n    float slide=.0;\n    \n    Frame v,w;\n    vec4 n = frames[0].formants;\n    vec4 k;\n    for(int i=1;i<62;i++)\n    {\n        float nt = frames[i+1].time;\n        float pt = frames[i-1].time;\n        if(t>frames[i].time*sp)\n        {\n\n            k = frames[i].formants;\n            k += n*slide;\n            k \/= slide+1.0;           \n            sample=s(pitch,k,t);\n            n = k;\n\n        }\n    }\n\n    #define a(tm,amp) if(t>tm*sp) intensity=amp;\n    \/\/ adjust overall intensity curve\n    float intensity;        \n    a(0.000,0.3); \n    a(0.040,0.9); \n    a(0.358,0.1);\n    a(0.403,0.9); \n    a(0.572,0.1); \n    a(0.633,0.9);\n    \n    \n    sample *=intensity;\n    sample *= env;       \n    \n    return vec2( sample );\n}","name":"","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"XsSSRz","date":"1408111927","viewed":104,"name":"Tiny Ray Marcher 3.0","username":"Aaro","description":"Oh its on. I'm sure comment section will be full with compacting suggestions... probs about the normal calculation.\n1.0 version: https:\/\/www.shadertoy.com\/view\/MdfXWl\n2.0 version: https:\/\/www.shadertoy.com\/view\/ldsXDs","likes":1,"published":1,"tags":["reflection","ray","shadow","marching","tiny"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/Tiny Ray Marcher 3.0\n\n\/\/Originally written by Aaro Per\u00e4maa, compacting by Ben and Dave_Hoskins\n\/\/466 characters\n\n#define k =min(length(p-q)-a,p.y+a);p+=j\n#define v vec3\nvoid main()\n{\n    v R=iResolution;\n\tv u=(2.*gl_FragCoord.xyz-R)\/R.y;\n\tfloat t=0.,r=1.,c=t,h=3.,s=t,a=r,b=.1;\n\tu.z=r;\n\tv o=u,p=u,q=v(7,abs(sin(iGlobalTime*h)),4),l=q.xxz,g=u,j=v(0,-b,b);\n\tq.x=t;\n\tfor(int i=0;i<192;i++)\n\t{\n\t\tp=u*t+o;\n\t\th k-j;\n\t\ti>127 ?r=min(r,8.*h\/t):h<.001 ? c=5.\/length(p-l):t;\n\t\tt+=h;\n\t\tif(i==63){\n\t\t\to=p;\n\t\t\ts=c;\n\t\t\th k.zxx;\n\t\t\tt k.yzx;\n\t\t\tr k;\n\t\t\tp.x k;\n\t\t\tu=reflect(u,normalize(v(t,r,p.x)-h));\n\t\t\tt=b;\n\t\t\tr=a;\n\t\t}\n\t\tif(i==127){\n\t\t\tu=normalize(l-o);\n\t\t\tt=b;\n\t\t}\n\t}\n\tgl_FragColor=vec4(c*r);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dSSRz","date":"1408108183","viewed":44,"name":"Deforming Lights ","username":"atmarksharp","description":"Deforming Lights with HSV Gradations.","likes":0,"published":1,"tags":["light","color","deform"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"float width = iResolution.x;\nfloat height = iResolution.y;\nfloat ms = iGlobalTime * 0.06;\n\nconst float PI = 3.141592653589793;\nconst float DEEP_COLOR_RATE = 0.8;\n\nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n \n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n \n\tcolor.rgb += v - c;\n \n\treturn color;\n}\n\nfloat get_rate(float n){\n\treturn n * PI;\n}\n\nfloat myfuncX(float n, float _time){\n\tfloat rate = n*sin(_time);\n\treturn (abs(2.0*cos(rate)*sin(3.0*rate)) + abs(sin(cos(2.0*rate)))) \/ 2.0;\n}\n\nfloat myfuncY(float n, float _time){\n\tfloat rate = n*cos(_time);\n\treturn (abs(sin(rate)*1.5*cos(2.6*rate)) + abs(sin(-sin(2.0*rate)))) \/ 2.0;\n}\n\nfloat myconv(float x, float y, float _time){\n\tfloat mil = _time*3.0;\n\treturn myfuncX(get_rate(x\/width), mil) * myfuncY(get_rate(y\/height), mil);\n}\n\nvec4 get_color(float n, float _time){\n\tfloat m = _time*0.5;\n\treturn hsv_to_rgb(m, 1.0, n, ((width - gl_FragCoord.x)\/width)+0.6);\n}\n\nvec4 get_depth(float x, float y, float millis){\n\treturn get_color(myconv(x,y,millis), millis);\n}\n\nvoid main(){\n\tfloat x = gl_FragCoord.x;\n\tfloat y = gl_FragCoord.y;\n\n\tgl_FragColor = get_depth(x, y, ms);\n}\n\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lssXDs","date":"1408065064","viewed":139,"name":"1, 2, 3 fractal","username":"demofox","description":"Creating a fractal is as easy as 1,2,3 (;\nVisualization of counting in binary.","likes":3,"published":1,"tags":["2d","fractal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ the size of each dot, in UV space\n#define BIT_SIZE 0.0125\n\n\/\/ used when controlling scale with the mouse\n#define SCALE_MIN BIT_SIZE \/ 2.0\n#define SCALE_MAX 0.0625\n\nvoid main(void)\n{\n    \/\/ let mouse y control scale if mouse button pressed\n    float scale = BIT_SIZE;\n    if( iMouse.z > 0.0 )\n        scale = iMouse.y \/ iResolution.y * (SCALE_MAX - SCALE_MIN) + SCALE_MIN;\n    \n    \/\/ get the uv coordinate of our pixel.\n    \/\/ Make UV's square and scroll the image to the left, starting at the right\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n    uv.x *= iResolution.x \/ iResolution.y;\n    uv.x = max(0.0,uv.x + iGlobalTime - iResolution.x \/ iResolution.y);\n        \n    \/\/ put it up near the middle of the screen and bail out below the x axis.\n    uv.y -= 0.5;\n    if (uv.y < 0.0)\n        gl_FragColor = vec4(vec3(0.0),1.0);\n    \n\t\/\/ if our column number (y) has our row bit set (x), then\n    \/\/ set the color to white, else set it to black\n    float row = floor(uv.y \/ scale);\n    float col = floor(uv.x \/ scale);\n    float color=mod(floor(col\/pow(2.0,row)),2.0);\n    \n    \/\/ make each bit into an anti aliased circle\n    float rx = fract(uv.x \/ scale) - 0.5;\n    float ry = fract(uv.y \/ scale) - 0.5;\n    float dist = sqrt(rx*rx+ry*ry);\n    color *= smoothstep(0.6,0.3,dist);\n    \n    \/\/ return the color\n    gl_FragColor = vec4(vec3(color),1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdSXzR","date":"1408062864","viewed":56,"name":"Julia Set.","username":"puzzleweaver","description":"Just a simple complex julia set, the actual set colored.","likes":0,"published":1,"tags":["2d","fractals"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"const int mi = 60;\n\nvoid main(void) {\n    vec2 z = (gl_FragCoord.xy-(iResolution\/2.0).xy)\/400.0, c = (iMouse.xy\/iResolution.xy - vec2(0.5, 0.5))*3.0;\n    float ozx;\n    for(int iters = 0; iters < mi; iters++){\n        ozx = z.x;\n        z.x = z.x*z.x-z.y*z.y + c.x;\n        z.y = ozx*z.y*2.0 + c.y;\n        if(length(z) > 2.0){\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n    }\n    float n = sin(length(z))\/2.0+0.5;\n    gl_FragColor = vec4(n, n, n, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dBXRR","date":"1408049198","viewed":53,"name":"mouse & noise test","username":"nexor","description":".","likes":0,"published":1,"tags":["noise","mouse"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"float hash( float n ){\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise( vec2 uv ){\n\tvec3 x = vec3(uv, 0);\n\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf       = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\treturn mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\t\t   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat2 m = mat2(0.8,0.6,-0.6,0.8);\n\nfloat fbm(vec2 p)\n{\n \tfloat f = 0.0;\n    f += 0.5000*noise( p ); p*=m*2.02;\n    f += 0.2500*noise( p ); p*=m*2.03;\n    f += 0.1250*noise( p ); p*=m*2.01;\n    f += 0.0625*noise( p );\n    f \/= 0.9375;\n    return f;\n}\n\nvec2 worldcoord(vec2 p)\n{\n \tp = -1.0+2.0*p\/iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n    return p;\n}\n\nvoid main(void)\n{   \n    vec2 p = worldcoord(gl_FragCoord.xy);\n    \n    vec2 center = vec2(0.0);\n    vec2 mouse = worldcoord(iMouse.xy);\n    \n    float f = fbm( 1.0*(p - mouse) + m*vec2(0.5,0.1)*iGlobalTime*0.35 );\n    \n    vec3 col = vec3(0.0);\n    \n    if ( f < 0.2)\n    {\n     \tcol = mix(vec3(0.0),vec3(0.35,0.0,0.0),f);\n    }\n    else if(f < 0.6)\n    {\n    \tcol = mix(vec3(0.4,0.0,0.0),vec3(0.8,0.2,0.0),smoothstep(0.4,0.5,f));\n    }\n    else\n    {\n     \tcol = mix(vec3(0.8,0.2,0.0),vec3(1.0,1.0,0.0),smoothstep(0.7,0.8,f));   \n    }\n    \n    col = sqrt(col);\n    \n\tgl_FragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdsXDl","date":"1408043218","viewed":129,"name":"Circle Beat","username":"shotgan","description":"My first attempt on creating one shader scene.\n","likes":5,"published":1,"tags":["circles","arcs"],"hasliked":0},"renderpass":[{"inputs":[{"id":19,"src":"\/presets\/mzk02.mp3","ctype":"music","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"const float Pi = 3.14159;\n\nvec2 q;\n\nfloat circle(float rad, float size){\n\n    return (1.0-smoothstep(rad+size,rad+size+0.01, length(q))) * smoothstep(rad, rad + 0.01, length(q)) ; \n\n}\n\nvoid main(void)\n{\n    \n    vec2 p = gl_FragCoord.xy \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n    p.x -= 0.39;\n\n    float fft  = texture2D( iChannel0, vec2(0.02,0.0) ).x; \n    float fft2  = texture2D( iChannel0, vec2(0.9,0.0) ).x; \n    \n    float fff = (fft-0.4)*1.6;\n    float fff2 = (fft2)*2.6;\n    \n    float tim = iChannelTime[0];\n    \n    q = p - vec2(0.5, 0.5);\n    \n    vec3 col = vec3(0.14, 0.14, 0.14); \/\/ gray\n\n    \n    vec3 col2 = vec3( 0.96, 0.47, 0.43); \/\/ salmon\n    vec3 col3 = vec3( 0.42, 0.18, 0.10); \/\/ brown\n    vec3 col4 = vec3( 0.20, 0.13, 0.15); \/\/ Purple\n    vec3 col5 = vec3( 0.87, 0.50, 0.18); \/\/ orange\n    vec3 col6 = vec3( 0.63, 0.67, 1.0); \/\/ blue\n    \n    col *= step(0.31+(fft*0.45)-0.3, length(q));\n          \n    col2 *= circle(0.2,0.06 + pow(0.01, (fft*0.9)-0.2));    \n    \n    float angle = atan( q.y, q.x ) + Pi;\n    float mod = sqrt(q.y*q.y+q.x*q.x);\n    \n    float angle2 = angle + (sin(tim*2.0)*3.0)+fff  ;\n\n    vec2 qr;\n    qr.y = sin(angle2)*mod;\n    qr.x = cos(angle2)*mod;\n            \n    float t = (atan( qr.y, qr.x ) + Pi) \/ (2.0 * Pi);\n    \n    col2 *= 1.0- smoothstep(0.12+fff, 0.125+fff, t);\n    col2 *= smoothstep(0.0, 0.005, t);\n\n    col += col2;\n\n\tfloat colm = fff*0.3;\n    \n    col3 += vec3( fff2*colm, fff2*colm, fff2*colm); \n    col3 *= circle(0.145+fff2*0.01, 0.03);\t\n    col += col3;\n\n    \n    angle2 = angle + (sin(tim*1.0)*6.0)+fff  ;\n\n    qr.y = sin(angle2)*mod;\n    qr.x = cos(angle2)*mod;\n            \n    t = (atan( qr.y, qr.x ) + Pi) \/ (2.0 * Pi);\n\n    col4 *= 2.5*fff2;\n    col4 *= circle(0.03, 0.08);\t\n    col4 *= 1.0-smoothstep(0.2+fff2*0.8, 0.205+fff2*0.8, t);    \n    col4 *= smoothstep(0.0, 0.005, t);\n    col += col4;\n\n    col5 *= 1.0 - smoothstep(0.01+fff*0.04, 0.018+fff*0.04, length(q));\t\n    col += col5;\n\t\n    \n    \n    vec3 colcol = col6;\n    for(int i=0;i<6;i++) {\n    \n        col6 = colcol;\n        angle2 = (angle + fff*3.0 + ((2.0*Pi\/6.0)*(float(i)))) + sin(tim*float(i)) ;\n\n        qr.y = sin(angle2)*mod;\n        qr.x = cos(angle2)*mod;\n\n        float t = (atan( qr.y, qr.x ) + Pi) \/ (2.0 * Pi);\n        col6 *= circle(0.0, 3.5);\t\n        col6 *= 1.0-smoothstep(0.03*fff*1.0, 0.035*fff*1.5, t);    \n        col6 *= smoothstep(0.0, 0.01, t);\n        col += col6;\n    }\n    \n    gl_FragColor = vec4(col, 1.0);\n    \n   \n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dSXRR","date":"1408042892","viewed":73,"name":"Wavy Shader","username":"lexicobob","description":"first play with shader toy.\n\nsin wave interpolated to stop distortion at top and bottom. ","likes":1,"published":1,"tags":["2dwavy"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"void main(void)\n{\n\tfloat frequency = 8.0;\n\tfloat amplitude = 0.05;\n\t\n    vec2 texCoord = gl_FragCoord.xy \/ iResolution.xy;\n    \n    vec2 pulse = sin(iGlobalTime - frequency * texCoord);\n    float dist = 2.0 * length(texCoord.y - 0.5);\n    \n    vec2 newCoord = texCoord + amplitude * vec2(0.0, pulse.x); \/\/ y-axis only; \n    \n    vec2 interpCoord = mix(newCoord, texCoord, dist);\n\t\n\tgl_FragColor = texture2D(iChannel0, interpCoord);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dBSRR","date":"1408037198","viewed":85,"name":"1D Sound","username":"Xor","description":"An interesting test. It seems to quit at about 20 seconds in for some reason.","likes":1,"published":1,"tags":["procedural"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"float noise(float n,float s,float res)\n{\n\tfloat a = fract(sin(((floor((n)\/s-0.5)*s)\/res)*43632.6326)*53356.6426);\n\tfloat b = fract(sin(((floor((n)\/s+0.5)*s)\/res)*43632.6326)*53356.6426);\n\treturn mix(a,b,smoothstep(0.0,1.0,+mod(n\/s+0.5,1.0)));\n}\nvoid main(void)\n{\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n\tgl_FragColor = vec4(vec3(uv.y-noise(iGlobalTime+uv.x,1.,800.)),1.0);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float noise(float n,float s,float res)\n{\n\tfloat a = fract(sin(((floor((n)\/s-0.5)*s)\/res)*43632.6326)*53356.6426);\n\tfloat b = fract(sin(((floor((n)\/s+0.5)*s)\/res)*43632.6326)*53356.6426);\n\treturn mix(a,b,smoothstep(0.0,1.0,+mod(n\/s+0.5,1.0)));\n}\nvec2 mainSound(float time)\n{\n    return vec2( cos(noise(time,1.,800.)*1800.));\n}","name":"","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"XdSSRR","date":"1408035117","viewed":47,"name":"Voronoi + Julia","username":"squid","description":"Playing with combining the Julia set with the Voronoi set, using iq's voronoi function. There could possibly be a better, more beautiful way, to do this","likes":1,"published":1,"tags":["2d","fractal","voronoi","julia"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"#define ANIMATE\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(p)*43758.5453);\n}\nfloat julia(in vec4 p)\n{\n    const int ITR = 20;\n    vec2 z = p.xy; vec2 c = p.zw;\n    int idx = ITR;\n    for(int i = 0; i < ITR; ++i) \n    {\n        vec2 r = vec2((dot(z,z*vec2(1., -1.)))+c.x, \n                       dot(z.yx,z.xy)+c.y);\n        if(dot(r,r) > 4.)\n        {\n            idx = i;\n            break;\n        }\n        z = r;\n    }\n    float v = mod(float(idx), 50.) \/ 50.;\n    return length(z);\n}\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec2 m = vec2( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( .5*iGlobalTime + 6.2831*o );\n        #endif\t\n\t\tvec2 r = g - f + o;\n\t\tfloat d = dot(r,r);\n        if( d<m.x )\n        {\n            m.x = d;\n            m.y = hash( dot(n+g,vec2(7.0,113.0) ) );\n        }\n    }\n    return vec2( sqrt(m.x), m.y );\n}\n\n\n\nvec2 mpx(in vec2 p)\n{\n    float apc = iResolution.x\/iResolution.y;\n    return vec2(2.5*apc, 2.5)*(p - vec2(.5));\n}\n\n\/\/from: http:\/\/lolengine.net\/blog\/2013\/07\/27\/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid main(void)\n{\n\tvec2 uv = mpx(gl_FragCoord.xy \/ iResolution.xy);\n    uv *= 1.25;\n    \n   \tvec3 col = vec3(0.); \n      \n    float j = julia(vec4(uv, vec2(sin(iGlobalTime*.1)*1.2)*voronoi(uv).xx ));\n    if(j < 2.) col += hsv2rgb(vec3((j\/4.)+.15, 1., .8));\n    vec2 v = voronoi(uv);\n    col += hsv2rgb(vec3(v.y, 1., .3));\n    \n\tgl_FragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}]