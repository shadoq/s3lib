[{"ver":"0.1","info":{"id":"XdsSWs","date":"1407871114","viewed":100,"name":"SIG2014 Hackathon","username":"tommywalton","description":"SIGGRAPH 2014 Shadertoy Hackathon entry","likes":3,"published":1,"tags":["2014","hackathon","siggraph","sig2014"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Created by Tommy Walton\n\/\/ Combining the work of https:\/\/www.shadertoy.com\/view\/4sl3zn and https:\/\/www.shadertoy.com\/view\/MdX3zr\n\nvec2 disp( in vec3 p )\n{\n\treturn vec2( pow( 0.0, 2.0 ),\n                 pow( 0.5 + 0.5*cos( 25.0*p.x  + 1.5*iGlobalTime)*\n\t\t\t\t\t            sin( 25.0*p.y  + 2.0*iGlobalTime )*\n\t\t\t\t\t            sin( 25.0*p.z  + 1.0*iGlobalTime ), 3.0) );\n}\n\nfloat obj( in vec3 p )\n{\n\tvec3 ax = vec3(-2.0,2.0,1.0)\/3.0;\n\tvec3 ce = vec3(0.0,-0.2,-0.2);\n\n\tfloat d1 = dot(p,ax) - 0.1;\n    float d2 = length(p) - 1.0;\n\tfloat d3 = length( p-ce - ax*dot(p-ce,ax)) - 1.0;\n\n\treturn max( max( d1, d2 ), -d3 );\n}\n\n\nvec2 map( in vec3 p )\n{\n\tfloat d1 = obj( p );\n\tfloat d2 = obj( p*vec3(-1.0,-1.0,1.0) );\n\n    vec2        res = vec2( d1, 0.0 );\n\tif( d2<d1 ) res = vec2( d2, 1.0 );\n\n\tvec2 di = disp( p );\n\tres.x -= 0.04*di.x*di.y;\n\n\treturn res;\n}\n\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat t = 0.0;\n\tvec2 h = vec2( -1.0 );\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro+rd*t);\n\t\tt += h.x;\n\t}\n\t\n\tif( h.x<0.1 ) return vec2(t,h.y);\n\n\treturn vec2(-1.0);\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h\/t );\n        t += h;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat noise(vec3 p) \/\/Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(.25,.5,1.), vec4(.0,-.95,.0,1.));\n\treturn d + (noise(p+vec3(.0,iGlobalTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)\/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvec4 fire(){\n    \/\/flame\n        vec2 vf = -1.0 + 2.0 * gl_FragCoord.xy \/ iResolution.xy;\n\tvf.x *= iResolution.x\/iResolution.y;\n        \n        vec3 orgf = vec3(0., -2., 4.);\n\tvec3 dirf = normalize(vec3(vf.x*1.6, -vf.y, -1.5));\n\t\n\tvec4 pf = raymarch(orgf, dirf);\n\tfloat glowf = pf.w;\n\t\n\tvec4 colf = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), pf.y*.02+.4);\n\t\n\treturn mix(vec4(0.), colf, pow(glowf*2.,4.));\n}\n\nfloat magnitude(vec4 col){\n\treturn (col.r + col.g + col.b);\n}\n\nvoid main(void)\n{\n    vec2 p = -1.0 + 2.0 * gl_FragCoord.xy \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n\n    vec2 m = iMouse.xy\/iResolution.xy;\n\tif( iMouse.z<0.0 ) m = vec2(0.0);\n\t\n    \/\/ camera\n\tfloat an = -6.2*m.x + 0.2*sin(0.5*iGlobalTime) + 6.5;\n    vec3 ro = 1.5*normalize(vec3(sin(an),-6.0*m.y, cos(an)));\n\n    vec3 ww = normalize( vec3(0.0,0.0,0.0) - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n    vec3 col = vec3(1.0);\n\n\t\/\/ raymarch\n    vec2 tmat = intersect(ro,rd);\n    if( tmat.y>-0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd,nor);\n\t\tvec3 lig = normalize(vec3(-0.6,0.5,0.2));\n\t\tvec2 dis = disp( pos );\n     \n        \n        \n        \/\/ lights\n        float con = 1.0;\n        float amb = 0.5 + 0.5*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lig.x,lig.y,-lig.z)),0.0);\n        float rim = pow(1.0+dot(nor,rd),8.0);\n        float spe = pow(clamp(dot(lig,ref),0.0,1.0),8.0);\n        float occ = mix( 1.0, 0.9 + 3.0*dis.y, dis.x );\n\n\t\t\/\/ shadow\n\t\tfloat sh = softshadow( pos, lig, 0.01, 8.0 );\n\t\tdif *= sh;\n\t\tspe *= sh;\n\t\trim *= sh;\n\t\t\n        col  = 0.10*con*vec3(1.0)*occ;\n        col += 1.00*dif*vec3(1.0,0.8,0.6);\n        col += 0.40*bac*vec3(1.0)*occ;\n        col += 0.25*amb*vec3(0.6,0.8,1.0)*occ;\n\n        \/\/ material\n\t\tcol *= mix( vec3(0.7,0.1,0.1), vec3(0.0,0.2,1.0), tmat.y );\n\t\t\n\t\t\/\/ speculars\n        col += 0.50*spe*vec3(1.0);\n\t\tcol += 1.00*rim*vec3(1.0);\n\t\n\t\t\n        \/\/ gamma\n        col = sqrt(col);\n    }\n\n\tvec4 firecol = fire();\n    col *= magnitude(firecol);\n    gl_FragColor = vec4(col, 1.0);\n    \/\/gl_FragColor = vec4( col.r * firecol.r, col.g * firecol.g, col.b * firecol.b, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4ssXWs","date":"1407871016","viewed":58,"name":"SIG2014_HERBST","username":"herbst","description":"should become an deterministic ifs renderer.","likes":2,"published":1,"tags":["fractal","ifs"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Tweak these to get different results\nconst int   NUM_CIRCLES \t= 17;\nconst float TIME_MULTIPLIER = 3.0;\nconst float CONSTANT_N\t    = 3.0;\n\nconst float N = CONSTANT_N;\n\n\/\/ Actual code below\n\n#define TWO_PI 6.28318530718\n#define TWO_THIRDS_PI 2.09439510239\n\n\nvec2 curUV;\n\nvec3 drawCircle(vec2 p, vec2 center, float radius, float edgeWidth, vec3 color)\n{\n    float dist = length(p - center);\n   \t\n    vec3 ret;\n\tret = color * (1.0 - smoothstep(radius, radius+edgeWidth, abs(dist-0.35) ));\n   \n    return ret;\n} \n\nvec3 draw(mat3 mat) {\n  \/\/ get center\n    return drawCircle(curUV, vec2(mat[2][0], mat[2][1]), 0.001, 0.01, vec3(1,1,1));\n}\n\n\n\nmat3 t1,t2;\n\n\/\/ shadertoy gives unknown error on try of recursion, thus\n\/\/ duplication...\n\nvec3 rec5(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    \/\/col += rec5(tt1,iter-1);\n    \/\/col += rec5(tt2,iter-1);\n    \n    return col;\n}\n\n\nvec3 rec4(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec5(tt1,iter-1);\n    col += rec5(tt2,iter-1);\n    \n    return col;\n}\n\nvec3 rec3(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec4(tt1,iter-1);\n    col += rec4(tt2,iter-1);\n    \n    return col;\n}\n\nvec3 rec2(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec3(tt1,iter-1);\n    col += rec3(tt2,iter-1);\n    \n    return col;\n}\n\n\nvec3 rec(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec2(tt1,iter-1);\n    col += rec2(tt2,iter-1);\n    \n    return col;\n}\n\nvoid main(void)\n{\n\t\/\/ Map coordinates into a small window around [-1, 1]\n\tvec2 uv = (gl_FragCoord.xy*2.0 - iResolution.xy) \/ iResolution.y;\n\tuv *= 1.2;\n\t\n    t1 = mat3(0.9,-.2,0.0,sin(iGlobalTime),0.9,0,-0.4,.3 + cos(iGlobalTime * 0.2),0);\n    t2 = mat3(0.5,-0.3 + cos(iGlobalTime * 0.8 + 0.1),0.1,0.2 + sin(iGlobalTime * 1.3),0.8,0,0.1,-0.2,0);\n    \n    \n\tvec3 color = vec3(0.0);\n\tfloat angleIncrement = TWO_PI \/ float(NUM_CIRCLES);\n    \n    mat3 tcur = mat3(1,0,0,0,1,0,0, 0,0);\n    \n    curUV = uv;\n\tcolor += rec(tcur,5);\n    \n    \/*\n\tfor (int i = 0; i < NUM_CIRCLES; ++i) {\n\t\tfloat t = angleIncrement*(float(i));\n\t\tfloat r = sin(float(N)*t+iGlobalTime*TIME_MULTIPLIER);\n\t\tvec2 p = vec2(r*cos(t), r*sin(t));\n\n\t\tvec3 circleColor = vec3(sin(t),\n\t\t\t\t\t\t\t\tsin(t+TWO_THIRDS_PI),\n\t\t\t\t\t\t\t\tsin(t+2.0*TWO_THIRDS_PI))*0.5+0.5;\n\n        float radius = 0.06;\n       color += drawCircle(curUV, p, radius, 0.01, circleColor);\n\t}\n\t*\/\n\t\n\tgl_FragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdlSDs","date":"1407870776","viewed":357,"name":"[SIG2014] - Total Noob","username":"dynamite","description":"A circle of color with shape - first shadertoy, this was fun!","likes":10,"published":1,"tags":["2d","colors","noob"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"void main(void)\n{\n\tvec2 p = (2.0*gl_FragCoord.xy-iResolution.xy)\/iResolution.y;\n    float tau = 3.1415926535*2.0;\n    float a = atan(p.x,p.y);\n    float r = length(p)*0.75;\n    vec2 uv = vec2(a\/tau,r);\n\t\n\t\/\/get the color\n\tfloat xCol = (uv.x - (iGlobalTime \/ 3.0)) * 3.0;\n\txCol = mod(xCol, 3.0);\n\tvec3 horColour = vec3(0.25, 0.25, 0.25);\n\t\n\tif (xCol < 1.0) {\n\t\t\n\t\thorColour.r += 1.0 - xCol;\n\t\thorColour.g += xCol;\n\t}\n\telse if (xCol < 2.0) {\n\t\t\n\t\txCol -= 1.0;\n\t\thorColour.g += 1.0 - xCol;\n\t\thorColour.b += xCol;\n\t}\n\telse {\n\t\t\n\t\txCol -= 2.0;\n\t\thorColour.b += 1.0 - xCol;\n\t\thorColour.r += xCol;\n\t}\n\n\t\/\/ draw color beam\n\tuv = (2.0 * uv) - 1.0;\n\tfloat beamWidth = (0.7+0.5*cos(uv.x*10.0*tau*0.15*clamp(floor(5.0 + 10.0*cos(iGlobalTime)), 0.0, 10.0))) * abs(1.0 \/ (30.0 * uv.y));\n\tvec3 horBeam = vec3(beamWidth);\n\tgl_FragColor = vec4((( horBeam) * horColour), 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdsSDl","date":"1407870461","viewed":137,"name":"SIG2014 - PlasmaBall","username":"kaspard","description":"Speed coding by Kaspar Daugaard","likes":5,"published":1,"tags":["plasmaballforsiggraph2014"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"void main(void)\n{\n\tvec2 norm = gl_FragCoord.xy \/ iResolution.xy;\n    vec2 pos = (norm - vec2(0.5, 0.5)) * vec2(3.6, 2.0);\n    float r = sqrt(dot(pos, pos));\n    r *= 1.0 + 0.4 * sin(iGlobalTime * 0.12);\n    float b = 1.0;\n    if (r < 1.0)\n    {\n        norm = vec2(1.0, 1.0) - norm;\n        norm *= sqrt(r);\n        b -= pow(r, 10.0);\n        b *= 0.9 + 0.2 * sin(iGlobalTime * 3.1);\n    }\n\n    vec2 uv = norm;\n    uv.x += 0.6 * sin(iGlobalTime + norm.y * 3.0);\n    uv.y += 0.6 * sin(iGlobalTime + norm.x * 3.0);\n\tgl_FragColor = vec4(uv,0.5+0.5*sin(iGlobalTime * 1.228),1.0);\n    uv.x += 0.2 * sin(iGlobalTime + norm.y * 29.0);\n    uv.y += 0.2 * sin(iGlobalTime + norm.x * 29.0);\n\tgl_FragColor +=  0.3 * vec4(uv,0.5+0.5*sin(iGlobalTime),1.0);\n    \n    uv.x += 0.2 * sin(iGlobalTime * 5.0 + norm.y * 129.0);\n    uv.y += 0.2 * sin(iGlobalTime * 5.0 + norm.x * 129.0);\n\tgl_FragColor +=  max(uv.x * uv.y - (sin(iGlobalTime * 0.04) + 1.0) * 0.1, 0.0);\n\n \tgl_FragColor -=  0.7*r;\n \tgl_FragColor *=  b;\n \tgl_FragColor.b =  max(gl_FragColor.b, -0.2);\n \tgl_FragColor.b +=  gl_FragColor.g * 0.4;\n    \n \tgl_FragColor =  max(gl_FragColor, vec4(0.0, 0.0, 0.0, 0.0));\n    if (r > 1.0)\n    {\n        float a = atan(pos.y \/ pos.x);\n \t\tfloat halo = 0.2 * pow(0.5, r * r + sin(a * 12.0 + iGlobalTime));\n \t\thalo += 0.2 * pow(0.5, r * r + sin(a * 8.0 - iGlobalTime * 1.3));\n \t\thalo += 0.2 * pow(0.5, r * r + sin(a * 18.0 + iGlobalTime * 1.2));\n \t\tvec4 col = vec4(halo - 0.1, halo - 0.08, halo, 0);\n        col + max(col, vec4(0.0, 0.0, 0.0, 0.0));\n        gl_FragColor += col;\n    }\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdsXWs","date":"1407870332","viewed":41,"name":"[SIG2014] Note","username":"tomka","description":"A test.","likes":0,"published":1,"tags":["sphere"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"void main(void)\n{\n    vec2 center = vec2(iResolution.x * 0.5, iResolution.y * 0.5);\n    vec2 direction = gl_FragCoord.xy - center.xy;\n    float r = 40.0;\n\n    float dist = sqrt( direction.x * direction.x + direction.y * direction.y );\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n    \n    if (dist < r) {\n\t    gl_FragColor = vec4(uv,0.5+0.5*sin(iGlobalTime),1.0);\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0,1.0);\n    }\n\n    \/\/ Add virtual light\n\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dsXWs","date":"1407870096","viewed":85,"name":"SIG2014 - First Shadertoy","username":"Sarconix","description":"This is my first Shadertoy, which I started at the SIGGRAPH 2014 hackathon.  It was based on the 2D template, which draws a single circle.  I modified it to show a pixelated image as viewed through a grid of circles that cycle their size over time.","likes":2,"published":1,"tags":["siggraph2014"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ The min and max sizes of the circles (in pixels) over time.\n#define MIN_SIZE 2.0\n#define MAX_SIZE 150.0\n\n\/\/ Compute the relative distance to the circle, where < 0.0 is outside the feathered border,\n\/\/ and > 1.0 is inside the feathered border.\nfloat ComputeCircle(vec2 pos, vec2 center, float radius, float feather)\n{\n    \/\/ Determine the distance to the center of the circle.\n\tfloat dist = length(center - pos);\n    \n    \/\/ Use the distance and the specified feather factor to determine where the distance lies\n    \/\/ relative to the circle border.\n    float start = radius - feather;\n    float end   = radius + feather;\n    return smoothstep(start, end, dist);\n}\n\n\/\/ The main function, which is executed once per pixel.\nvoid main(void)\n{\n    \/\/ Prepare the circle parameters, cycling the circle size over time.\n    float cycle = clamp(cos(iGlobalTime \/ 2.0) * 0.6 + 0.7, 0.0, 1.0);\n    float diameter = mix(MAX_SIZE, MIN_SIZE, cycle);\n    float radius = diameter \/ 2.0;\n    vec2  center = vec2(0.0);\n    \n    \/\/ Compute the relative distance to the circle, using mod() to repeat the circle across the display.\n    \/\/ A feather value (in pixels) is used to reduce aliasing artifacts when the circles are small.\n    \/\/ The position is adjusted so that a circle is in the center of the display.\n    vec2 screenPos = gl_FragCoord.xy - (iResolution.xy \/ 2.0) - vec2(radius);\n    vec2 pos = mod(screenPos, vec2(diameter)) - vec2(radius);\n    float d = ComputeCircle(pos, center, radius, 0.5);\n    \n    \/\/ Compute \"pixelated\" (stepped) texture coordinates using the floor() function.\n    \/\/ The position is adjusted to match the circles, i.e. so a pixelated block is at the center of the\n    \/\/ display.\n    vec2 count = iResolution.xy \/ diameter;\n    vec2 shift = vec2(0.5) - fract(count \/ 2.0);\n    vec2 uv = floor(count * gl_FragCoord.xy \/ iResolution.xy + shift) \/ count;\n    \n\t\/\/ Sample the texture, using an offset to the center of the pixelated block.\n    \/\/ NOTE: Use a large negative bias to effectively disable mipmapping, which would otherwise lead\n    \/\/ to sampling artifacts where the UVs change abruptly at the pixelated block boundaries.\n    uv += vec2(0.5) \/ count;\n    uv = clamp(uv, 0.0, 0.99);\n    uv.y = 1.0 - uv.y;\n    vec3 texColor = texture2D(iChannel0, uv, -32.0).rgb;    \n    \n\t\/\/ Calculate the color based on the circle shape, mixing between that color and a background color.\n    \/\/ NOTE: Set the mix factor to 0.0 to see the pixelating effect directly, without the circles.\n    vec3 bg  = vec3(0.0, 0.0, 0.0);\n    vec3 col = mix(texColor, bg, d);\n        \n    \/\/ Set the final fragment color.\n\tgl_FragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4slXWs","date":"1407869872","viewed":419,"name":"SIG2014 O","username":"mrdoob","description":"Done in a keyboard without parenthesis. Lots of copy\/paste action.","likes":2,"published":1,"tags":["sphere"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/------------------------------------------------------------------------\n\/\/ Camera\n\/\/\n\/\/ Move the camera. In this case it's using time and the mouse position\n\/\/ to orbitate the camera around the origin of the world (0,0,0), where\n\/\/ the yellow sphere is.\n\/\/------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iGlobalTime + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(sin(iGlobalTime),cos(iGlobalTime),0.0);\n}\n\n\n\/\/------------------------------------------------------------------------\n\/\/ Background \n\/\/\n\/\/ The background color. In this case it's just a black color.\n\/\/------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n    \n\/\/------------------------------------------------------------------------\n\/\/ Modelling \n\/\/\n\/\/ Defines the shapes (a sphere in this case) through a distance field, in\n\/\/ this case it's a sphere of radius 1.\n\/\/------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    return length(p) - 1.0;\n}\n\nfloat doModel2( vec3 p )\n{\n    p.x = sin(p.x + iGlobalTime) * sin(p.y);\n    p.y = cos(p.y + iGlobalTime) * sin(p.x);\n    p.z = sin(p.z + iGlobalTime);\n    return length(p * sin(iGlobalTime * 0.1) - 0.25) - 0.25;\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Material \n\/\/\n\/\/ Defines the material (colors, shading, pattern, texturing) of the model\n\/\/ at every point based on its position and normal. In this case, it simply\n\/\/ returns a constant yellow color.\n\/\/------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(sin(iGlobalTime + pos.x),cos(iGlobalTime + pos.y),0.05);\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Lighting\n\/\/------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    \/\/ key light\n    \/\/-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    \/\/ ambient light\n    \/\/-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    \/\/ surface-light interacion\n    \/\/-----------------------------\n    vec3 col = mal*lin;\n\n    \n    \/\/ fog    \n    \/\/-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           \/\/ max trace distance\n\tconst float precis = 0.001;        \/\/ precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          \/\/ max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel2( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             \/\/ precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 \/\/ selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         \/\/ 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h\/t );   \/\/ 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   \/\/ limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid main( void )\n{\n    vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)\/iResolution.y;\n    vec2 m = iMouse.xy\/iResolution.xy;\n\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n    \n    \/\/ camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iGlobalTime, m.x );\n\n    \/\/ camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, iGlobalTime * 0.2 );  \/\/ 0.0 is the camera roll\n    \n\t\/\/ create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); \/\/ 2.0 is the lens length\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t\/\/ raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        \/\/ materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    gl_FragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XssXDl","date":"1407869811","viewed":60,"name":"SIG2014-metaballs","username":"mfu","description":"My first shadertoy, starting from IQ's metaballs Quintic.  This was fun!","likes":2,"published":1,"tags":["hackathon"],"hasliked":0},"renderpass":[{"inputs":[{"id":13,"src":"\/presets\/mzk00.mp3","ctype":"music","channel":1},{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Using polynomial fallof of degree 5 for bounded metaballs, which produce smooth normals\n\/\/ unlike the cubic (smoothstep) based fallofs recommended in literature (such as John Hart).\n\n\/\/ The quintic polynomial p(x) = 6x5 - 15x4 + 10x3 has zero first and second derivatives in\n\/\/ its corners. The maxium slope p''(x)=0 happens in the middle x=1\/2, and its value is \n\/\/ p'(1\/2) = 15\/8. Therefore the  minimum distance to a metaball (in metaball canonical \n\/\/ coordinates) is at least 8\/15 = 0.533333 (see line 63).\n\n\/\/ This shader uses bounding spheres for each ball so that rays traver much faster when far\n\/\/ or outside their radius of influence.\n\n\/\/ MODIFIED FROM SHADERTOY FOR HACKATHON\n\n\/\/ if you change this, try making it a square number (1,4,9,16,25,...)\n#define samples 4\n\n#define numballs 4\n\n\/\/ undefine this for numerical normals\n#define ANALYTIC_NORMALS\n\n\/\/----------------------------------------------------------------\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n\/\/----------------------------------------------------------------\n\nvec4 blobs[numballs];\n\nfloat sdMetaBalls( vec3 pos )\n{\n\tfloat m = 0.0;\n\tfloat p = 0.0;\n\tfloat dmin = 1e20;\n\t\t\n\tfloat h = 1.0; \/\/ track Lipschitz constant\n\t\n\tfor( int i=0; i<numballs; i++ )\n\t{\n\t\t\/\/ bounding sphere for ball\n        float db = length( blobs[i].xyz - pos );\n        if( db < blobs[i].w )\n    \t{\n    \t\tfloat x = db\/blobs[i].w;\n    \t\tp += 1.0 - x*x*x*(x*(x*6.0-15.0)+10.0);\n\t    \tm += 1.0;\n    \t\th = max( h, 0.5333*blobs[i].w );\n\t    }\n\t    else \/\/ bouncing sphere distance\n\t    {\n    \t\tdmin = min( dmin, db - blobs[i].w );\n    \t}\n\t}\n    float d = dmin + 0.1;\n\t\n\tif( m>0.5 )\n\t{\n\t\tfloat th = 0.2;\n\t\td = h*(th-p);\n\t}\n\t\n\treturn d;\n}\n\n\nvec3 norMetaBalls( vec3 pos )\n{\n\tvec3 nor = vec3( 0.0, 0.0001, 0.0 );\n\t\t\n\tfor( int i=0; i<numballs; i++ )\n\t{\n        float db = length( blobs[i].xyz - pos );\n\t\tfloat x = clamp( db\/blobs[i].w, 0.0, 1.0 );\n\t\tfloat p = x*x*(30.0*x*x - 60.0*x + 30.0);\n\t\tnor += normalize( pos - blobs[i].xyz ) * p \/ blobs[i].w;\n\t}\n\t\n\treturn normalize( nor );\n}\n\n\nfloat map( in vec3 p )\n{\n\treturn sdMetaBalls( p );\n}\n\n\nconst float precis = 0.01;\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 10.0;\n    float h = precis*2.0;\n    float t = 0.0;\n    float m = 1.0;\n    for( int i=0; i<75; i++ )\n    {\n        if( h<precis||t>maxd ) continue;\/\/break;\n        t += h;\n\t    h = map( ro+rd*t );\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n#ifdef ANALYTIC_NORMALS\t\n\treturn norMetaBalls( pos );\n#else\t\n    vec3 eps = vec3(precis,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n#endif\n}\n\nvoid main( void )\n{\n    \/\/-----------------------------------------------------\n    \/\/ input\n    \/\/-----------------------------------------------------\n\n\tvec2 q = gl_FragCoord.xy \/ iResolution.xy;\n\n\tvec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n    float freqs[2];\n\n\tfreqs[0] = texture2D( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture2D( iChannel1, vec2( 0.07, 0.25 ) ).y;\n\n    \n    \/\/-----------------------------------------------------\n    \/\/ montecarlo (over time, image plane and lens) (5D)\n    \/\/-----------------------------------------------------\n\n\tfloat msamples = sqrt(float(samples));\n\t\n\tvec3 tot = vec3(0.0);\n\t#if samples>1\n\tfor( int a=0; a<samples; a++ )\n    #else\n    float a = 0.0;\t\t\n    #endif\t\t\n\t{\n\t\tvec2  poff = vec2( mod(float(a),msamples), floor(float(a)\/msamples) )\/msamples;\n\t\t#if samples>4\n        float toff = 0.0;\n\t\t#else\n        float toff = 0.0*(float(a)\/float(samples)) * (0.5\/24.0); \/\/ shutter time of half frame\n        #endif\n\t\t\n        \/\/-----------------------------------------------------\n        \/\/ animate scene\n        \/\/-----------------------------------------------------\n\t\tfloat time = iGlobalTime + toff;\n\n        \/\/ move metaballs\n\t\tfor( int i=0; i<numballs; i++ )\n        {\n            float h = float(i)\/4.0;\n            blobs[i].xyz = 2.1*sin( 6.2831*hash3(h*1.17) + hash3(h*13.7)*time) + freqs[0]*0.1;\n            blobs[i].w = 1.7 + 0.9*sin(6.28*hash1(h*23.13));\n\t\t}\n\n        \/\/ move camera\t\t\n\t\tfloat an = 0.5*time - 6.2831*(m.x-0.5);\n\t\tvec3 ro = vec3(5.0*sin(an),2.5*cos(0.4*an),5.0*cos(an));\n        vec3 ta = vec3(0.0,0.0,0.0);\n\n\t\t\/\/-----------------------------------------------------\n        \/\/ camera\n        \/\/-----------------------------------------------------\n        \/\/ image plane\t\t\n\t\tvec2 p = -1.0 + 2.0 * (gl_FragCoord.xy + poff) \/ iResolution.xy;\n        p.x *= iResolution.x\/iResolution.y;\n        \/\/ camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        \/\/ create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n        \/\/ dof\n        #if samples >= 9\n        vec3 fp = ro + rd * 5.0;\n\t\tvec2 le = -1.0 + 2.0*hash2( dot(gl_FragCoord.xy,vec2(131.532,73.713)) + float(a)*121.41 );\n        ro += ( uu*le.x + vv*le.y )*0.1;\n        rd = normalize( fp - ro );\n        #endif\t\t\n\n\t\t\/\/-----------------------------------------------------\n        \/\/ render\n        \/\/-----------------------------------------------------\n\n        \/\/ background\n\t    vec3 col = pow( textureCube( iChannel0, rd ).xyz, vec3(2.2) ) * 0.2 * freqs[1];\n\t\t\n\t    \/\/ raymarch\n        vec2 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            \/\/ geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n    \t\tvec3 ref = reflect( rd, nor );\n\n            \/\/ materials\n    \t\tvec3 mate = vec3(0.0);\n    \t\tfloat w = 0.01;\n    \t\tfor( int i=0; i<numballs; i++ )\n    \t\t{\n    \t\t\tfloat h = float(i)\/4.0;\n\n                \/\/ metaball color\n    \t\t\tvec3 ccc = vec3(1.0);\n                vec3 red = vec3(1.0,0.1,0.1);\n                vec3 green = vec3(0.1,1.0,0.1);\n                vec3 blue = vec3(0.1,0.1,1.0);\n                vec3 c1 = mix(red, blue, freqs[1]);\n                vec3 c2 = mix(green, vec3(1,1,1), freqs[1]);\n    \t\t\tccc = mix( ccc, c1, smoothstep(0.65,0.66,sin(30.0*h)));\n    \t\t\tccc = mix( ccc, c2, smoothstep(0.65,0.66,sin(15.0*h)));\n\t\t\t\n                float x = clamp( length( blobs[i].xyz - pos )\/blobs[i].w, 0.0, 1.0 );\n                float p = 1.0 - x*x*(3.0-2.0*x);\n                mate += p*ccc;\n                w += p;\n            }\n            mate \/= w;\n\n            \/\/ lighting\n    \t\tvec3 lin = vec3(0.0);\n\t\t\tlin += mix( vec3(0.05,0.02,0.0), 1.2*vec3(0.8,0.9,1.0), 0.5 + 0.5*nor.y );\n            lin *= 1.0 + 1.5*vec3(0.7,0.5,0.3)*pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n    \t\tlin += 1.5*clamp(0.3+2.0*nor.y,0.0,1.0)*pow(textureCube( iChannel0, ref ).xyz,vec3(2.2))*(0.04+0.96*pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 4.0 ));\n\n\t    \t\/\/ surface-light interacion\n    \t\tcol = lin * mate;\n\t    }\n\t\ttot += col;\n\t}\n\ttot \/= float(samples);\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n\t\/\/ vigneting\n    tot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.30 );\n\n    gl_FragColor = vec4( tot, 1.0 );\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XslXWs","date":"1407869414","viewed":50,"name":"[SIG2014] CircleSlide","username":"asteropaeus","description":"Well, I sat down and someone told me the theme was circles, so this may be a bit less 3 dimensional than it should be for the theme ...","likes":1,"published":1,"tags":["wip"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ Start with iq's voronoi noise from https:\/\/www.shadertoy.com\/view\/ldl3W8\nvec2 hash2( vec2 p )\n{\n\t\/\/ texture based white noise\n\treturn texture2D( iChannel0, (p+0.5)\/256.0, -100.0 ).xy;\n\t\n    \/\/ procedural white noise\t\n\t\/\/return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    \/\/----------------------------------\n    \/\/ first pass: regular voronoi\n    \/\/----------------------------------\n\tvec2 mg, mr;\n    vec2 col;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iGlobalTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            col = o;\n        }\n    }\n    \n    \/\/----------------------------------\n    \/\/ second pass: distance to borders\n    \/\/----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( col, md );\n}\n\nvec2 rotateCircle( vec2 p, vec2 center, float angle, float inner, float outer )\n{\n    vec2 disp = p - center;\n    float l = length( disp );\n    vec2 rotX = vec2( cos( angle ), sin( angle ) );\n    vec2 rotY = rotX.yx * vec2( -1.0, 1.0 );\n    \n    return ( l > outer || l < inner ) ? p : center + vec2( dot( disp, rotX ), dot( disp, rotY ) ); \n}\n\nstruct circleStruct\n{\n    vec2 center;\n    float angle;\n    float inner;\n    float outer;\n};\n\nvoid main( void )\n{\n    vec2 p = 2.0 * (gl_FragCoord.xy\/iResolution.xx) - vec2(1.0,iResolution.y \/ iResolution.x  );\n    \n    const int numSplits = 5;\n    vec4 circleStruct[numSplits];\n    float circleRot[numSplits];\n    \n    vec2 splitCenter = vec2( 0.0 );\n    vec2 splitAxis = normalize( vec2( 1.0, 0.3 ) );\n    float splitSize = 0.9;\n\n    for( int i = numSplits - 1; i >= 0; i -- )\n\t{   \n        circleStruct[i] = vec4( splitCenter, 0.6 * splitSize, 0.8 * splitSize );\n        splitSize *= 0.8;\n\t\tsplitAxis = vec2( normalize( vec2(splitAxis.y, -splitAxis.x ) + 0.0 * 0.35 * hash2( 256.0 * splitCenter.xy ) ) );\n        float axisDot = dot( p - splitCenter, splitAxis );\n        splitCenter = vec2( splitCenter + sign( axisDot ) * splitAxis * splitSize );\n        \n        \n    }\n    for( int i = 0; i < numSplits; i++ )\n\t{\n        p = rotateCircle( p, circleStruct[i].xy, max( 0.0, iGlobalTime - float(numSplits - 1 - i) * 5.0 ), circleStruct[i].z, circleStruct[i].w );\n    }\n        \n    \/\/p = rotateCircle( p, vec2(0.5), iGlobalTime, 0.3, 0.5 );\n    \/\/p = rotateCircle( p, vec2(0.0), iGlobalTime, 0.5, 0.7 );\n    \n    vec3 c = voronoi( 16.0*p );\n\n\t\/\/ isolines\n    \/*vec3 col = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n    \/\/ borders\t\n    col = mix( vec3(1.0,0.6,0.0), col, smoothstep( 0.04, 0.07, c.x ) );\n    \/\/ feature points\n\tfloat dd = length( c.yz );\n\tcol = mix( vec3(1.0,0.6,0.1), col, smoothstep( 0.0, 0.12, dd) );\n\tcol += vec3(1.0,0.6,0.1)*(1.0-smoothstep( 0.0, 0.04, dd));*\/\n    vec3 col = mix( vec3( 0.2 ), vec3( hash2( c.xy * 256.0 ), 0.0 ), 1.0 - pow( 1.0 - c.z, 4.0 ) );\n    \n\n\tgl_FragColor = vec4(col,1.0);\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XssSDl","date":"1407869143","viewed":21,"name":"[SIG2014] 2d metaballs (sorta)","username":"nguillemot","description":"2d metaball test for sig2014\n\nuse the mouse to move the red one","likes":0,"published":1,"tags":["metaballs"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"float wyvillFilter(float r, float dSquared)\n{\n    float x = 1.0 - dSquared \/ (r * r);\n    return x * x * x;\n}\n\nfloat sphereFieldValue(vec3 sphereCenter, float radius, vec3 point)\n{\n    vec3 delta = sphereCenter - point;\n\treturn wyvillFilter(radius, dot(delta, delta));\n}\n\nvoid main(void)\n{\n    vec3 eyePos = vec3(gl_FragCoord.xy, 0);\n    \n    const float rayStep = 0.1;\n    const float numSteps = 100.0;\n    \n    vec3 lightPos = vec3(iResolution.x\/2.0,iResolution.y\/2.0,500.0);\n\n    const int numSpheres = 5;\n    vec4 spheres[numSpheres];\n    vec4 sphereColors[numSpheres];\n    spheres[0] = vec4(iMouse.xy, 0.0, 100.0);\n    sphereColors[0] = vec4(1,0,0,1);\n    spheres[1] = vec4(-100.0 + mod(iGlobalTime*1000.0,iResolution.x + 100.0),(1.0+sin(iGlobalTime*5.0)) * iResolution.y\/2.0,0,100);    sphereColors[1] = vec4(0,1,0,1);\n    spheres[2] = vec4(iResolution.x\/2.0,-100.0 + mod(iGlobalTime*200.0,iResolution.y + 400.0),0,100);\n    sphereColors[2] = vec4(0,0,1,1);\n    spheres[3] = vec4(200,100,50,100);\n    sphereColors[3] = vec4(0.1,0.3,0.4,1);\n    spheres[4] = vec4(600,100,50,100);\n    sphereColors[4] = vec4(0.7,04,0.4,1);\n    \n\tgl_FragColor = vec4(0.1,0.3,0,0.0);\n    \n    for (float s = 0.0; s < numSteps; s++)\n    {\n        vec3 rayPos = eyePos + vec3(0,0,s * rayStep);\n        float field = 0.0;\n        vec4 color = vec4(0,0,0,0);\n        \n        for (int i = 0; i < numSpheres; i++)\n        {\n            float currField = max(0.0,sphereFieldValue(spheres[i].xyz, spheres[i].w, rayPos));\n            field += currField;\n            color += currField * vec4(sphereColors[i].xyz,1.0);\n        }\n        \n        color \/= vec4(numSpheres);\n                            \n        if (field > 0.0)\n        {\n            const float offset = 30.0;\n            \n            vec3 offsetFields = vec3(0);\n            for (int i = 0; i < numSpheres; i++)\n            {\n                offsetFields.x += max(0.0,sphereFieldValue(spheres[i].xyz, spheres[i].w, rayPos + vec3(offset,0,0)));\n\t\t\t\toffsetFields.y += max(0.0,sphereFieldValue(spheres[i].xyz, spheres[i].w, rayPos + vec3(0,offset,0)));\n\t\t\t\toffsetFields.z += max(0.0,sphereFieldValue(spheres[i].xyz, spheres[i].w, rayPos + vec3(0,0,offset)));\n\t\t\t}\n            \n            vec3 gradient = normalize(offsetFields \/ vec3(offset));\n            \n            vec3 toLight = lightPos - rayPos;\n            \n            gl_FragColor = color + max(0.0,dot(gradient,normalize(toLight))) * vec4(0.1);\n            break;\n        }\n    }\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dlXWs","date":"1407869109","viewed":30,"name":"[SIG2014] Val's 2D Shader","username":"val","description":"This is the first shader I've ever written. Click and drag the mouse for sine wave magic.","likes":0,"published":1,"tags":["sig2014"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Calculate the circle\nfloat calcCircle(vec2 p, vec2 center, float radius)\n{\n    \/\/ Calculate the distance to the center of the circle\n\tfloat d = length(center - p);\n    \n    \/\/ Calculate the border of the circle\n    d = smoothstep(radius, radius + 0.01, d);\n    return d;\n}\n\n\nvoid main(void)\n{\n    \/\/ Convert texture coordinates to [-1,1]\n\tvec2 q = gl_FragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;    \/\/ Fix the aspect ratio\n    \n    \/\/ Calculate the circle shape\n    \/\/vec2  center = vec2(sin(iGlobalTime), cos(iGlobalTime)) * 0.1;\n\tvec2 center;\n    float radius;\n    \/\/float d      = calcCircle(p, center, radius);\n    float d = 0.9;\n    float m = iMouse.x;\n    \n    if (m == 0.0) {\n        radius = 0.03;\n        for (int i = 2500; i>0; i--){\n        \tcenter.x = float(i) \/ 600.0 - 1.0;\n        \tcenter.y = sin(iGlobalTime - float(i) * 50.0 \/ 10.0) + 1.0;\n        \td *= calcCircle(p + 0.1, center - 1.0, radius);\n    \t}\n    }\n    else {\n        radius = 100.0 \/ iMouse.x \/ 40.0;\n        for (int i = 2500; i>0; i--){\n        \tcenter.x = float(i) \/ 600.0 - 1.0;\n        \tcenter.y = sin(iGlobalTime - float(i) * m \/ 10.0) + 1.0;\n        \td *= calcCircle(p + 0.1, center - 1.0, radius);\n    \t}  \n    }\n    \n\t\/\/ Calculate the color based on the circle shape\n    vec3 backgroundColor = vec3(p.x * -0.2, 0.05, 0.1);\n\tvec3 circleColor     = vec3(1.0, p.x, p.y);\n    vec3 col             = mix(circleColor, backgroundColor, d);\n    \n   \n    \/\/ Send the color to the screen\n\tgl_FragColor = vec4(col, 1.0);\n\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4ssSDl","date":"1407868386","viewed":43,"name":"SIG2014 - Test","username":"rwblodgett","description":"Spheres are awesome","likes":0,"published":1,"tags":["spheres"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/------------------------------------------------------------------------\n\/\/ Camera\n\/\/\n\/\/ Move the camera. In this case it's using time and the mouse position\n\/\/ to orbitate the camera around the origin of the world (0,0,0), where\n\/\/ the yellow sphere is.\n\/\/------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iGlobalTime + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\/\/------------------------------------------------------------------------\n\/\/ Background \n\/\/\n\/\/ The background color. In this case it's just a black color.\n\/\/------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    vec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n    return vec3( 0.0, uv.y*0.1*cos(iGlobalTime), uv.x*0.1*sin(iGlobalTime));\n}\n    \n\/\/------------------------------------------------------------------------\n\/\/ Modelling \n\/\/\n\/\/ Defines the shapes (a sphere in this case) through a distance field, in\n\/\/ this case it's a sphere of radius 1.\n\/\/------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    float mind = 100.0;\n    for (int j = 0; j < 10; j++)\n    {\n    for (int i = 0; i < 25; i++)\n    {\n    \tfloat d1 = length(p - vec3(-5.0+float(i)*0.45, -2.0+float(j)*0.45, 0.0) ) - 0.2;\n        mind = min(mind,d1);\n    }\n    }\n    \n    \n    \n    return mind;\n}\n\n\/\/ hash based 3d value noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.2 - p.y;\n\n\tvec3 q = p - vec3(1.0,0.1,0.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.5000*noise( q ); q = q*2.02;\n    f += 0.2500*noise( q ); q = q*2.03;\n    f += 0.1250*noise( q ); q = q*2.01;\n    f += 0.0625*noise( q );\n\n\td += 3.0 * f;\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.2,0.1,0.3), res.x );\n\t\n\treturn res;\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Material \n\/\/\n\/\/ Defines the material (colors, shading, pattern, texturing) of the model\n\/\/ at every point based on its position and normal. In this case, it simply\n\/\/ returns a constant yellow color.\n\/\/------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec4 result = map(pos);\n    \/\/result = texture2D(iChannel1, vec2(map(pos)));\n    return result.xyz;\n}\n\n\n\n\/\/------------------------------------------------------------------------\n\/\/ Lighting\n\/\/------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    \/\/ key light\n    \/\/-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(1.00,1.00,1.00)*sha;\n\n    \/\/ ambient light\n    \/\/-----------------------------\n    lin += vec3(0.10,0.10,0.10);\n\n    \n    \/\/ surface-light interacion\n    \/\/-----------------------------\n    vec3 col = mal*lin;\n\n    \n    \/\/ fog    \n    \/\/-----------------------------\n\t\/\/col *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           \/\/ max trace distance\n\tconst float precis = 0.001;        \/\/ precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    vec2 tt = vec2(0.2,0.5);\n    \n    \n    for( int i=0; i<120; i++ )          \/\/ max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             \/\/ precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 \/\/ selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         \/\/ 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h\/t );   \/\/ 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   \/\/ limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid main( void )\n{\n    vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)\/iResolution.y;\n    vec2 m = iMouse.xy\/iResolution.xy;\n\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n    \n    \/\/ camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iGlobalTime, m.x );\n\n    \/\/ camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  \/\/ 0.0 is the camera roll\n    \n\t\/\/ create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); \/\/ 2.0 is the lens length\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n    for (int j = 0; j < 5; j++)\n    {\n    \n        \/\/ raymarch\n        float t = calcIntersection( ro, rd );\n        if( t>-0.5 )\n        {\n            \/\/ geometry\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n\n            \/\/ materials\n            vec3 mal = doMaterial( pos, nor );\n\n            col = doLighting( pos, nor, rd, t, mal );\n        }\n    }\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    gl_FragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}]