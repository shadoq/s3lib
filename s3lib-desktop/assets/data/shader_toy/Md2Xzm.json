[{"ver":"0.1","info":{"id":"Md2Xzm","date":"1410567901","viewed":395,"name":"Fake glints","username":"nimitz","description":"Looks better in fullscreen. (Mouse to rotate)\n\nAnisotropic code based on TekF's \"Anisotropic Highlights\" (https:\/\/www.shadertoy.com\/view\/XdB3DG)","likes":11,"published":1,"tags":["3d","raymarching","fake","hack","glints"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":1},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/Fake Glints by nimitz (twitter @stormoid)\n\n\/*\n\tProper glints are pretty expensive to render because the solutions invariably require\n\tmultiple evaluations per pixel.\n\t\n\tHere, I am faking glints by applying two layers of noisy\/small anisotropic\n\thighlights that get displaced as a function of the half vector and the projected\n\tpixel position in 3d space.\n\n\tThis could be improved to look a lot better, but I feel\tthis is a decent demo\n\tof the technique's potential.\n*\/\n\n#define time iGlobalTime\n#define FAR 30.\n#define ITR 60\n\n#define PRIMARY_INTENSITY 1.3\n#define PRIMARY_CONCENTRATION 12.\n#define SECONDARY_INTENSITY 5.\n#define SECONDARY_CONCENTRATION 0.9\n\n\/\/The lack of reflcetions give it a different but still interesting look\n\/\/#define NO_REFLECTIONS\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nfloat length16( vec3 p )\n{\n\tp = p*p; p = p*p; p = p*p;p = p*p;\n\treturn pow(p.x+p.y+p.z, 1.0\/16.0 );\n}\n\nfloat map(vec3 p)\n{\n    float d= length16(p)-0.5;\n\tp.xy *= .7;\n\treturn mix(d,length(p)-1.5,0.5);\n}\n\n\n\/\/Based on TekF's \"Anisotropic Highlights\" (https:\/\/www.shadertoy.com\/view\/XdB3DG)\nvec3 shade( vec3 pos, vec3 rd, vec3 normal, vec3 ligt )\n{\n\tvec3 lcol = vec3(.48,.45,.9);\n    float nl = dot(normal,ligt);\n\tvec3 light = lcol*max(.0,nl)*1.5;\n    \/\/light += mix( vec3(.07,.07,.07), vec3(.15), (-normal.y+1.0) );\t\n\tvec3 h = normalize(ligt-rd);\n    vec3 rf = reflect(rd,normal);\n\n\tvec3 coord = pos*.5;\n\tcoord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n\tcoord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n    vec3 coord2 = coord;\n    \n    \/\/displacement of the noise grabs to create the glinting effect\n    #if 1    \n    vec3 ww = fwidth(pos);\n    coord.xy -= h.xz*20.*ww.xy;\n    coord.xz -= h.xy*20.*ww.xz;\n    coord2.xy -= h.xy*5.*ww.xy;\n    coord2.xz -= h.xz*5.*ww.xz;\n    #endif\n\t\n    \/\/first layer (inner glints)\n    float pw = .21*((iResolution.x));\n\tvec3 aniso = vec3( Noise(coord*pw), Noise(coord.yzx*pw).x )*2.0-1.0;\n    aniso -= normal*dot(aniso,normal);\n\tfloat anisotropy = min(1.,length(aniso));\n\taniso \/= anisotropy;\n\tanisotropy = .55;\n\tfloat ah = abs(dot(h,aniso));\n    float nh = abs(dot(normal,h));\n\tfloat q = exp2((1.1-anisotropy)*3.5);\n\tnh = pow( nh, q*PRIMARY_CONCENTRATION );\n\tnh *= pow( 1.-ah*anisotropy, 10.0 );\n\tvec3 glints = lcol*nh*exp2((1.2-anisotropy)*PRIMARY_INTENSITY);\n    glints *= smoothstep(.0,.5,nl);\n    \n    \/\/second layer (outer glints)\n    pw = .145*((iResolution.x));\n    vec3 aniso2 = vec3( Noise(coord2*pw), Noise(coord2.yzx*pw).x )*2.0-1.0;\n    anisotropy = .6;\n    float ah2 = abs(dot(h,aniso2));\n    float q2 = exp2((.1-anisotropy)*3.5);\n    float nh2 = pow( nh, q2*SECONDARY_CONCENTRATION );\n    nh2 *= pow( 1.-ah2*anisotropy, 150.0 );\n    vec3 glints2 = lcol*nh2*((1.-anisotropy)*SECONDARY_INTENSITY);\n    glints2 *= smoothstep(.0,.4,nl);\n\t\n\t\n    \n    #ifdef NO_REFLECTIONS\n    vec3 reflection = vec3(0);\n    #else\n    vec3 reflection = textureCube(iChannel1,rf).rgb;\n    #endif\n\tfloat frnl = pow( 1.0+dot(normal,rd), 5.0 );\n\tfrnl = mix( .0, .25, frnl );\n    \n\treturn mix( light*vec3(.3), reflection, frnl ) + glints + glints2 +\n        reflection*0.015*(clamp(nl,0.,1.))+ reflection*0.005 + lcol*0.1;\n}\n\n\n\nfloat march( vec3 pos, vec3 ray )\n{\n\tfloat d = 0.;\n\tfloat h;\n\tfor( int i=0; i < ITR; i++ )\n\t{\n\t\th = map( pos+d*ray );\n\t\tif ( h < .005 || d > FAR )break;\n\t\td = d+h;\n\t}\n\t\n\tif (d > FAR)return 0.;\t\n\telse return d;\n}\n\nvec3 normal(in vec3 p, in vec3 rd)\n{  \n    vec2 e = vec2(-1., 1.)*0.01;   \n\tvec3 n = (e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n    \n    \/\/from TekF (error checking)\n\tfloat gdr = dot (n, rd );\n\tn -= max(.0,gdr)*rd;\n    return normalize(n);\n}\n\nvoid main()\n{\n\t\/\/setup\n    vec2 p = gl_FragCoord.xy\/iResolution.xy-0.5;\n\tp.x*=iResolution.x\/iResolution.y;\n\tvec2 um = iMouse.xy \/ iResolution.xy-.5;\n\tum.x *= iResolution.x\/iResolution.y;\n\t\n    \/\/camera\n\tvec3 ro = vec3(0.,0.,-5.);\n\tvec3 rd = normalize(vec3(p,1.5));\n    mat2 mx = mm2(sin(time*.24)*0.5+um.x*6.);\n    mat2 my = mm2(sin(time*0.15)*1.5+um.y*6.+3.5); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n\t\n\tvec3 col = vec3(0);\n\t\n\tfloat t = march( ro, rd );\n\tif ( t > .0 )\n\t{\n        vec3 ligt = normalize(vec3(1.,1,-.2));\n\t\tvec3 p = ro + rd*t;\n\t\tvec3 n = normal(p,rd);\n        col = shade( p, rd, n, ligt);\n\t\t\n\t}\n\telse\n\t{\n        #ifdef NO_REFLECTIONS\n        col = vec3(0);\n        #else\n        col = textureCube(iChannel1,rd).rgb;\n        #endif\n\t}\n\n    \n\tgl_FragColor = vec4(pow(col,vec3(.85)),1);\n}\n","name":"","description":"","type":"image"}]}]