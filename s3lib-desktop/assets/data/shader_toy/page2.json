[{"ver":"0.1","info":{"id":"4sjXW1","date":"1411534703","viewed":31,"name":"Sphere mappings","username":"nimitz","description":"I couldn't find an implementation of procedural cubemaps here on shadertoy, so I did a little study on the different options. For further study: Is there a cheap way to do Icosahedral projection? (and geodesic grids). Drag to rotate.","likes":1,"published":1,"tags":["3d","uv","mapping","technique","healpix","quadcube"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/Sphere mapping by nimitz (twitter: @stormoid)\n\n\/*\n\tLittle demo of different sphere uv mapping techniques.\n*\/\n\n#define time iGlobalTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 tex(in vec2 p)\n{\n    float frq =50.3;\n    p += 0.405;\n    return vec3(1.)*smoothstep(.9, 1.05, max(sin((p.x)*frq),sin((p.y)*frq)));\n}\n\n\/\/Cube projection, cheap to compute and not too much deformation\nvec3 cubeproj(in vec3 p)\n{\n    vec3 x = tex( vec2(p.z,p.y)\/p.x );\n    vec3 y = tex( vec2(p.x,p.z)\/p.y );\n    vec3 z = tex( vec2(p.x,p.y)\/p.z );\n    \n    \/\/simple coloring\/shading\n    x *= vec3(1,0,0)*abs(p.x) + p.x*vec3(0,1,0);\n    y *= vec3(0,1,0)*abs(p.y) + p.y*vec3(0,0,1);\n    z *= vec3(0,0,1)*abs(p.z) + p.z*vec3(1,0,0);\n    \n    \/\/select face\n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\n\/\/HEALPix  (debugged and cleaned from: http:\/\/www.cse.cuhk.edu.hk\/~ttwong\/papers\/spheremap\/spheremap.html)\n\/\/Has several advantages, might not be as versatile as cubemapped.\nvec3 healpix(vec3 p)\n{\n\tfloat a = atan(p.z, p.x) * 0.63662; \n\tfloat h = 3.*abs(p.y);\n\tfloat h2 = .75*p.y;\n\tvec2 uv = vec2(a + h2, a - h2);\n\th2 = sqrt(3. - h);\n\tfloat a2 = h2 * fract(a);\n    uv = mix(uv, vec2(-h2 + a2, a2), step(2., h));    \n  \t\n    vec3 col = tex(uv);\n    col.x = a*0.5;\n    return hsv2rgb(vec3(col.x,.8,col.z));\n}\n\n\/\/Triplanar, not really a sphere mapping, but adding it for completeness sake\nvec3 tpl(in vec3 p)\n{\n\tvec3 x = tex(p.yz);\n\tvec3 y = tex(p.zx);\n\tvec3 z = tex(p.xy);\n    \n    \/\/simple coloring\/shading\n    x *= vec3(1,0,0)*abs(p.x) + p.x*vec3(0,1,0);\n    y *= vec3(0,1,0)*abs(p.y) + p.y*vec3(0,0,1);\n    z *= vec3(0,0,1)*abs(p.z) + p.z*vec3(1,0,0);\n    \n    p = normalize(max(vec3(0),abs(p)-.6));\n    return x*p.x + y*p.y + z*p.z;\n}\n\n\/\/Spherical coordinates, very heavy deformation on the poles\nvec3 sphproj(in vec3 p)\n{\n    vec2 sph = vec2(acos(p.y\/length(p)), atan(p.z,p.x));\n    \n    vec3 col = tex(sph*.9);\n    col.x = sph.x*0.4;\n    return hsv2rgb(vec3(col.x,.8,col.z));\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return -1.;\n    return -b - sqrt(h);\n}\n\nvoid main(void)\n{\t\n\tvec2 p = gl_FragCoord.xy\/iResolution.xy-0.5;\n\tp.x*=iResolution.x\/iResolution.y;\n\tvec2 um = iMouse.xy \/ iResolution.xy-.5;\n\tum.x *= iResolution.x\/iResolution.y;\n    p*= 1.5;\n\t\n    \/\/camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx = mm2(time*.4+um.x*5.);\n    mat2 my = mm2(time*0.3+um.y*5.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float sel = mod(floor(time*0.3),4.);\n    \n    float t = iSphere(ro,rd);\n    vec3 col = vec3(0);\n    if (sel == 0.) col = cubeproj(rd)*1.1;\n    else if (sel == 1.) col = tpl(rd)*1.2;\n    else if (sel == 2.) col = healpix(rd);\n    else col = sphproj(rd);\n    \n        if (t > 0.)\n    {\n    \tvec3 pos = ro+rd*t;\n    \tif (sel == 0.) col = cubeproj(pos)*1.1;\n        else if (sel == 1.) col = tpl(pos)*1.2;\n        else if (sel == 2.) col = healpix(pos);\n        else col = sphproj(pos);\n    }\n    \n\tgl_FragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dSXDR","date":"1411507642","viewed":29,"name":"Another eye","username":"jaba","description":"The pupil is animated with the music.\nInpired by Inigo Quilez tutorial","likes":0,"published":1,"tags":["procedural","2d","music","eye","iris"],"hasliked":0},"renderpass":[{"inputs":[{"id":13,"src":"\/presets\/mzk00.mp3","ctype":"music","channel":1},{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ Created by Javier Barandiaran Martirena 2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise( in vec2 x ){return texture2D(iChannel0, x).x;}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.50000*noise( p ); p = p*2.04;\n    f += 0.25000*noise( p ); p = p*2.02;\n    f += 0.12500*noise( p ); p = p*2.03;\n    f += 0.06250*noise( p ); p = p*2.05;\n    f += 0.03125*noise( p );\n\n    return f\/0.96875;\n}\n\nvoid main(void)\n{\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\t\n    vec2 distv = gl_FragCoord.xy - 0.5 * iResolution.xy;\n    float dist = sqrt( dot( distv, distv ) );\n\n    \/\/remap coordinates between (-1,1)\n    vec2 p = -1.0 + 2.0 * uv; \n    p.y *= iResolution.y \/ iResolution.x; \/\/remove aspect ratio    \n    \n    \/\/polar coordinates\n    float r = sqrt( dot( p, p ) );\n    float a = atan( p.y, p.x );\n    \/\/polar coordinates with 90 degrees rotation\n    vec2 p2 = vec2( p.x*cos( 1.57 ) - p.y *sin( 1.57 ), p.y * cos( 1.57 ) + p.x * sin( 1.57 ) );    \n    float a2 = atan( p2.y, p2.x );\n\n    \n    float irisRadius = iResolution.y*0.45;\n    float irisGrad = iResolution.y*0.04;\n    float pupilRadius = iResolution.y*0.15;\n    float pupilGrad = iResolution.y*0.03;    \n    float scleraRadius = iResolution.y*0.85;\n    float scleraGrad = iResolution.y*0.1;\n    \n    \/\/ Calculate average frequency of the music\n    float fftAvg = 0.0;\n    float x = 0.0;\n    for ( int i = 0; i < 10; ++ i)\n    {\n        float fft  = texture2D( iChannel1, vec2(x,0.25) ).x;\n        x+=0.1;       \n        fftAvg += fft;                \n    }\t\n    float mul = 0.8+fftAvg * 0.15;\n    \n\t\/\/ Modify pupil radius with the music\n    pupilRadius *= mul;\n    pupilGrad *= mul;    \n    \n    const vec3 irisColor = vec3(0.7,0.85,0.99);\n    const vec3 irisColor2 = vec3(0.4,0.2,0.2);\n    const vec3 irisColor3 = vec3(0.7,0.99,0.85);\n    const vec3 irisColor4 = vec3(0.9,0.99,0.5);\n    const vec3 scleraColor = vec3(0.98,0.95,0.98);\n    \n    float factor =  smoothstep( irisRadius*1.1, pupilRadius, dist );\n    factor *= factor;\n    float animIris = 1.0\/mul;    \n    \/\/The internal radius of the iris should contract and dilate with the pupil\n    \/\/but the external radius remains fixed\n    float f2 = fbm( vec2( (1.0-factor) * 0.5*r + factor*animIris*0.4*r, 0.2*a2) );\n    float f3 = fbm( vec2( (1.0-factor) * 0.4*r + factor*animIris*0.2*r, 0.2*a2) );\n    float f4 = fbm( vec2( (1.0-factor) * 0.2*r + factor*animIris*0.1*r,0.5+ 0.1*a2 ) );\n    float f5 = fbm( vec2( (1.0-factor) * 0.4*r + factor*animIris*0.4*r, 0.5*a2 ) );\n              \n    vec3 col = mix( irisColor, vec3(0.1), f2 ); \/\/blue\n    vec3 col2 = mix( irisColor3, vec3(0.2), f2 ); \/\/green\n    vec3 col3 = mix( irisColor4, vec3(0.1), f2 ); \/\/green\n    \/\/green in the center around the pupil\n    col=mix( col, col2, smoothstep( 3.0*pupilRadius, 0.0, dist ) );\n    \/\/green spots\n    col=mix( col, col2,smoothstep( 0.4, 0.6, ( f3 ) ) );\n    \/\/green spots\n    col=mix( col, col3, 0.4*smoothstep( 0.4, 0.6, f4 ) );\n    \/\/white lines\n    col=mix( col, vec3(1.0), 0.4*smoothstep( 0.3, 1.0, f5 ) );\n     \n    \/\/darken the external perimeter of the iris\n    col *= clamp( 0.6+smoothstep( irisRadius, 0.0, dist ), 0.0, 1.0 );\n\n    \/\/iris circle\n    float f = smoothstep(irisRadius-irisGrad,irisRadius, dist );\n    \/\/sclera\n    \/\/red veins\n    float f6 = smoothstep(0.49, 1.0, fbm( vec2( 0.5*r, a+fbm(0.07*p) ) ) );    \n    vec3 scleraColor2 = mix( scleraColor, vec3(1.0,0.0,0.0), 0.3*f6 );\n    \/\/mix sclera and iris\n    col = mix( col, scleraColor2, f );\n\n    \/\/eyeball\n    \/\/darken the external radius of the eyeball\n    f = smoothstep(irisRadius,scleraRadius, dist );\n    col = mix( col, 0.5*scleraColor, 0.4*f ); \n    \/\/red corners\n    f = smoothstep(scleraRadius-scleraGrad,scleraRadius, dist );    \n    col = mix( col, vec3(0.8,0.0,0.0), 0.3*f ); \n\n    \/\/pupil black circle\n    f = 1.0 - smoothstep( pupilRadius- pupilGrad, pupilRadius, dist );\n    col = mix( col, vec3(0.0), f );\n    \n    \/\/Corneal reflections\n    col += 0.4*smoothstep( 0.05, 0.0, length( p - vec2( 0.1, 0.1 ) ) );\n    col += smoothstep( 0.3, 0.0, length( p - vec2( 0.2, 0.2 ) ) );\n    col += 0.4*smoothstep( 0.2, 0.0, length( p - vec2( -0.2, -0.2 ) ) );\n        \n    \/\/Eyelid\n   \tvec3 eyelidShadow = vec3( smoothstep( 0.0, 0.17, -0.4 - p.y + 0.4*p.x * p.x ) +\n                smoothstep( 0.0, 0.17, -0.12 + p.y + 0.2*p.x * p.x ) );    \n    vec3 eyelid = vec3( smoothstep( 0.0, 0.015, -0.5 - p.y + 0.4*p.x * p.x ) +\n                smoothstep( 0.0, 0.015, -0.3 + p.y + 0.3*p.x * p.x ) );\n\tcol = mix( col, vec3( 0.0, 0.0, 0.0 ), 0.7*eyelidShadow );\n    col = mix( col, vec3( 0.79, 0.69, 0.69 ), eyelid );\n\t\n    \/\/darken the top of the image\n    col *= 0.5 + 0.5 * pow(1.0-uv.y,0.4);\n\tgl_FragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sjSW1","date":"1411505248","viewed":46,"name":"Remnant X","username":"Dave_Hoskins","description":"Binary subdivision finds the surface really well with this fractal. Two light sources with shadows, and near surface glows.\nMOUSE X TO TIME WARP","likes":2,"published":1,"tags":["3d","raymarching","fractal","remnantx"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ Remnant X\n\/\/ by David Hoskins.\n\/\/ Thanks to boxplorer and lots of people at 'Fractalforums.com'\n\n\/\/ #define STEREO\n\nvec3 sunDir  = normalize( vec3(  0.35, 0.1,  0.3 ) );\nconst vec3 sunColour = vec3(1.0, .95, .8);\n\n\n#define SCALE 2.85\n#define MINRAD2 .25\nfloat minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);\nvec4 scale = vec4(SCALE, SCALE, SCALE, abs(SCALE)) \/ minRad2;\nfloat absScalem1 = abs(SCALE - 1.0);\nfloat AbsScaleRaisedTo1mIters = pow(abs(SCALE), float(1-10));\nvec3 surfaceColour1 = vec3(.8, .0, 0.);\nvec3 surfaceColour2 = vec3(.4, .4, 0.5);\nvec3 surfaceColour3 = vec3(.5, 0.3, 0.00);\nvec3 fogCol = vec3(0.4, 0.4, 0.4);\n\n\/\/--------------------------------------------------------------------------\n\/\/ Noise functions...\nfloat Hash( float n )\n{\n    return fract(sin(n)*33753.545383);\n}\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -500.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat Map(vec3 pos) \n{\n\t\/\/return (length(pos)-4.0);\n\n\tvec4 p = vec4(pos,1);\n\tvec4 p0 = p;  \/\/ p.w is the distance estimate\n\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\n\t\t\/\/ sphere folding: if (r2 < minRad2) p \/= minRad2; else if (r2 < 1.0) p \/= r2;\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2\/r2, minRad2), 0.0, 1.0);\n\n\t\t\/\/ scale, translate\n\t\tp = p*scale + p0;\n\t}\n\treturn ((length(p.xyz) - absScalem1) \/ p.w - AbsScaleRaisedTo1mIters);\n}\n\nvec3 Colour(vec3 pos, float sphereR) \n{\n\t\/\/scale.z = 0.0;\n\tvec3 p = pos;\n\tvec3 p0 = p;\n\tfloat trap = 1.0;\n    \n\tfor (int i = 0; i < 6; i++)\n\t{\n        \n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2\/r2, minRad2), 0.0, 1.0);\n\n\t\tp = p*scale.xyz + p0.xyz;\n\t\ttrap = min(trap, r2);\n\t}\n\t\/\/ |c.x|: log final distance (fractional iteration count)\n\t\/\/ |c.y|: spherical orbit trap at (0,0,0)\n\tvec2 c = clamp(vec2( 0.3333*log(dot(p,p))-1.0, sqrt(trap) ), 0.0, 1.0);\n\n    float t = mod(length(pos) + iGlobalTime*.2, 4.0);\n    surfaceColour1 = vec3(1.0, .0, 0.) * clamp(t, 0.0, 0.3)*3.0;\n\treturn mix(mix(surfaceColour1, surfaceColour2, c.y), surfaceColour3, c.x);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 pos, float distance)\n{\n\tvec2 eps = vec2(distance, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy) - Map(pos-eps.xyy),\n\t    Map(pos+eps.yxy) - Map(pos-eps.yxy),\n\t    Map(pos+eps.yyx) - Map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat GetSky(vec3 pos)\n{\n    pos *= 2.3;\n\tfloat t = Noise(pos);\n    t += Noise(pos * 2.1) * .5;\n    t += Noise(pos * 4.3) * .25;\n    t += Noise(pos * 7.9) * .125;\n\treturn t;\n}\n\n\n\/\/--------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\n{\n\tfloat halfwayT = 0.0;\n\tfor (int n = 0; n < 5; n++)\n\t{\n\t\thalfwayT = (oldT + t ) * .5;\n\t\tif (Map(rO + halfwayT*rD) < .001)\n\t\t{\n\t\t\tt = halfwayT;\n\t\t}else\n\t\t{\n\t\t\toldT = halfwayT;\n\t\t}\n\t}\n\treturn (oldT + t ) * .5;;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Scene(in vec3 rO, in vec3 rD)\n{\n\tfloat t = .02+ 0.05 * texture2D(iChannel0, gl_FragCoord.xy \/ iChannelResolution[0].xy).y;\n\tvec3 p = vec3(0.0);\n    float oldT = 0.0;\n    bool hit = false;\n    float glow = 0.0;\n    vec2 dist;\n\tfor( int j=0; j < 80; j++ )\n\t{\n\t\tif (t > 12.0 || hit) break;\n        p = rO + t*rD;\n       \n\t\tfloat h = Map(p);\n        \n\t\tif( h <0.001)\n\t\t{\n            dist = vec2(t, oldT);\n            hit = true;\n        }else\n        {\n        \tglow += clamp(.05-h, 0.0, .4);\n        \tt +=  h + t*0.001;\n\t        oldT = t;\n        }\n \t}\n    if (!hit)\n        t = 1000.0;\n    else\n        t = BinarySubdivision(rO, rD, dist.x, dist.y);\n    return vec2(t, clamp(glow*.25, 0.0, 1.0));\n\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec3 p = vec3(.025+4.0 * sin(2.14*t),.1+ 4.0 * sin(1.5*t),.4+4.0 * cos(3.5*t) );\n\treturn p;\n} \n\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n} \n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t\/\/ Then...\n\t#define CONTRAST 1.4\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.1\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t\/\/ Noise...\n\t\/\/rgb = clamp(rgb+Hash(xy*iGlobalTime)*.1, 0.0, 1.0);\n\t\/\/ Vignette...\n\trgb *= .5 + 0.5*pow(20.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2);\t\n\n\treturn rgb;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 9; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(6.0*h \/ t, res);\n\t\tt += h;\n\t}\n    return max(res, 0.0);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 LightSource(vec3 spotLight, vec3 dir, float dis)\n{\n    float g = 0.0;\n    if (length(spotLight) < dis)\n    {\n\t\tg = pow(max(dot(normalize(spotLight), dir), 0.0), 600.0) * 1.5;\n    }\n   \n    return vec3(1.0) * g;\n}\n    \n\/\/--------------------------------------------------------------------------\nvoid main(void)\n{\n\tfloat m = (iMouse.x\/iResolution.x)*300.0;\n\tfloat gTime = (iGlobalTime+m)*.01 + 8.208;\n    vec2 xy = gl_FragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y, 1.0);\n\t\n\t\n\t#ifdef STEREO\n\tfloat isRed = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\n\t#endif\n\n\tvec3 cameraPos\t= CameraPath(gTime);\n    vec3 camTar\t\t= CameraPath(gTime + .01);\n\n\tfloat roll = 3.0*gTime;\n\tvec3 cw = normalize(camTar-cameraPos);\n\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\n\tvec3 cv = normalize(cross(cu,cw));\n    cw = RotationMatrix(cv, sin(-gTime*19.3)*1.0) * cw;\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\t#ifdef STEREO\n\tcameraPos += .008*cu*isRed; \/\/ move camera to the right\n\t#endif\n\n    vec3 spotLight = CameraPath(gTime + .03) + vec3(sin(gTime*15.0), cos(gTime*13.98), sin(gTime * 21.53))*.2;\n\tvec3 col = vec3(0.0);\n    vec3 sky = vec3(0.03, .04, .05) * GetSky(dir);\n\tvec2 ret = Scene(cameraPos, dir);\n    \n    if (ret.x != 1000.0)\n    {\n\t\tvec3 p = cameraPos + ret.x*dir; \n\t\tvec3 nor = GetNormal(p, ret.x*ret.x*.0015);\n        \n       \tvec3 spot = spotLight - p;\n\t\tfloat atten = length(spot);\n\n        spot \/= atten;\n        \n        float shaSpot = Shadow(p, spot);\n        float shaSun = Shadow(p, sunDir);\n        \n       \tfloat bri = max(dot(spot, nor), 0.0) \/ pow(atten, 1.5) * .1;\n        float briSun = max(dot(sunDir, nor), 0.0) * .6;\n        \n       col = Colour(p, ret.x);\n       col = (col * bri * shaSpot) + (col * briSun* shaSun);\n        \n       vec3 ref = reflect(dir, nor);\n       col += pow(max(dot(spot,  ref), 0.0), 10.0) * 2.0 * shaSpot * bri;\n       col += pow(max(dot(sunDir, ref), 0.0), 10.0) * 2.0 * shaSun  * bri;\n    }\n    col += vec3(pow(abs(ret.y), 2.)) * vec3(.05, .15, .2);\n    col = mix(sky, col, min(exp(-ret.x+1.5), 1.0));\n \n\tcol = PostEffects(col, xy);\t\n    col += LightSource(spotLight-cameraPos, dir, ret.x);\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isRed, 1.0-isRed, 1.0-isRed );\t\n\t#endif\n\t\n\tgl_FragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ Remnant X\n\/\/ by David Hoskins.\n\n#define TAU  6.28318530718\n\nfloat n1 = 0.0;\nfloat n2 = 0.0;\nfloat n3 = 0.0;\nfloat n4 = 0.0;\nfloat fb_lp = 0.0;\nfloat fb_hp = 0.0;\nfloat hp = 0.0;\nfloat p4=1.0e-24;\n\nfloat gTime;\nfloat beat;\n\n\n#define N(a, b) if(t > a){x = a; n = b;}\n#define K(a) if(t > a) x = a;\n#define BRING_IN\n\nfloat sample = 1.0 \/ iSampleRate;\n\n\/\/ Low pass resonant filter...\nfloat Filter(float inp, float cut_lp, float res_lp)\n{\n\tfb_lp \t= res_lp+res_lp\/(1.0-cut_lp);\n\tn1 \t\t= n1+cut_lp*(inp-n1+fb_lp*(n1-n2))+p4;\n\tn2\t\t= n2+cut_lp*(n1-n2);\n    return n2;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 3.4337);\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Noise(float time, float pitch)\n{\n    float ret = Hash(floor(time * pitch));\n\treturn ret;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat noteMIDI(float n)\n{\n\treturn 440.0 * pow(2.0, (n - 69.0) \/ 12.0);\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Saw(float time, float pitch)\n{\n    float f1 = fract(time * pitch);\n    float f2 = fract(time * pitch * .99);\n    float f3 = fract(time * pitch * 2.01);\n    return (f1+f2+f3) \/ 1.5 - 1.0;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Kick()\n{\n    #ifdef BRING_IN\n    if (beat < 24.0) return 0.0;\n    #endif\n    float x = 0.0;\n    float t = mod(beat, 8.0);\n    \n    K(0.0);\n    K(0.5);\n    K(4.0);\n    K(6.0);\n    K(7.5);\n    \n    t = t-x;\n    float vol = exp(-t*.5);\n    \n    float kick = sin(t*220.0* exp(-t* .75));\n    \n    kick = (1.5 * kick - 0.5 * kick * kick * kick);\n    \n    \n    return kick * vol * .5;\/\/ * smoothstep(0.0, .3, t);\n}\n\n\/\/----------------------------------------------------------------------------------\nvec2 Cymbals()\n{\n\t#ifdef BRING_IN\n    if (beat < 16.0) return vec2(0.0);\n    #endif\n    \n    float x = 0.0;\n    float n = 0.0;\n    float t = mod(beat, 8.0);\n\n    N(0.0, .2);\n    N(0.5, .5);\n    N(2.5, .75);\n    N(3.0, 1.0);\n    N(4.0, .2);\n    N(4.5, .7);\n    N(6.5, 1.0);\n    N(7.0, .6);\n    N(7.75, .8);\n    t = t-x;\n    \n    float vol = exp(-pow(abs(t), .3)*1.5) * .7 * n * smoothstep(0.0, .03, t);\n\tvec2 cym = vec2(Noise(t, 10000.0), Noise(t, 9000.0));\n   \n    return cym * vol;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Snare()\n{\n    float x = 0.0;\n    float n = 0.0;\n    #ifdef BRING_IN\n    if (beat < 48.0) return 0.0;\n    #endif\n    float t = mod(beat, 8.0);\n    \n    N(1.0, 1.0);\n    N(3.0, 1.0);\n    N(3.25, .5);\n    N(5.0, 1.0);\n    N(5.25, .5);\n    N(7.0, 1.0);\n    N(7.25, .5);\n    N(7.5, 1.0);\n    t = t-x;\n    \n    float vol = exp(-pow(abs(t), .7) * 1.5) * n * .3;\n    \n    float sna = sin(t * 220.0 * exp(-t*.2)) * .8;\n\tsna += Noise(t, 5200.0 * exp(-t*.1));    \n    \n    return sna * vol;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Bass()\n{\n    float n;\n    float x = 0.0;\n    float t = mod(beat, 16.0);\n    \n    N(0.0, 36.0);\n    N(4.0, 35.0);\n    N(6.0, 34.0);\n    N(8.0, 33.0);\n\n    float p = noteMIDI(float(n));\n    t = t-x;\n    float vol = exp(-t*.3) * smoothstep(0.0, .05, t) * .4;\n    float saw = 0.0;\n    float low = (cos(beat*.15)+1.0) *.45 + .05;\n    float res = 1.0-(cos(beat*.25)+1.0) *.45 + .01;\n\n    for (int i = 0; i < 50; i++)\n    {\n        float s = Saw(gTime-(float(i)* sample), p) * .6;\n        s += Noise(gTime-(float(i) * sample), p*16.0) *.4;\n        saw = Filter(s, low, res);\n    }\n    return saw*vol;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Lead()\n{\n    float n;\n    float x = 0.0;\n    \n    #ifdef BRING_IN\n\tif (beat < 31.0) return 0.0;\n    #endif\n\n    float t = mod(beat+.15, 32.0);\n    \n    N(0.0, 58.0);\n    N(.5, 60.0);\n    N(2.0, 48.0);\n    N(4.0, 59.0);\n    N(6.0, 58.0);\n    N(8.0, 57.0);\n    \n    N(16.0, 58.0);\n    N(16.5, 60.0);\n    N(18.0, 48.0);\n    N(20.0, 59.0);\n    N(22.0, 60.0);\n    N(24.0, 64.0);\n\n    N(31.0, 54.0);\n    N(31.5, 56.0);\n\n    float p = noteMIDI(float(n));\n    t = t-x;\n    float vol = exp(-t*.3) * smoothstep(0.0, .4, t) * .2;\n    float saw = 0.0;\n    float low = (sin(beat * .3) + 1.0) *.28 + .01;\n    float res = (cos(beat *.025) + 1.0) *.35 + .2;\n\n    for (int i = 0; i < 50; i++)\n    {\n        float s1 = Saw(gTime-(float(i) * sample), p);\n        float s2 = Noise(gTime-(float(i) * sample), p*4.0) + Noise(gTime-(float(i) * sample+130.0), p*2.0);\n        saw = Filter(s1*.6 + s2, low, res) * .6;\n    }\n    return saw * vol;\n}\n\n\/\/----------------------------------------------------------------------------------\nvec2 mainSound(float time)\n{\n\tgTime = time;\n\tbeat = time * 2.2;\n    \n   \tvec2 audio = vec2(0.0, 0.0);\n    \n    float b1 = Bass();\n    float b2 = 1.0-b1;\n    float kick = Kick();\n    float snare = Snare();\n    vec2 cymb = Cymbals();\n    float lead = Lead();\n    \n    audio = vec2(b1, b2);\n    audio += vec2(kick);\n    audio += vec2(snare);\n    audio += cymb;\n    audio += lead;\n    \n    return clamp(audio * .55 * smoothstep(60.0, 52.0, time) * smoothstep(0.0, 1.0, time), -1.0, 1.0);\n    \n    \/\/return vec2(0.0); \/\/ Disabled.\n}","name":"","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"XsjSW1","date":"1411504358","viewed":21,"name":"Radial Colorize with Colors","username":"Paraknight","description":"A shader written for http:\/\/gamedev.stackexchange.com\/questions\/83853\/how-to-implement-color-changing-fragment-shader","likes":0,"published":1,"tags":["radial","gdse","colorize"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"void main(void)\n{\n    \/\/ Scale UV coords to account for rectangular window\n\tvec2 uv = vec2(gl_FragCoord.x - 0.25 * iResolution.x, gl_FragCoord.y) \/ iResolution.y;\n    \n    uv = 2.0 * uv - 1.0;\n    \n    \/\/ Double the speed\n    float wave = sin(iGlobalTime * 2.0);\n    \n    \/\/ Scale to make the circle bigger so it reaches the far edges\n    float circle = (uv.x * uv.x + uv.y * uv.y) * 0.2;\n    \n    vec4 color1 = vec4(1.0, 0.0, 0.0, 1.0); \/\/ Red\n    vec4 color2 = vec4(0.0, 0.0, 1.0, 1.0); \/\/ Blue\n    \n    \/\/ Lerp the two\n\tgl_FragColor = mix(color1, color2, circle + wave);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xs2SDh","date":"1411494416","viewed":22,"name":"inky surfboard","username":"wgoldie","description":"playing with sines more","likes":0,"published":1,"tags":["2d"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"#define MOUSE\n\nconst vec4 K = vec4(1., 2. \/ 3., 1. \/ 3., 3.);\nvec3 hsv2rgb(vec3 c)\n{\n\t\/\/ from http:\/\/lolengine.net\/blog\/2013\/07\/27\/rgb-to-hsv-in-glsl\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n\nconst float rads = 2. * 3.14159;\nconst float oscRate = 2.;\n\nvoid main(void)\n{\n    vec2 uv = gl_FragCoord.xy \/ iResolution.x;\n    #ifdef MOUSE\n    vec2 center = iMouse.xy \/ iResolution.x;\n    float tMod = (center.x + 1.);\n    float t = iGlobalTime * oscRate * tMod * tMod;\n\n    #else\n    float cx = sin(iGlobalTime) * 0.5 + 0.5;\n    vec2 center = vec2(cx, sin(cx * rads) * 0.25 + 0.25);\n    float t = iGlobalTime * oscRate;\n    #endif\n    \n    float sinT = sin(t);\n    \n    float d = distance(center, uv);\n    float rings = mod((d * d * 500.), (sinT + 1.5) * 10.) * 0.5 + 0.5;\n    \n    vec3 target = vec3(cos(t), sinT, 0.);\n    float line = dot(target, vec3(uv - center, 1.));\n    float ink = cos(sqrt(line) * 50.) * 0.5 + 0.5;\n    \n\tgl_FragColor = vec4(hsv2rgb(vec3(d,ink,rings)), 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsjSDh","date":"1411486941","viewed":29,"name":"Spiral                         .","username":"ChuckNorris","description":"For best effect enable fullscreen mode and look at center for one minute","likes":0,"published":1,"tags":["spiral","cc0"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ LICENSE: CC0\n\/\/ *-SA-NC considered to be cancerous and non-free\n\nconst float PI = 3.14159;\n\nvoid main(){\n    vec2 uv = gl_FragCoord.xy \/ iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x\/iResolution.y;\n    \n    float r = length(uv);\n    float a = atan(uv.y, uv.x)*10.0;\n    a += iGlobalTime*10.0;\n    a += log(r)*50.0;\n    \n    float g = cos(mod(a, PI)*2.0)*0.5 + 0.5;\n    \n    g *= smoothstep(0.0, 0.7, r);\n    \n    gl_FragColor = vec4(g);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xd2XWh","date":"1411483305","viewed":35,"name":"Centaurs","username":"erucipe","description":"random phase animation","likes":0,"published":1,"tags":["3d","animation","centaur"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"const float pi = 3.141592653589793;\n\nfloat hash(in vec3 p) {\n\treturn fract(sin(dot(p, vec3(15.64, 35.78, 75.42))) * 43758.23);\t\n}\n\nfloat shash(in vec3 p) {\n\treturn hash(p) * 2.0 - 1.0;\t\n}\n\nfloat sdPlane(in vec3 p) {\n\treturn p.y + 0.45;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n\treturn length(p) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa, ba) \/ dot(ba , ba), 0.0, 1.0 );\n    \treturn length( pa - ba * h ) - r;\n}\n\nfloat motor(float _min, float _max, float time) {\n\tfloat t = 0.5 + 0.5 * sin(time);\n\treturn mix(_min, _max, t);\n}\n\nvec3 rotate_from_origin(vec3 origin, vec3 target, float r, float angle) {\n\treturn vec3(\n\t\torigin.x + r * cos(angle),\n\t\torigin.y + r * sin(angle),\n\t\ttarget.z\n\t);\n}\n\nvec3 preserve(vec3 p0, vec3 p1, float len) {\n\tvec3 v = p1 - p0;\n\tvec3 u = normalize(v);\n\treturn p0 + len * u;\n}\n\nfloat smin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 map(in vec3 p) {\n\tvec3 q = p;\n\tvec3 c = vec3(2.5, 0.0, 1.5);\n\tp = mod(p,c) - 0.5 * c;\n\t\n\tfloat k = hash(floor( q * vec3(1.0 \/ 2.5, 1.0, 1.0 \/ 1.5) - vec3(0.0, 0.5, 0.0) ));\n\tfloat phase = k * pi;\n\tfloat t = iGlobalTime * (1.0 + k * 4.0);\n\t\n\tfloat cx = 0.2;\n\tfloat cz = 0.1;\n\tvec3 p0 = vec3(-cx, 0.0, 0.0);\n\tvec3 p1 = vec3(-cx, -0.2, -cz);\n\tvec3 p2 = vec3(-cx, -0.4, -cz);\n\tvec3 p3 = vec3(-cx, 0.2, cz);\n\tvec3 p4 = vec3(-cx, -0.4, cz);\n\t\n\tvec3 p5 = vec3(cx, 0.0, 0.0);\n\tvec3 p6 = vec3(cx, -0.2, -cz);\n\tvec3 p7 = vec3(cx, -0.4, -cz);\n\tvec3 p8 = vec3(cx, 0.2, cz);\n\tvec3 p9 = vec3(cx, -0.4, cz);\n\t\n\tvec3 p10 = vec3(0.0, 0.0, 0.0);\n\tvec3 p11 = vec3(cx, -0.2, 0.0);\n\t\n\tfloat angle0 = 0.0;\n\tfloat angle1 = 0.0;\n\tp0.y = -motor(-0.05, 0.05, t * 4.0 + phase);\n\tangle0 = -motor(pi * 0.35, pi * 0.55, t * 2.0 - pi * 0.5 + phase);\n\tangle1 = -motor(pi * 0.35, pi * 0.55, t * 2.0 + pi * 0.5 + phase);\n\tp1 = rotate_from_origin(p0, p1, 0.2, angle0); \n\tp3 = rotate_from_origin(p0, p3, 0.2, angle1); \n\tangle0 += -motor(0.0, pi * 0.15, t * 2.0 + pi + phase);\n\tangle1 += -motor(0.0, pi * 0.15, t * 2.0 + pi + pi + phase);\n\tp2 = rotate_from_origin(p1, p2, 0.2, angle0);\n\tp4 = rotate_from_origin(p3, p4, 0.2, angle1);\n\t\n\tt += pi * 0.5;\n\t\n\tp5.y = -motor(-0.05, 0.05, t * 4.0 + phase);\n\tangle0 = -motor(pi * 0.35, pi * 0.55, t * 2.0 - pi * 0.5 + phase);\n\tangle1 = -motor(pi * 0.35, pi * 0.55, t * 2.0 + pi * 0.5 + phase);\n\tp6 = rotate_from_origin(p5, p6, 0.2, angle0); \n\tp8 = rotate_from_origin(p5, p8, 0.2, angle1); \n\tangle0 += -motor(0.0, pi * 0.15, t * 2.0 + pi + phase);\n\tangle1 += -motor(0.0, pi * 0.15, t * 2.0 + pi + pi + phase);\n\tp7 = rotate_from_origin(p6, p7, 0.2, angle0);\n\tp9 = rotate_from_origin(p8, p9, 0.2, angle1);\n\t\n\tp10.y = -motor(-0.02, 0.02, t * 4.0 - pi * 0.5 + phase);\n\tp11 = preserve(p5, p11, -0.25);\n\tfloat w = 0.015;\n\t\n\tfloat d = sdPlane(p);\n\t\n\td = min(d, sdCapsule(p, p0, p1, w));\n\td = min(d, sdCapsule(p, p1, p2, w));\n\td = min(d, sdCapsule(p, p0, p3, w));\n\td = min(d, sdCapsule(p, p3, p4, w));\n\t\n\td = min(d, sdCapsule(p, p5, p6, w));\n\td = min(d, sdCapsule(p, p6, p7, w));\n\td = min(d, sdCapsule(p, p5, p8, w));\n\td = min(d, sdCapsule(p, p8, p9, w));\n\t\n\td = min(d, sdCapsule(p, p0, p10, w));\n\td = min(d, sdCapsule(p, p10, p5, w));\n\t\n\td = smin(d, sdCapsule(p, p5, p11, w), 0.1);\n\n    \treturn vec2(d, k);\n}\n\nvec3 calcNormal(in vec3 p) {\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tmap(p + e.xyy).x - map(p - e.xyy).x,\n\t\tmap(p + e.yxy).x - map(p - e.yxy).x,\n\t\tmap(p + e.yyx).x - map(p - e.yyx).x\n\t);\n\treturn normalize(nor);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float maxt) {\n\tfloat precis = 0.001;\n\tfloat h = precis * 2.0;\n\tfloat t = 0.0;\n\tvec2 m = vec2(0.0);\n\tfor(int i = 0; i < 60; i++) {\n\tif(abs(h) < precis || t > maxt) continue;\n\t\tm = map(ro + rd * t);\n\t\th = m.x;\n\t\tt += h;\n\t}\n\treturn vec2(t, m.y);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n\tfloat sh = 1.0;\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfor(int i = 0; i < 30; i++) {\n\tif(t > maxt) continue;\n\t\th = map(ro + rd * t).x;\n\t\tsh = min(sh, k * h \/ t);\n\t\tt += h;\n\t}\n\treturn sh;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, out vec3 p) {\n\tvec3 col = vec3(1.0);\n\tvec2 m = castRay(ro, rd, 20.0);\n\tfloat t = m.x;\n\tvec3 pos = ro + rd * t;\n\tp = pos;\n\tvec3 nor = calcNormal(pos);\n\tvec3 lig = normalize(vec3(-0.4, 0.7, 0.5));\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n\tfloat sh = softshadow(pos, lig, 0.02, 20.0, 7.0);\n\tcol = col * (dif * (0.9 + 0.5 * m.y) + spec) * (0.5 + sh * 0.5) * (1.0 - pow(t, 0.8) * 0.1);\n\treturn col;\n}\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n\tvec2 ms = 2.0 * iMouse.xy \/ iResolution.xy - 1.0;\n\tvec2 p = uv * 2.0 - 1.0;\n\tp.x *= iResolution.x \/ iResolution.y;\n\tvec3 ro = vec3(ms.x * 10.0, 1.0 - ms.y, 10.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n\tvec3 q = vec3(0.0);\n\tvec3 col = render(ro, rd, q);\n\t\n\tgl_FragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sjXWh","date":"1411483199","viewed":21,"name":"Radial Colorize","username":"Paraknight","description":"A shader written for http:\/\/gamedev.stackexchange.com\/questions\/83853\/how-to-implement-color-changing-fragment-shader","likes":0,"published":1,"tags":["radial","gdse","colorize"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"void main(void)\n{\n    \/\/ Scale UV coords to account for rectangular window\n\tvec2 uv = vec2(gl_FragCoord.x - 0.25 * iResolution.x, gl_FragCoord.y) \/ iResolution.y;\n    \n    uv = 2.0 * uv - 1.0;\n    \n    \/\/ Double the speed\n    float wave = sin(iGlobalTime * 2.0);\n    \n    \/\/ Scale to make the circle bigger so it reaches the far edges\n    float circle = (uv.x * uv.x + uv.y * uv.y) * 0.2;\n    \n\tgl_FragColor = vec4(vec3(circle + wave),1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldSXD1","date":"1411481733","viewed":32,"name":"Torus\u3000Fan","username":"gaz","description":"3d","likes":1,"published":1,"tags":["3d","polygon"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nvec2 rotate( in vec2 p, in float t )\n{\n\treturn p * cos( -t ) + vec2( p.y, -p.x ) * sin( -t );\n}   \n\nvec3 rotateX( in vec3 p, in float t )\n{\n    p.yz = rotate( p.yz, t );\n    return p;\n}\n\nvec3 rotateY( in vec3 p, in float t )\n{\n    p.zx = rotate( p.zx, t );\n    return p;\n}\n\nvec3 rotateZ( in vec3 p, in float t )\n{\n\tp.xy = rotate( p.xy, t );\n    return p;\n}\n\nstruct Mesh\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nconst float sepT = 8.0;\nconst float sepR = 10.0;\nconst float radT = 0.2;\nconst float radR = 0.5;\nconst float thetaT = PI2 \/ sepT;\nconst float thetaR = PI2 \/ sepR;\n\nMesh genTorus( in int idx )\n{\n    float i = float( idx );\n    float iT0 = mod( i, sepT );\n    float iR0 = floor( i \/ sepT );\n    float iT1 = iT0 + 1.0;\n    float iR1 = iR0 + 1.0;\n    float rad0 = radR + radT * cos( iT0 * thetaT );\n    float rad1 = radR + radT * cos( iT1 * thetaT );\n    float sin0 = sin( iR0 * thetaR );\n    float sin1 = sin( iR1 * thetaR );\n    float cos0 = cos( iR0 * thetaR );\n    float cos1 = cos( iR1 * thetaR );    \n    float h0 = radT * sin( iT0 * thetaT );\n    float h1 = radT * sin( iT1 * thetaT );    \n    \/\/vec3 v0 = vec3( rad0 * sin0, h0, rad0 * cos0 );\n    vec3 v1 = vec3( rad1 * sin0, h1, rad1 * cos0 );\n    vec3 v2 = vec3( rad0 * sin1, h0, rad0 * cos1 );\n    vec3 v3 = vec3( rad1 * sin1, h1, rad1 * cos1 );\n    \/\/if (idx < int( sepT * sepR ) ) return Mesh( v0, v1, v2 );\n    return Mesh( v3, v2, v1 );\n}\n\nvoid main( void )\n{\n\tvec2 p = ( 2.0 * gl_FragCoord.xy - iResolution.xy ) \/ iResolution.y;\n    vec3 rd =normalize( vec3( p, -1.5 ) );\n\tvec3 ro = vec3( 0.0, -0.15, 0.8 + 0.1 * sin( iGlobalTime * 0.5 ) );\n    vec3 light = normalize( vec3( 0.5, 0.8, 3.0 ) );\n    float theta;\n\ttheta = -0.7;\n\tro = rotateX( ro, theta );\n\trd = rotateX( rd, theta );       \n    light = rotateX( light, theta );    \n\ttheta = 0.2 * sin( iGlobalTime * 0.3 );\n\tro = rotateZ( ro, theta );\n\trd = rotateZ( rd, theta );       \n    light = rotateZ( light, theta );    \n\ttheta = -iGlobalTime * 0.8;\n\tro = rotateY( ro, theta );\n\trd = rotateY( rd, theta );       \n    light = rotateY( light, theta );    \n        \n    vec3 col = vec3( 0.3, 0.3, 1.0 ) * ( 0.5 + 0.3 * p.y );\n\n    vec3 far =  ro + rd * 10.0;\n    vec3 nor;\n    float z = 2.0;\n    for (int i = 0; i <int( sepT * sepR ); i++ )\n   \t{\n\t\tMesh m = genTorus( i );\n        vec3 n = cross( m.c - m.a, m.b - m.a );\n\t    float a = dot( ro - m.a, n );\n   \t\tfloat b = dot( far - m.a, n );\n        if ( a * b < 0.0 )\n        {\n    \t\tfloat t = abs( a ) \/ ( abs( a ) + abs( b ) );\n\t\t\tvec3 p = ro + ( far - ro ) * t;\n            if ( dot( cross( m.b - m.a, n ), p - m.a ) > 0.0 ) \n            if ( dot( cross( m.c - m.b, n ), p - m.b ) > 0.0 ) \n            if ( dot( cross( m.a - m.c, n ), p - m.c ) > 0.0 )\n        \t{\n            \tif ( z > t )\n                {\n                  \tz = t;\n                    nor = normalize( n );\n                }\n            }                                \n        }            \n    }\n    if (z < 2.0)\n    {     \n    \tcol = vec3( 1.0, 0.5 + 0.2 * sin( iGlobalTime * 1.5 ), 0.2 );\n        if ( dot( nor, -rd ) < 0.0 )\n            col = vec3( 0.5 + 0.5 * sin( iGlobalTime ), 1.0, 0.5 + 0.5 * sin( iGlobalTime ) );\n        float br = abs( dot( nor, light ) );\n       \tbr = clamp( ( br + 0.5 ) * 0.7, 0.3, 1.0 );        \n        float fog = min( 1.0, 0.01 \/ z \/ z );       \n       \tcol *= br * fog;\n    }\n    gl_FragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsjXWh","date":"1411479526","viewed":38,"name":"Exploring the crystal lattice","username":"Devin","description":"My attempt to create a simple 3D shader, after studying the code of other ones.","likes":1,"published":1,"tags":["3d","raymarching","balls"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"float rand(vec3 n) {\n  n = floor(n);\n  n.z = 100.0*fract(n.z\/100.0);\n  return fract(sin((n.x*1e2+n.y*1e4+n.z*1e6)*1e-4)*1e5);\n}\n\n\/\/distance\nfloat map( vec3 ray) {\n    vec3 f = fract( ray ) -0.5;\n\tfloat cr = rand( ray );\n    float r1 = length(f)-cr*0.3;\n\treturn r1;\n}\n\n\/\/color\nvec3 light( vec3 ray,vec3 lightPos) {\n    vec3 f = fract( ray ) -0.5;\n\tfloat cr = rand( ray );\n    float r1 = length(f)-cr*0.3;\n    vec3 normf = normalize(f);\n    vec3 light = lightPos-ray;\n    float lighting = normf.x*light.x+normf.y*light.y+normf.z*light.z;\n    lighting=lighting<0.0?0.0:lighting;\n    float l2 = length(light);\n\treturn 3.0*lighting\/pow((l2+0.40),2.5)*vec3(0.8*cr,0.5,0.8-cr);\n}\n\nvoid main( void ) {\n    vec2 pos = (gl_FragCoord.xy*2.0 - iResolution.xy) \/ iResolution.y;\n    float t = iGlobalTime+0.2;\n    float tt = iGlobalTime+2.0;\n    \n    \/\/camera\n    vec3 camPos = vec3(cos(iGlobalTime*0.5), sin(iGlobalTime*0.5), -iGlobalTime*0.5);\n    vec3 camTarget = vec3(cos(t*0.5), sin(t*0.5), -t*0.5);\n    vec3 camDir = normalize(camTarget-camPos);\n    vec3 camUp  = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 camSide = cross(camDir, camUp);\n    camUp  = cross(camDir, camSide);\n    vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir*1.5);\n    \n    \/\/light position\n    vec3 lightPos = vec3(cos(tt*0.5), sin(tt*0.5), -tt*0.5);\n    lightPos += vec3(0.1*sin(iGlobalTime*5.0),0.1*cos(iGlobalTime*3.0),0.1*cos(iGlobalTime*4.0));\n    lightPos -=pow(1.0-2.0*abs(fract(iGlobalTime\/7.0)-0.5),6.)*(-camDir)*5.0;\n    \n    \/\/raymarching\n    vec3 ray = camPos;\n    float d;\n    float total_d = 0.;\n    float halo = 0.0;\n    for(int i=0; i<100; ++i) {\n        d = map(ray);\n        d=d>0.3?0.3:d;\n        if ((halo==0.0)&&(total_d>length(lightPos-camPos))) {\n                float l_min = length(cross(lightPos-ray,rayDir));\n\t\t\t\thalo = 0.0005\/l_min\/l_min;}\n        total_d += d;\n        ray += rayDir * d;\n        if(d<0.007) { break; }\n        if(total_d>25.0) { break; }\n    }\n    gl_FragColor = vec4( light(ray,lightPos)+halo*(1.0,1.0,1.0), 1.0 );;\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xd2SWh","date":"1411459836","viewed":29,"name":"Image warp 1","username":"darkhus","description":"simple image warp, use mouse to warp","likes":0,"published":1,"tags":["2d","warp","image"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\nvoid main(void)\n{\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n    vec2 m = vec2(iMouse.x, iMouse.y) \/ iResolution.xy;\n    float ratio = iResolution.x \/ iResolution.y;\n    \n    vec2 pos = m;\n    if(m.x < 0.01 && m.y < 0.1)\n        pos = vec2(0.5);\n\n    vec2 dxy = vec2(ratio, 1.0);\n    float dist = distance(pos * dxy, uv * dxy);\n    \n    uv.y = 1.0-uv.y;\n    uv -= vec2(0.5) ;\n    uv *= dist*0.6;\n    \n\tgl_FragColor = texture2D(iChannel0, uv+vec2(0.5));\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4djSWh","date":"1411459196","viewed":31,"name":"Energy circle","username":"darkhus","description":"circle","likes":1,"published":1,"tags":["2d","circle"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\n\nvoid main(void)\n{\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n    float ratio = iResolution.x \/ iResolution.y;\n    \n    int side = 0;\n    if(uv.x > 0.5 && uv.y > 0.5)\n        side = 1;\n    if(uv.x > 0.5 && uv.y < 0.5)\n        side = 2;\n    if(uv.x < 0.5 && uv.y < 0.5)\n        side = 3;\n    \n    vec4 col_back = vec4(0.0);\n    \n    float tt = iGlobalTime;\n    float ff = 0.35;\n    vec2 pos = vec2(sin(tt*0.6)*ff, cos(tt*0.6)*ff) + vec2(0.5, 0.5);\n           \n    float s = 2.0;\n    float dx = (1.4 + sin(-iGlobalTime*s)*0.1 )*exp(uv.x*sin(tt*0.3)*float(side)*0.5);\n    float dy = (1.4 + cos(iGlobalTime*s*1.3)*0.1)*exp(uv.y*sin(tt)*0.2*float(side));\n    vec2 dxy = vec2(dx, dy) * 1.1;\n\n    dxy *= vec2(ratio, 1.0); \n    \n    float dist = distance(pos * dxy, uv * dxy);\n    float hole = 5.-dist*15.;\n   \n    float f = sin(tt) * 100000.0;\n    if(side == 3)\n    \tcol_back += vec4(1., 0.5, 0., 1.)*(1.5*cos(sin(dist*f))-log(hole));\n    if(side == 1)\n    \tcol_back += vec4(0., 0.5, 1., 1.)*(0.95-log(hole))*cos(sin(dist*f));\n    if(side == 2)\n    \tcol_back += vec4(0.2, 0.9, 0.3, 1.)*(0.25-log(hole))*sin((dist*f));\n    if(side == 0)\n    \tcol_back += vec4(0.8, 0.3, 0.9, 1.)*(1.05-log(hole*sin((dist*f))));\n    \n\tgl_FragColor = col_back;\n}\n","name":"","description":"","type":"image"}]}]