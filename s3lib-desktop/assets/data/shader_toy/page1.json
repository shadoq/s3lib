[{"ver":"0.1","info":{"id":"XslGRr","date":"1361810389","viewed":31062,"name":"Clouds","username":"iq","description":"Raymarching some fbm (you can move the mouse around)","likes":240,"published":1,"tags":["procedural","3d","raymarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/#define FULL_PROCEDURAL\n\n\n#ifdef FULL_PROCEDURAL\n\n\/\/ hash based 3d value noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n#else\n\n\/\/ LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.2 - p.y;\n\n\tvec3 q = p - vec3(1.0,0.1,0.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.5000*noise( q ); q = q*2.02;\n    f += 0.2500*noise( q ); q = q*2.03;\n    f += 0.1250*noise( q ); q = q*2.01;\n    f += 0.0625*noise( q );\n\n\td += 3.0 * f;\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.7,0.7,0.7), res.x );\n\t\n\treturn res;\n}\n\n\nvec3 sundir = vec3(-1.0,0.0,0.0);\n\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n\tfloat t = 0.0;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.a > 0.99 ) continue;\n\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = map( pos );\n\t\t\n\t\t#if 1\n\t\tfloat dif =  clamp((col.w - map(pos+0.3*sundir).w)\/0.6, 0.0, 1.0 );\n\n        vec3 lin = vec3(0.65,0.68,0.7)*1.35 + 0.45*vec3(0.7, 0.5, 0.3)*dif;\n\t\tcol.xyz *= lin;\n\t\t#endif\n\t\t\n\t\tcol.a *= 0.35;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n        #if 0\n\t\tt += 0.1;\n\t\t#else\n\t\tt += max(0.1,0.025*t);\n\t\t#endif\n\t}\n\n\tsum.xyz \/= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvoid main(void)\n{\n\tvec2 q = gl_FragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy \/ iResolution.xy;\n    \n    \/\/ camera\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\n    vec4 res = raymarch( ro, rd );\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\tcol = mix( col, res.xyz, res.w );\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\t    \n    gl_FragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsX3RB","date":"1372830991","viewed":30338,"name":"Volcanic","username":"iq","description":"An alien volcanic landscape. It started as an experiment on 2d-texture based 3d noise. But then I played with the noise shape, the added some shading, put lighting in it, etc..., until I got this.  I can't wait for Shadertoy to have multipass rendering...","likes":122,"published":1,"tags":["procedural","3d","raymarching","noise","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/#define STEREO \n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\n\n#ifdef STEREO\n#define lodbias -5.0\n#else\n#define lodbias 0.0\n#endif\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz, lodbias );\n\tvec4 y = texture2D( sam, p.zx, lodbias );\n\tvec4 z = texture2D( sam, p.xy, lodbias );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/=====================================================================\n\nfloat lava( vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p )\n{\n\tp += vec3(1.0,0.0,0.8);\n\t\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n\t\n\tfloat n = noise( p*3.5 );\n    f += 0.03*n*n;\n\t\n    return f;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 30.0;\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = mapTerrain( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\t\nvec4 mapClouds( in vec3 pos )\n{\n\tvec3 q = pos*0.5 + vec3(0.0,-iGlobalTime,0.0);\n\t\n\tfloat d;\n    d  = 0.5000*noise( q ); q = q*2.02;\n    d += 0.2500*noise( q ); q = q*2.03;\n    d += 0.1250*noise( q ); q = q*2.01;\n    d += 0.0625*noise( q );\n\t\t\n\td = d - 0.55;\n\td *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), res.x );\n\tres.xyz *= 0.25;\n\tres.xyz *= 0.5 + 0.5*smoothstep( -2.0, 1.0, pos.y );\n\t\n\treturn res;\n}\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax )\n{\n\tvec4 sum = vec4( 0.0 );\n\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ),6.0 );\n\tfloat t = 0.0;\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tif( t>tmax || sum.w>0.95 ) break;\/\/continue;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );\n\t\t\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += max(0.1,0.05*t);\n\t}\n\n\tsum.xyz \/= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = mapTerrain(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.02, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 16.0*cos(0.2+0.5*.1*time*1.5), 1.5, 16.0*sin(0.1+0.5*0.11*time*1.5) );\n\t\n}\n\nvoid main( void )\n{\n\t#ifdef STEREO\n\tfloat eyeID = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\n    #endif\n\n    vec2 q = gl_FragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\t\n    \/\/ camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x\/iResolution.x;\n\tfloat time = 2.7+iGlobalTime + off;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\t\/\/ta.y *= 0.3 + 0.25*cos(0.11*time);\n\tta.y *= 0.35 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.07*time);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\t\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\n\t#ifdef STEREO\n\tvec3 fo = ro + rd*7.0; \/\/ put focus plane behind Mike\n\tro -= 0.2*cu*eyeID;    \/\/ eye separation\n\trd = normalize(fo-ro);\n    #endif\n\n    \/\/ sky\t \n\tvec3 col = vec3(0.32,0.36,0.4) - rd.y*0.4;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.2*pow( sun, 6.0 );\n    col *= 0.9;\n\n\tvec3 bcol = col;\n    \n\n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\tvec3 ref = reflect( rd, nor );\n\n\t\tvec3 bn = -1.0 + 2.0*texcube( iChannel0, 3.0*pos\/4.0, nor ).xyz;\n\t\tnor = normalize( nor + 0.6*bn );\n\t\t\n\t\tfloat hh = 1.0 - smoothstep( -2.0, 1.0, pos.y );\n\n        \/\/ lighting\n\t\tfloat sun = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( sun>0.01) sha=softshadow(pos,lig,0.01,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\n\t\tfloat amb = 1.0;\n\n\t\tcol = vec3(0.8);\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += sun*vec3(1.64,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += sky*vec3(0.16,0.20,0.28)*occ;\n\t\tlin += bac*vec3(0.40,0.28,0.20)*occ;\n\t\tlin += amb*vec3(0.18,0.15,0.15)*occ;\n\t\tlin += lav*vec3(3.00,0.61,0.00);\n\n\n        \/\/ surface shading\/material\t\t\n\t\tcol = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\tcol = col*(0.2+0.8*texcube( iChannel2, 4.0*vec3(2.0,8.0,2.0)*pos, nor ).x);\n\t\tvec3 verde = vec3(1.0,0.9,0.2);\n\t\tverde *= texture2D( iChannel2, pos.xz, lodbias ).xyz;\n\t\tcol = mix( col, 0.8*verde, hh );\n\t\t\n\t\tfloat vv = smoothstep( 0.0, 0.8, nor.y )*smoothstep(0.0, 0.1, pos.y-0.8 );\n\t\tverde = vec3(0.2,0.45,0.1);\n\t\tverde *= texture2D( iChannel2, 30.0*pos.xz, lodbias ).xyz;\n\t\tverde += 0.2*texture2D( iChannel2, 1.0*pos.xz, lodbias ).xyz;\n\t\tvv *= smoothstep( 0.0, 0.5, texture2D( iChannel2, 0.1*pos.xz + 0.01*nor.x ).x );\n\t\tcol = mix( col, verde*1.1, vv );\n\t\t\n        \/\/ light\/surface interaction\t\t\n\t\tcol = lin * col;\n\t\t\n\t\t\/\/ atmospheric\n\t\tcol = mix( col, (1.0-0.7*hh)*bcol, 1.0-exp(-0.00006*t*t*t) );\n\t}\n\n\t\/\/ sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*pow( sun, 2.0 )*clamp( (rd.y+0.4)\/(0.0+0.4),0.0,1.0);\n\t\n    \/\/ smoke\t\n\t{\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t );\n\tcol = mix( col, res.xyz, res.w );\n\t}\n\n    \/\/ gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*0.3 + 0.7*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= 1.3*vec3(1.06,1.1,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    #ifdef STEREO\t\n    col *= vec3( eyeID, 1.0-eyeID, 1.0-eyeID );\t\n\t#endif\n\t\n\tgl_FragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdX3Rr","date":"1360495251","viewed":27936,"name":"Elevated","username":"iq","description":"A raymarched version of my demo Elevated from 2009","likes":142,"published":1,"tags":["procedural","3d","raymarching","distancefield","terrain"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/stereo thanks to Croqueteer\n\/\/#define STEREO \n\n\/\/ value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n\tfloat a = texture2D(iChannel0,(p+vec2(0.5,0.5))\/256.0,-100.0).x;\n\tfloat b = texture2D(iChannel0,(p+vec2(1.5,0.5))\/256.0,-100.0).x;\n\tfloat c = texture2D(iChannel0,(p+vec2(0.5,1.5))\/256.0,-100.0).x;\n\tfloat d = texture2D(iChannel0,(p+vec2(1.5,1.5))\/256.0,-100.0).x;\n\t\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat terrain( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<6; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat terrain2( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<14; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p=m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat terrain3( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat map( in vec3 p )\n{\n\tfloat h = terrain(p.xz);\n    return p.y - h;\n}\n\nfloat map2( in vec3 p )\n{\n\tfloat h = terrain2(p.xz);\n    return p.y - h;\n}\n\nfloat interesct( in vec3 ro, in vec3 rd )\n{\n    float h = 1.0;\n    float t = 1.0;\n\tfor( int i=0; i<120; i++ )\n\t{\n\t\tif( h<0.01 || t>2000.0 ) break;\n\t\tt += 0.5*h;\n\t\th = map( ro + t*rd );\n\t}\n\n\tif( t>2000.0 ) t = -1.0;\n\treturn t;\n}\n\nfloat sinteresct(in vec3 ro, in vec3 rd )\n{\n#if 0\n    \/\/ fake shadows\n\tvec3 nor;\n\tvec3  eps = vec3(20.0,0.0,0.0);\n\tnor.x = terrain3(ro.xz-eps.xy) - terrain3(ro.xz+eps.xy);\n    nor.y = 1.0*eps.x;\n    nor.z = terrain3(ro.xz-eps.yx) - terrain3(ro.xz+eps.yx);\n\tnor = normalize(nor);\n\treturn clamp( 4.0*dot(nor,rd), 0.0, 1.0 );\n#else\n    \/\/ real shadows\t\n    float res = 1.0;\n    float t = 0.0;\n\tfor( int j=0; j<48; j++ )\n\t{\n\t    vec3 p = ro + t*rd;\n        float h = map( p );\n\t\tres = min( res, 16.0*h\/t );\n\t\tt += h;\n\t\tif( res<0.001 ||p.y>300.0 ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n#endif\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n\tfloat e = 0.001*t;\n    vec3  eps = vec3(e,0.0,0.0);\n    return normalize( vec3( terrain2(pos.xz-eps.xy) - terrain2(pos.xz+eps.xy),\n                            2.0*e,\n                            terrain2(pos.xz-eps.yx) - terrain2(pos.xz+eps.yx) ) );\n}\n\nvec3 camPath( float time )\n{\n    vec2 p = 1100.0*vec2( cos(0.0+0.23*time), cos(1.5+0.21*time) );\n\treturn vec3( p.x, 0.0, p.y );\n}\n\t\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture2D( iChannel0, p\/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture2D( iChannel0, p\/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture2D( iChannel0, p\/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture2D( iChannel0, p\/256.0 ).x;\n    return f\/0.9375;\n}\n\nvoid main(void)\n{\n    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy\/iResolution.xy;\n\n\tvec2 s = xy*vec2(iResolution.x\/iResolution.y,1.0);\n\n\t#ifdef STEREO\n\tfloat isCyan = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\n    #endif\n\t\n    float time = iGlobalTime*0.15 + 0.3 + 4.0*iMouse.x\/iResolution.x;\n\t\n\tvec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n\t\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrain3( ro.xz ) + 11.0;\n\tta.y = ro.y - 20.0;\n\n\tfloat cr = 0.2*cos(0.1*time);\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( s.x*cu + s.y*cv + 2.0*cw );\n\n\t#ifdef STEREO\n\tro += 2.0*cu*isCyan; \/\/ move camera to the right - the rd vector is still good\n    #endif\n\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = interesct( ro, rd );\n    if( t<0.0 )\n    {\n        \/\/ sky\t\t\n\t\tcol = vec3(0.3,.55,0.8)*(1.0-0.8*rd.y);\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n\t\tvec2 sc = ro.xz + rd.xz*(1000.0-ro.y)\/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc)) );\n\t}\n\telse\n\t{\n        \/\/ mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n\n        vec3 nor = calcNormal( pos, t );\n        \n        \/\/ rock\n\t\tfloat r = texture2D( iChannel0, 7.0*pos.xz\/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), texture2D(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)).x );\n\t\tcol = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\n\t\t\/\/ snow\n\t\tfloat h = smoothstep(55.0,80.0,pos.y + 25.0*fbm(0.01*pos.xz) );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         \/\/ lighting\t\t\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = sinteresct(pos+light1*20.0,light1);\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(7.00,5.00,3.00)*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,0.80)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n\n\t\t\/\/ fog\n\t\tfloat fo = 1.0-exp(-0.0005*t);\n\t\tvec3 fco = 0.55*vec3(0.55,0.65,0.75) + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n\t\tcol = mix( col, fco, fo );\n\n        \/\/ sun scatter\n\t\tcol += 0.3*vec3(1.0,0.8,0.4)*pow( sundot, 8.0 )*(1.0-exp(-0.002*t));\n\t}\n\n    \/\/ gamma\n\tcol = pow(col,vec3(0.4545));\n\n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n\t\n    #ifdef STEREO\t\n    col *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tgl_FragColor=vec4(col,1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdX3zr","date":"1360969512","viewed":26266,"name":"Flame","username":"XT95","description":"Simple flame in distance field.","likes":155,"published":1,"tags":["3d","distancefield","transparency"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"float noise(vec3 p) \/\/Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iGlobalTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)\/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid main()\n{\n\tvec2 v = -1.0 + 2.0 * gl_FragCoord.xy \/ iResolution.xy;\n\tv.x *= iResolution.x\/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n\t\n\tgl_FragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n\t\/\/gl_FragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n}\n\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sfGWX","date":"1380117630","viewed":22023,"name":"Wolfenstein","username":"reinder","description":"Experiment to generate some well-known textures in a textureless shader. This shader is work in progress. \nFeel free to add comments, suggestions or a clever method to generate the most used wall texture in Wolfenstein (irregular grey bricks).","likes":53,"published":1,"tags":["procedural","voxel","textures","wolfenstein"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Reinder Nijhoff 2013\n\/\/\n\n#define NUM_MATERIALS 3\n#define NUM_OBJECTS 1\n#define SECONDS_IN_ROOM 3.\n#define ROOM_SIZE 10.\n#define MAXSTEPS 17\n#define MATERIAL_DOOR 200\n#define MATERIAL_DOORWAY 201\n\n#define COL(r,g,b) vec3(r\/255.,g\/255.,b\/255.)\n\nfloat time = iGlobalTime+40.;\nvec3 rdcenter;\n\n\/\/----------------------------------------------------------------------\n\/\/ Math functions\n\nfloat hash( const float n ) {\n    return fract(sin(n*14.1234512)*51231.545341231);\n}\nfloat hash( const vec2 x ) {\n\tfloat n = dot( x, vec2(14.1432,1131.15532) );\n    return fract(sin(n)*51231.545341231);\n}\nfloat crossp( const vec2 a, const vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\nbool intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\n\tvec2 p = ro.xz;\tvec2 r = rd.xz;\n\tvec2 q = a-p;\tvec2 s = b-a;\n\tfloat rCrossS = crossp(r, s);\n\t\n\tif( rCrossS == 0.){\n\t\treturn false;\n\t}\n\tdist = crossp(q, s) \/ rCrossS;\n\tu = crossp(q, r) \/ rCrossS;\n\t\n\tif(0. <= dist && 0. <= u && u <= 1.){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Material helper functions\n\nfloat onCircle( const vec2 c, const vec2 centre, const float radius ) {\n\treturn clamp( 4.*(radius - distance(c,centre)), 0., 1. );\n}\nfloat onCircleLine( const vec2 c, const vec2 centre, const float radius ) {\n\treturn clamp( 1.-1.5*abs(radius - distance(c,centre)), 0., 1. );\n}\nfloat onLine( const float c, const float b ) {\n\treturn clamp( 1.-abs(b-c), 0., 1. );\n}\nfloat onBand( const float c, const float mi, const float ma ) {\n\treturn clamp( (ma-c+1.), 0., 1. )*clamp( (c-mi+1.), 0., 1. );\n}\nfloat onLineSegmentX( const vec2 c, const float b, const float mi, const float ma ) {\n\treturn onLine( c.x, b )*onBand( c.y, mi, ma );\n}\nfloat onLineSegmentY( const vec2 c, const float b, const float mi, const float ma ) {\n\treturn onLine( c.y, b )*onBand( c.x, mi, ma );\n}\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\n\treturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\n}\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\n\tfloat xl = clamp( (c.x-lt.x)\/size, 0., 1. ); \n\tfloat xr = clamp( (rb.x-c.x)\/size, 0., 1. );\t\n\tfloat yt = clamp( (c.y-lt.y)\/size, 0., 1. ); \n\tfloat yb = clamp( (rb.y-c.y)\/size, 0., 1. );\t\n\n\treturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRect( c, lt, rb ) );\n}\nvec3 addKnob( const vec2 c, const vec2 centre, const float radius, const float strength, const vec3 col ) {\n\tvec2 lv = normalize( centre-c );\n\treturn mix( col, col*(1.0+strength*dot(lv,vec2(-0.7071,0.7071))), onCircle(c, centre, radius ) );\n}\nfloat stepeq( float a, float b ) { \n\treturn step( a, b )*step( b, a );\n}\n\/\/----------------------------------------------------------------------\n\/\/ Generate materials!\n\nvoid getMaterialColor( const int material, in vec2 uv, const float decorationHash, out vec3 col ) {\t\n\tvec3 fgcol;\n\t\n\tuv = floor( mod(uv, vec2(64.)) );\n\tvec2 uvs = uv \/ 64.;\n\t\n\t\/\/ basecolor\n\tvec3 basecol = vec3( mix(55.\/255.,84.\/255.,uvs.y ) );\t\n\tfloat br = hash(uv);\n\tcol = basecol;\n\/\/ grey bricks\n\tif( material == 0 || material == 1 ) {\n\t\tvec2 buv = vec2( mod(uv.x+1. + (floor((uv.y+1.) \/ 16.) * 16.), 32.) , mod( uv.y+1., 16.) );\n\t\tfloat bbr = mix( 190.\/255., 91.\/255., (buv.y)\/14. ) + 0.05*br;\n\t\tif ( buv.x < 2. || buv.y < 2.) {\n\t\t\tbbr = 72.\/255.; \n\t\t}\n\t\tcol = vec3(bbr*0.95);\n\t\tcol = addBevel( buv, vec2(1.,1.), vec2( 31.5, 15.), 2., 0.35, 1., 1., col);\n\t\/\/ blue wall\n\t\tif( material == 1 ) {\n\t\t\tcol *= 1.3*COL(11.,50.,209.);\n\t\t\tcol = mix( col, COL(2.,15.,86.), onBand(uv.y,14.,49.));\n\t\t\tcol = mix( col, COL(9.,44.,185.)*(0.9+0.1*br), onBand(uv.y,16.,47.));\n\t\t\tcol = mix( col, COL(3.,25.,122.), onBand(uv.y,21.,42.));\n\t\t\tcol = addBevel( uv, vec2(-1.,16.), vec2( 65., 21.), 1., 0.35, 1., 1., col);\n\t\t\tcol = addBevel( uv, vec2(-1.,43.), vec2( 65., 48.), 1., 0.35, 1., 1., col);\n\t\t\t\n\t\t\tcol = mix( col, COL(2.,11.,74.), onRect(uv, vec2(22.,22.), vec2(42.,42.)));\t\t\n\t\t\tcol = mix( col, COL(9.,44.,185.)*(0.95+0.1*br), onRect(uv, vec2(22.,23.), vec2(42.,40.)));\n\t\t\tcol = addBevel( uv, vec2(22.,23.), vec2(42.,40.), 1., 0.2, -1., 1., col);\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.x-26.)\/3.), onRect(uv, vec2(26.,23.), vec2(29.,29.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)\/2.), onRect(uv, vec2(22.,34.), vec2(29.,36.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-27.)\/2.), onRect(uv, vec2(35.,27.), vec2(42.,29.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)\/8.), onRect(uv, vec2(35.,34.), vec2(38.,42.)));\n\t\t}\n\t}\n\/\/ wooden wall\n\telse if( material == 2 ) {\n\t\tfloat mx = mod( uv.x, 64.\/5. ); \n\t\tfloat h1 = hash( floor(uv.x\/(64.\/5.)) );\n\t\tfloat h2 = hash( 1.+1431.16*floor(uv.x\/(64.\/5.)) );\n\t\tcol = mix( COL(115.,75.,43.),COL( 71.,56.,26.), smoothstep( 0.2, 1., (0.7+h2)*abs(mod( h2-uv.y*(0.05+0.1*h2)+(1.+h1+h2)*sin(mx*(0.1+0.2*h2)), 2. )-1.) ) );\n\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x)\/2.), step(uv.x,2.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-10.)\/2.), step(10.,uv.x)*step(uv.x,12.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-26.)\/2.), step(26.,uv.x)*step(uv.x,28.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-40.)\/2.), step(40.,uv.x)*step(uv.x,42.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-54.)\/2.), step(54.,uv.x)*step(uv.x,56.) );\n\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x- 8.)), step( 8.,uv.x)*step(uv.x,9.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-24.)), step(24.,uv.x)*step(uv.x,25.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-38.)), step(38.,uv.x)*step(uv.x,39.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-52.)), step(52.,uv.x)*step(uv.x,53.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-62.)), step(62.,uv.x) );\n\t\t\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.y)\/2.), step(uv.y,2.) );\n\t\tcol *= 1.-0.3*stepeq(uv.y,3.);\n\t}\n\/\/ door\n\telse if( material == MATERIAL_DOOR ) {\n\t\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)\/(1.3-0.8*uvs.x)) ) );\n\t\tfgcol = addBevel( uv, vec2(-1.,1.), vec2(62.,66.), 2., 0.4, -1., -1., fgcol);\n\t\tfgcol = addBevel( uv, vec2( 6.,6.), vec2(57.,57.), 2.25, 0.5, -1., -1., fgcol);\t\n\t\tfgcol = mix( addKnob( mod( uv, vec2(8.) ), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uv,  vec2( 6.,6.), vec2(57.,57.)) ) ;\n\t\t\n\t\t\/\/knob\n\t\tfgcol *= 1.-0.2*onRect( uv, vec2( 13.5, 28.5 ), vec2( 22.5, 44.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(44.,44.,44.),COL(152.,152.,152.), ((uv.x+(43.-uv.y)-15.)\/25. ) ), onRect( uv, vec2( 15., 27. ), vec2( 24., 43. ) ) );\n\t\tfgcol = addBevel( uv, vec2( 15., 27. ), vec2( 24., 43. ), 1., 0.45, 1., 1., fgcol);\t\n\t\tfgcol = mix( fgcol, addKnob( mod( uv, vec2(6.) ), vec2(4.25,5.5), 1.15, 0.75, fgcol ), onRect( uv,  vec2( 15., 27. ), vec2( 24., 43. ) ) ) ;\n\n\t\tfgcol *= 1.-0.5*onRect( uv, vec2( 16.5, 33.5 ), vec2( 20.5, 38.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(37.-uv.y)-18.)\/7. ) ), onRect( uv, vec2( 18., 33. ), vec2( 21., 37. ) ) );\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onRect( uv, vec2( 19., 34. ), vec2( 20., 35.7 ) ) );\n\n\t\tfgcol *= 1.-0.2*onRect( uv, vec2( 6.5, 29.5 ), vec2( 10.5, 41.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(40.-uv.y)-9.)\/13. ) ), onRect( uv, vec2( 9., 29. ), vec2( 11., 40. ) ) );\n\t\tfgcol = addBevel( uv, vec2( 9., 29. ), vec2( 11., 40. ), 0.75, 0.5, 1., 1., fgcol);\t\n\t\t\n\t\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\t\n\t}\n\/\/ doorway\n\telse if( material == MATERIAL_DOORWAY ) {\n\t\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)\/(1.3-0.8*uvs.x)) ) );\n\t\tvec2 uvhx = vec2( 32.-abs(uv.x-32.), uv.y );\n\t\tfgcol = addBevel( uvhx, vec2(-1.,1.), vec2(28.,66.), 2., 0.4, -1., -1., fgcol);\n\t\tfgcol = addBevel( uvhx, vec2( 6.,6.), vec2(23.,57.), 2.25, 0.5, -1., -1., fgcol);\t\n\t\tfgcol = mix( addKnob( vec2( mod( uvhx.x, 22. ), mod( uvhx.y, 28. )), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uvhx,  vec2( 6.,6.), vec2(24.,57.)) ) ;\n\t\tfgcol = mix( fgcol, vec3(0.), onRect( uv, vec2( 29., 1.), vec2( 35., 63.) ) );\n\t\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\t\n\t}\n\t\n\/\/ prison door\t\n\tif( decorationHash > 0.93 && material < (NUM_MATERIALS+1) ) {\t\n\t\tvec4 prisoncoords = vec4(12.,14.,52.,62.);\n\t\/\/ shadow\n\t\tcol *= 1.-0.5*onRect( uv,  vec2( 11., 13. ), vec2( 53., 63. ) );\n\t\/\/ hinge\n\t\tcol = mix( col, COL(72.,72.,72.), stepeq(uv.x, 53.)*step( mod(uv.y+2.,25.), 5.)*step(13.,uv.y) );\n\t\tcol = mix( col, COL(100.,100.,100.), stepeq(uv.x, 53.)*step( mod(uv.y+1.,25.), 3.)*step(13.,uv.y) );\n\t\t\n\t\tvec3 pcol = vec3(0.)+COL(100.,100.,100.)*step( mod(uv.x-4., 7.), 0. ); \n\t\tpcol += COL(55.,55.,55.)*step( mod(uv.x-5., 7.), 0. ); \n\t\tpcol = addBevel(uv, vec2(0.,17.), vec2(63.,70.), 3., 0.8, 0., -1., pcol);\n\t\tpcol = addBevel(uv, vec2(0.,45.), vec2(22.,70.), 3., 0.8, 0., -1., pcol);\n\t\t\n\t\tfgcol = COL(72.,72.,72.);\n\t\tfgcol = addBevel(uv, prisoncoords.xy, prisoncoords.zw+vec2(1.,1.), 1., 0.5, -1., 1., fgcol );\n\t\tfgcol = addBevel(uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(2.,1.), 1., 0.5, 1., -1., fgcol );\n\t\tfgcol = mix( fgcol, pcol, onRect( uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(3.,2.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uv, vec2(15.,32.5), vec2(21.,44.) ) );\n\t\t\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.) ), stepeq(uv.x, 15.)*step(37.,uv.y)*step(uv.y,38.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.)\/3. ), stepeq(uv.x, 17.)*step(37.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 18.)*step(37.,uv.y)*step(uv.y,41.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(100.,100.,100.), (uv.y-37.)\/3. ), stepeq(uv.x, 18.)*step(36.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 19.)*step(37.,uv.y)*step(uv.y,40.) );\n\n\t\tfgcol = mix( fgcol, mix( COL(84.,84.,84.), COL(108.,108.,108.), (uv.x-15.)\/2. ), stepeq(uv.y, 32.)*step(15.,uv.x)*step(uv.x,17.) );\n\t\tfgcol = mix( fgcol, COL(81.,81.,81.), stepeq(uv.y, 32.)*step(20.,uv.x)*step(uv.x,21.) );\n\n\t\tcol = mix( col, fgcol, onRect( uv, prisoncoords.xy, prisoncoords.zw ) );\n\t}\n\/\/ flag\n\telse if( decorationHash > 0.63 && material < (NUM_MATERIALS+1) ) {\t\t\n\t\tvec2 uvc = uv-vec2(32.,30.);\n\t\n\t\/\/ shadow\t\n\t\tvec4 shadowcoords = vec4( 14., 7., \n\t\t\t\t\t\t\t\t  54., max( 56. + sin( uv.x*0.32-1. ),56.) ); \n\t\tcol *= 1.-0.3*onRect( uv,  vec2( 6., 6. ), vec2( 61., 7. ) );\n\t\tcol *= 1.-0.3*clamp( 0.25*(56.-uv.x), 0., 1.)*onRect( uv, shadowcoords.xy, shadowcoords.zw );\n\n\t\/\/ rod\n\t\tcol = mix( col, COL(250.,167.,98.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 4., 6.5 ) );\n\t\tcol = mix( col, COL(251.,242.,53.), onLineSegmentY( uv, 5., 4., 60. ) );\n\t\tcol = mix( col, COL(155.,76.,17.), onLineSegmentY( uv, 6., 4., 60. ) );\n\t\tcol = mix( col, COL(202.,96.,25.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 26., 28. ) );\n\t\tcol = mix( col, COL(251.,242.,53.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 3., 7. ) );\n\t\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 4.3, 5.5 ) );\n\t\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 5.3, 5.5 ) );\n\t\tcol = mix( col, COL(0.,0.,0.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 18.3, 19.5 ) );\n\n\t\/\/ flag\t\n\t\tvec4 flagcoords = vec4( 13., min( 9.5 - pow(5.5* (uvs.x-0.5), 2.), 9. ), \n\t\t\t\t\t\t    51., max( 55. + sin( uv.x*0.4+2.7 ),55.) ); \n\t\n\t\tfgcol = COL(249.,41.,27.);\n\t\t\n\t\tfgcol = mix( fgcol, COL(255.,255.,255.), onBand( min(abs(uvc.x), abs(uvc.y)), 2., 4. ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onLine( min(abs(uvc.x), abs(uvc.y)), 3. ) );\t\t\n\t\t\n\t\tfgcol = mix( fgcol, COL(255.,255.,255.), onCircle( uv, vec2(32.,30.), 12.5 ) );\t\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 11. ) );\t\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 9. ) );\n\t\t\n\t\tvec2 uvr = vec2( (uvc.x-uvc.y)*0.7071, (uvc.y+uvc.x)*0.7071)*sign( uvc.x+0.5 );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(1.,4.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-4.2, 4.2), vec2(1.,6.15) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(4.,1.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2( 4.2,-1.), vec2(6.15,4.2) ) );\n\t\n\t\tfgcol *= (0.8+0.2*sin( uv.x*0.4+2.7 ));\n\t\tfgcol *= (0.8+0.2*clamp( 0.5*(uv.y-7.), 0., 1.));\n\t\n\t\/\/ mix flag on background\n\t\tcol = mix( col, fgcol, onRect( uv, flagcoords.xy, flagcoords.zw ) );\n\t}\n\t\n\/\/ fake 8-bit color palette and dithering\t\n\tcol = floor( (col+0.5*mod(uv.x+uv.y,2.)\/32.)*32.)\/32.;\n}\nbool getObjectColor( const int object, in vec2 uv, inout vec3 icol ) {\n\tuv = floor( mod(uv, vec2(64.)) );\n\tvec2 uvs = uv \/ 64.;\n\tvec3 col = vec3(20.\/255.);\n\tfloat d;\n\t\n\/\/ only a lamp for now\n\t\n\t\/\/ lamp top\n\td = distance( uv*vec2(1.,2.), vec2(28.1, 5.8)*vec2(1.,2.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( d\/8.-0.2, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,13.6), 11.7 )*step( uv.y, 6. )); \n\tcol = mix( col, COL(9.,75.,6.), onCircleLine( uv, vec2(31.,14.), 11.6 ) *\n\t\t\t  step( length(uv-vec2(31.,13.6)), 11.7 )*step( uv.y, 6. ) );\n\tcol = mix( col, COL(100.,100.,100.), onLine( abs(uv.x-31.), 1. )*step( uv.y, 1. ) );\n\tcol = mix( col, COL(140.,140.,140.), onLine( abs(uv.x-31.), 0.25 )*step( uv.y, 1. )*step( 1., uv.y ) );\n\t\n\t\/\/ lamp bottom\n\td = distance( uv*vec2(1.,2.), vec2(30.5, 6.5)*vec2(1.,2.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( abs(uv.x-31.)\/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 7.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(16.,123.,17.), clamp( abs(uv.x-31.)\/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 8.) );\n\tcol = mix( col, mix( COL(133.,250.,130.), COL(22.,150.,23.), clamp( abs(uv.x-31.)\/4.-0.75, 0., 1. )), step( abs(uv.x-31.), 7. )*stepeq( uv.y, 9.) );\n\n\tcol = mix( col, mix( COL(255.,251.,187.), col, clamp( d\/4.5-0.6, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,1.), 10.2 )*step( uv.y, 8. )*step( 7., uv.y )); \n\tcol = mix( col, mix( COL(255.,255.,255.), col, clamp( d\/4.-0.7, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,1.), 7.2 )*step( uv.y, 8. )*step( 7., uv.y )); \n\t\t\n\t\/\/ floor\n\td = distance( vec2(mod(uv.x, 32.),uv.y)*vec2(1.5,30.\/3.), vec2(16., 61.5)*vec2(1.5,30.\/3.) );\n\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(d\/15.-0.5, 0., 1.) ), step(d,24.5)); \n\tcol = mix( col, mix( COL(124.,124.,124.), COL(140.,140.,140.), clamp((uv.y-59.)\/1., 0., 1.)), step(59.,uv.y)*step(uv.x, 57.)*step(7.,uv.x)); \n\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(abs(32.-uv.x)\/10.-2., 0., 1.)), step(uv.y, 62.)*step(62.,uv.y)*step(uv.x, 61.)*step(3.,uv.x)); \n\tcol = mix( col, mix( COL(152.,152.,152.), COL(124.,124.,124.), clamp(abs(32.-uv.x)\/10.-2.25, 0., 1.)), step(uv.y, 61.)*step(61.,uv.y)*step(uv.x, 59.)*step(5.,uv.x)); \n\n\tcol = floor( (col)*32.)\/32.;\n\tif( any(notEqual(col, vec3(floor((20.\/255.)*32.)\/32.))) ) {\n\t\ticol = col;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Proocedural MAP functions\n\nbool isWall( const vec2 vos ) {\n\treturn vos.y<0.4*ROOM_SIZE || vos.y>2.75*ROOM_SIZE || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(0.,0.) ) );\n}\nbool isDoor( const vec2 vos ) {\n\treturn isWall(vos) && ((hash(vos)>0.75 &&  any( equal( mod( vos, vec2( ROOM_SIZE*0.5 ) ), vec2(2.) ) )) \n\t\t    || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(ROOM_SIZE*0.5) ) )); \n}\nbool isObject( const vec2 vos ) {\n\treturn hash( vos*10. ) > 0.95;\n}\nbool map( const vec2 vos ) {\n\treturn isObject( vos ) || isWall( vos );\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Render MAP functions\n\nbool intersectSprite( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 nor, out vec2 uv ) {\n\tfloat dist, u;\n\tvec2 a = vos.xz + nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\n\tvec2 b = vos.xz - nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\n\tif( intersectSegment( ro, rd, a, b, dist, u) ) {\n\t\tuv.x = u; uv.y = 1.-(ro+dist*rd).y;\n\t\tif( sign(nor.x)<0. ) uv.x = 1.-uv.x;\n\t\treturn uv.y>0.&&uv.y<1.;\n\t}\n\treturn false;\n}\nint getMaterialId( const vec2 vos ) {\n\treturn int( mod( 521.21 * hash( floor((vos-vec2(0.5))\/ROOM_SIZE )  ), float(NUM_MATERIALS)) );\n}\nbool getColorForPosition( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 pos, const vec3 nor, inout vec3 col ) {\t\n\tvec2 uv;\n\n\tif( isWall( vos.xz ) ) {\n\t\tif( isDoor( vos.xz ) ) {\n\t\t\tif( intersectSprite( ro, rd, vos+nor*0.03, nor, uv ) ) {\n\t\t\t\t\/\/ open the door\n\t\t\t\tuv.x -= clamp( 2.-0.75*distance( ro.xz, vos.xz+vec2(0.5) ), 0., 1.);\n\t\t\t\tif( uv.x > 0. ) {\n\t\t\t\t\tgetMaterialColor( MATERIAL_DOOR, uv*64., 0., col );\n\t\t\t\t\treturn true;\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t\treturn false;\n\t\t}\n\t\t\/\/ a wall is hit\n\t\tif( pos.y <= 1. && pos.y >= 0. ) {\n\t\t\tvec2 mpos = vec2( dot(vec3(-nor.z,0.0,nor.x),pos), -pos.y );\n    \t\tfloat sha = 0.6 + 0.4*abs(nor.z);\t\t\n\t\t\tgetMaterialColor( isDoor( vos.xz+nor.xz )?MATERIAL_DOORWAY:getMaterialId(vos.xz), mpos*64., hash( vos.xz ), col );\n\t\t\tcol *= sha;\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}\n\tif( isObject( vos.xz ) && !isWall( vos.xz+vec2(1.,0.) ) && !isWall( vos.xz+vec2(-1.,0.) )\n\t    && !isWall( vos.xz+vec2(0.,-1.) ) && !isWall( vos.xz+vec2(0.,1.) ) &&\n\t    intersectSprite( ro, rd, vos, rdcenter, uv ) ) {\n\t\treturn getObjectColor( 0, uv*64., col );\n\t}\n\treturn false;\n}\n\nbool castRay( const vec3 ro, const vec3 rd, inout vec3 col ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 0.0;\n\tvec3 mm = vec3(0.0);\n\tbool hit = false;\n\t\n\tfor( int i=0; i<MAXSTEPS; i++ )\t{\n\t\tif( hit ) continue;\n\t\t\n\t\tmm = step(dis.xyz, dis.zyx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t\t\n\t\tif( map(pos.xz) ) { \n\t\t\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\t\t\tfloat t = max ( mini.x, mini.z );\t\t\t\n\t\t\thit = getColorForPosition( ro, rd, pos, ro+rd*t, -mm*sign(rd), col );\n\t\t}\n\t}\n\treturn hit;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Some really ugly code\n\n#define CCOS(a) cos(clamp(a,0.,1.)*1.57079632679)\n#define CSIN(a) sin(clamp(a,0.,1.)*1.57079632679)\nvec3 path( const float t ) {\n\tfloat tmod = mod( t\/SECONDS_IN_ROOM, 8. );\n\tfloat tfloor = floor( tmod );\n\t\n\tvec3 pos = vec3( 4.*ROOM_SIZE*floor(t\/(SECONDS_IN_ROOM*8.))+0.5, 0.5, 0.5*ROOM_SIZE+0.5 );\t\n\treturn pos + ROOM_SIZE*vec3(\n\t\tclamp(tmod,0.,1.)+clamp(tmod-4.,0.,1.)+0.5*(2.+CSIN(tmod-1.)-CCOS(tmod-3.)+CSIN(tmod-5.)-CCOS(tmod-7.)), 0.,\n\t\tclamp(tmod-2.,0.,1.)-clamp(tmod-6.,0.,1.)+0.5*(-CCOS(tmod-1.)+CSIN(tmod-3.)+CCOS(tmod-5.)-CSIN(tmod-7.)) );\n}\n\n\n\/\/----------------------------------------------------------------------\n\/\/ Main\n\nvoid main(void) {\n\tvec2 q = gl_FragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+0.1 );\n\t\n    rdcenter = rotate( normalize( ta - ro), 0.3*cos(time*0.75) );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), rdcenter ));\n    vec3 vv = normalize(cross(rdcenter,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*rdcenter );\n\t\n\tvec3 col = rd.y>0.?vec3(56.\/255.):vec3(112.\/255.);\n\tcastRay( ro, rd, col );\n\t\t\n\tgl_FragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdsGDB","date":"1378762363","viewed":18744,"name":"Buoy","username":"TekF","description":"A ray-traced sphere floating in a ray-marched ocean. Refraction & reflection effects.\nIt looks particularly nice when you pause it and move the camera.","likes":90,"published":1,"tags":["raytracing","raymarching","noise","reflection","refraction"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float tau = 6.28318530717958647692;\n\n\/\/ Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t\/\/ simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t\/\/ convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0\/GAMMA) );\n}\n\nvec3 localRay;\n\n\/\/ Set up a camera looking at the scene.\n\/\/ origin - camera is positioned relative to, and looking at, this point\n\/\/ distance - how far camera is from origin\n\/\/ rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n\/\/ zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom )\n{\n\t\/\/ get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); \/\/ worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t\/\/ ray in view space\n\tray.xy = gl_FragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\tlocalRay = ray;\n\t\n\t\/\/ rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t\/\/ position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\n\/\/ Noise functions, distinguished by variable types\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\/\/\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\n\/\/ hardware interpolation lacks precision\n\/\/\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n\tvec4 rg = mix( mix(\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+0.5)\/256.0, -100.0 ),\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(1,0)+0.5)\/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(0,1)+0.5)\/256.0, -100.0 ),\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+1.5)\/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n\t\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x.xy);\n    vec2 f = fract(x.xy);\n\tf = f*f*(3.0-2.0*f);\n\/\/\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = p.xy + f.xy;\n\treturn texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn texture2D( iChannel0, (vec2(x)+0.5)\/256.0, -100.0 );\n}\n\nvec2 Noise( in ivec3 x )\n{\n\tvec2 uv = vec2(x.xy)+vec2(37.0,17.0)*float(x.z);\n\treturn texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).xz;\n}\n\n\nfloat Waves( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 6;\n\tfloat f = 0.0;\n\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\n\t\/\/ (because I rotate by 45 degrees on each octave)\n\t\tpos += iGlobalTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf \/= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WavesDetail( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 8;\n\tfloat f = 0.0;\n\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\n\t\/\/ (because I rotate by 45 degrees on each octave)\n\t\tpos += iGlobalTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf \/= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WavesSmooth( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 2;\n\tfloat f = 0.0;\n\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\n\t\/\/ (because I rotate by 45 degrees on each octave)\n\t\tpos += iGlobalTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\n\t\t\/\/f  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tf  = f*2.0+sqrt(pow(Noise(pos).x-.5,2.0)+.01)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf \/= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WaveCrests( vec3 ipos )\n{\n\tvec3 pos = ipos;\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves1 = 6;\n\tconst int octaves2 = 16;\n\tfloat f = 0.0;\n\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\n\t\/\/ (because I rotate by 45 degrees on each octave)\n\tpos += iGlobalTime*vec3(0,.1,.1);\n\tvec3 pos2 = pos;\n\tfor ( int i=0; i < octaves1; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\n\t\tf  = f*1.5+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tpos = pos2 * exp2(float(octaves1));\n\tpos.y = -.05*iGlobalTime;\n\tfor ( int i=octaves1; i < octaves2; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\n\t\tf  = f*1.5+pow(abs(Noise(pos).x-.5)*2.0,1.0);\n\t\tpos *= 2.0;\n\t}\n\tf \/= 1500.0;\n\t\n\tf -= Noise(ivec2(gl_FragCoord.xy)).x*.01;\n\t\n\treturn pow(smoothstep(.4,-.1,f),6.0);\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn vec3(.4,.45,.5);\n}\n\n\nvec3 boatRight, boatUp, boatForward;\nvec3 boatPosition;\n\nvoid ComputeBoatTransform( void )\n{\n\tvec3 samples[5];\n\t\n\tsamples[0] = vec3(0,0, 0);\n\tsamples[1] = vec3(0,0, .5);\n\tsamples[2] = vec3(0,0,-.5);\n\tsamples[3] = vec3( .5,0,0);\n\tsamples[4] = vec3(-.5,0,0);\n\t\n\tsamples[0].y = WavesSmooth(samples[0]);\n\tsamples[1].y = WavesSmooth(samples[1]);\n\tsamples[2].y = WavesSmooth(samples[2]);\n\tsamples[3].y = WavesSmooth(samples[3]);\n\tsamples[4].y = WavesSmooth(samples[4]);\n\n\tboatPosition = (samples[0]+samples[1]+samples[2]+samples[3]+samples[4])\/5.0;\n\t\n\tboatRight = samples[3]-samples[4];\n\tboatForward = samples[1]-samples[2];\n\tboatUp = normalize(cross(boatForward,boatRight));\n\tboatRight = normalize(cross(boatUp,boatForward));\n\tboatForward = normalize(boatForward);\n\t\n\tboatPosition += .0*boatUp;\n}\n\nvec3 BoatToWorld( vec3 dir )\n{\n\treturn dir.x*boatRight+dir.x*boatUp+dir.x*boatForward;\n}\n\nvec3 WorldToBoat( vec3 dir )\n{\n\treturn vec3( dot(dir,boatRight), dot(dir,boatUp), dot(dir,boatForward) );\n}\n\nfloat TraceBoat( vec3 pos, vec3 ray )\n{\n\tvec3 c = boatPosition;\n\tfloat r = 1.0;\n\t\n\tc -= pos;\n\t\n\tfloat t = dot(c,ray);\n\t\n\tfloat p = length(c-t*ray);\n\tif ( p > r )\n\t\treturn 0.0;\n\t\n\treturn t-sqrt(r*r-p*p);\n}\n\n\nvec3 ShadeBoat( vec3 pos, vec3 ray )\n{\n\tpos -= boatPosition;\n\tvec3 norm = normalize(pos);\n\tpos = WorldToBoat(pos);\n\t\n\tvec3 lightDir = normalize(vec3(-2,3,1));\n\tfloat ndotl = dot(norm,lightDir);\n\t\n\t\/\/ allow some light bleed, as if it's subsurface scattering through plastic\n\tvec3 light = smoothstep(-.1,1.0,ndotl)*vec3(1.0,.9,.8)+vec3(.06,.1,.1);\n\n\t\/\/ anti-alias the albedo\n\tfloat aa = 4.0\/iResolution.x;\n\t\n\t\/\/vec3 albedo = ((fract(pos.x)-.5)*(fract(pos.y)-.5)*(fract(pos.z)-.5) < 0.0) ? vec3(0) : vec3(1);\n\tvec3 albedo = vec3(1,.01,0);\n\talbedo = mix( vec3(.04), albedo, smoothstep( .25-aa, .25, abs(pos.y) ) );\n\talbedo = mix( mix( vec3(1), vec3(.04), smoothstep(-aa*4.0,aa*4.0,cos(atan(pos.x,pos.z)*6.0)) ), albedo, smoothstep( .2-aa*1.5, .2, abs(pos.y) ) );\n\talbedo = mix( vec3(.04), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.6) ) );\n\talbedo = mix( vec3(1,.8,.08), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.65) ) );\n\t\n\tvec3 col = albedo*light;\n\t\n\t\/\/ specular\n\tvec3 h = normalize(lightDir-ray);\n\tfloat s = pow(max(0.0,dot(norm,h)),100.0)*100.0\/32.0;\n\t\n\tvec3 specular = s*vec3(1,1,1);\n\n\tvec3 rr = reflect(ray,norm);\n\tspecular += mix( vec3(0,.04,.04), Sky(rr), smoothstep( -.1, .1, rr.y ) );\n\t\n\tfloat ndotr = dot(norm,ray);\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\n\tfresnel = mix( .001, 1.0, fresnel );\n\n\tcol = mix( col, specular, fresnel );\n\t\n\treturn col;\n}\n\n\nfloat OceanDistanceField( vec3 pos )\n{\n\treturn pos.y - Waves(pos);\n}\n\nfloat OceanDistanceFieldDetail( vec3 pos )\n{\n\treturn pos.y - WavesDetail(pos);\n}\n\nvec3 OceanNormal( vec3 pos )\n{\n\tvec3 norm;\n\tvec2 d = vec2(.01*length(pos),0);\n\t\n\tnorm.x = OceanDistanceFieldDetail( pos+d.xyy )-OceanDistanceFieldDetail( pos-d.xyy );\n\tnorm.y = OceanDistanceFieldDetail( pos+d.yxy )-OceanDistanceFieldDetail( pos-d.yxy );\n\tnorm.z = OceanDistanceFieldDetail( pos+d.yyx )-OceanDistanceFieldDetail( pos-d.yyx );\n\n\treturn normalize(norm);\n}\n\nfloat TraceOcean( vec3 pos, vec3 ray )\n{\n\tfloat h = 1.0;\n\tfloat t = 0.0;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tif ( h < .01 || t > 100.0 )\n\t\t\tbreak;\n\t\th = OceanDistanceField( pos+t*ray );\n\t\tt += h;\n\t}\n\t\n\tif ( h > .1 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\n\nvec3 ShadeOcean( vec3 pos, vec3 ray )\n{\n\tvec3 norm = OceanNormal(pos);\n\tfloat ndotr = dot(ray,norm);\n\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\n\t\n\tvec3 reflectedRay = ray-2.0*norm*ndotr;\n\tvec3 refractedRay = ray+(-cos(1.33*acos(-ndotr))-ndotr)*norm;\t\n\trefractedRay = normalize(refractedRay);\n\n\tconst float crackFudge = .0;\n\t\n\t\/\/ reflection\n\tvec3 reflection = Sky(reflectedRay);\n\tfloat t=TraceBoat( pos-crackFudge*reflectedRay, reflectedRay );\n\t\n\tif ( t > 0.0 )\n\t{\n\t\treflection = ShadeBoat( pos+(t-crackFudge)*reflectedRay, reflectedRay );\n\t}\n\n\t\n\t\/\/ refraction\n\tt=TraceBoat( pos-crackFudge*refractedRay, refractedRay );\n\t\n\tvec3 col = vec3(0,.04,.04); \/\/ under-sea colour\n\tif ( t > 0.0 )\n\t{\n\t\tcol = mix( col, ShadeBoat( pos+(t-crackFudge)*refractedRay, refractedRay ), exp(-t) );\n\t}\n\t\n\tcol = mix( col, reflection, fresnel );\n\t\n\t\/\/ foam\n\tcol = mix( col, vec3(1), WaveCrests(pos) );\n\t\n\treturn col;\n}\n\n\nvoid main(void)\n{\n\tComputeBoatTransform();\n\t\n\tvec2 camRot = vec2(.5,.5)+vec2(-.35,4.5)*(iMouse.yx\/iResolution.yx);\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, vec3(0), camRot, 3.0, 1.0 );\n\t\n\tfloat to = TraceOcean( pos, ray );\n\tfloat tb = TraceBoat( pos, ray );\n\t\n\tvec3 result;\n\tif ( to > 0.0 && ( to < tb || tb == 0.0 ) )\n\t\tresult = ShadeOcean( pos+ray*to, ray );\n\telse if ( tb > 0.0 )\n\t\tresult = ShadeBoat( pos+ray*tb, ray );\n\telse\n\t\tresult = Sky( ray );\n\t\n\t\/\/ vignette effect\n\tresult *= 1.1*smoothstep( .35, 1.0, localRay.z );\n\t\n\tgl_FragColor = vec4(ToGamma(result),1.0);\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsSXzD","date":"1410462817","viewed":18559,"name":"E1M1 - Hangar","username":"P_Malin","description":"The start area of Doom E1M1.\nHold down the mouse button and drag the mouse to move.\nWhere you click relative to the center of the screen sets the view direction.\n\nAlso, check out Reinder's excellent Doom2 shader: https:\/\/www.shadertoy.com\/view\/lsB3zD","likes":25,"published":1,"tags":["doom","e1m1","hangar"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ E1M1 - Hangar\n\/\/ by @P_Malin\n\n\/\/ Procedural version of Doom E1M1\n\n\/\/ The start area of Doom E1M1.\n\/\/ Click and drag the mouse to move.\n\/\/ Where you click relative to the center of the screen sets the view direction.\n\n\/\/ Also, check out Reinder's excellent Doom2 shader: https:\/\/www.shadertoy.com\/view\/lsB3zD\n\n\/\/ The sectors we draw by default\n#define ENABLE_NUKAGE_SECTORS\n#define ENABLE_START_SECTORS\n\n\/\/ Adding this compiles with \"Unknown Error\" on some machines. Uncomment if you are feeling lucky.\n\/\/#define ENABLE_SECTOR_31\n\n\/\/ Some additional sectors, may need to comment out some of the default ones\n\/\/#define ENABLE_EXTRA_NUKAGE_SECTORS\n\/\/#define ENABLE_MISC_SECTORS\n\n#define ENABLE_SPRITES\n\n#define DEMO_CAMERA\n#define INTRO_EFFECT\n#define DRAW_SKY\n#define HEAD_BOB\n\n#define PIXELATE_IMAGE\n#define QUANTIZE_FINAL_IMAGE\n#define QUANTIZE_TEXTURES\n#define PIXELATE_TEXTURES\n\n\/\/#define DRAW_COMPASS\n\n\/\/ Add walls to close entrances to sectors we are not rendering\n#ifndef ENABLE_EXTRA_NUKAGE_SECTORS\n\t#define CLOSE_NUKAGE_SECTOR\n#endif\n#ifndef ENABLE_SECTOR_31\n\t#define CLOSE_START_SECTOR\n#endif\n\n#define FAR_CLIP 10000.0\n\nconst vec2 vFakeResolution = vec2(320.0, 240.0);\n\nconst float kDepthFadeScale = (1.0 \/ 3500.0);\nconst float kExtraLight = 0.0;\n\n\/\/ Light level adjustment to East-West and North-South walls\nconst float kC = (1.0 \/ 16.0);\n\nvec3 SampleTexture( const in float fTexture, const in vec2 vUV );\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo );\nfloat hash(float p);\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    const float kFOV = 1.8;\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * kFOV);\n\n\treturn vDir;\n}\n\nvec3 Quantize( const in vec3 col )\n{\n\treturn floor( col * 48.0 + 0.5 ) * (1.0 \/ 48.0);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    \/\/return cross( vec3(vA, 0.0), vec3(vB, 0.0) ).z;\n  \treturn vA.x * vB.y - vA.y * vB.x;\n\n    \/\/return dot(vA * vB.yx, vec2(1.0, -1.0)); \n}\n\nvec3 g_vRayOrigin;\nvec3 g_vRayDir;\nvec2 g_vSpriteDir;\n\nvoid BeginSector( out vec4 vSectorState, const in vec2 vSectorHeights )\n{\n    \/\/ store the infinite floor-ceiling plane intersect depth in vSectorState.xy\n    vSectorState.xy = (vSectorHeights - g_vRayOrigin.y) \/ g_vRayDir.y;   \n    vSectorState.zw = vec2(0.0);\n}\n\n\/\/ Intersect a sidedef that meets another sector with the same floor and ceiling height\nvoid Null( inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n   \tif((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n    \tvSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n    }\n}\n\nvoid Wall( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in float fTexture )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n\n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {        \n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * fLen, fHitY, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nvoid Open( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in int iUpperHeight, const in float fLowerTexture, const in float fUpperTexture )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    float fLowerHeight = float(iLowerHeight);\n\t\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\nvoid Upper( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iUpperHeight, const in float fUpperTexture )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( fHitY < vSectorHeights.y )\n            {           \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\n\nvoid Lower( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in float fLowerTexture )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fLowerHeight = float(iLowerHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( fHitY > vSectorHeights.x )\n            {           \n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n            }\n        }\n    }\n}\n\nvoid EndSector( inout float fClosestT, inout vec4 vHitInfo, in vec4 vSectorState, const in float fLightLevel, const in vec2 vFloorCeilingTextures )\n{\n    \/\/ Test the even-odd state of our sector floor\/ceiling in-out values\n    vec2 vInOutTest = fract( vSectorState.zw * 0.5 ) * 2.0;\n\n    if( fClosestT > vSectorState.x )\n    {\n        if((vInOutTest.x > 0.5) && (vSectorState.x > 0.0))\n        {\n            vec3 vFloorPos = g_vRayOrigin + g_vRayDir * vSectorState.x;        \n            if( g_vRayOrigin.y > vFloorPos.y )\n            {\n                fClosestT = vSectorState.x;\n                vHitInfo = vec4( vFloorPos.xz, fLightLevel, vFloorCeilingTextures.x);\n            }\n        }\n    }\n\n    if( fClosestT > vSectorState.y )\n    {\n        if((vInOutTest.y > 0.5) && (vSectorState.y > 0.0))\n        {\n            vec3 vCeilingPos = g_vRayOrigin + g_vRayDir * vSectorState.y;        \n            if( g_vRayOrigin.y < vCeilingPos.y )\n            {\n                fClosestT = vSectorState.y;\n                vHitInfo = vec4( vCeilingPos.xz, fLightLevel, vFloorCeilingTextures.y);\n            }\n        }            \n    }\n}\n\n#ifdef ENABLE_SPRITES\n\nvoid Sprite( out float fClosestT, out vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, vec2 vSize, float fLightLevel, float fTexture )\n{\n\tvec3 vPos = vec3(iX, iY, iZ);\n\tfClosestT = FAR_CLIP;\n\tvHitInfo = vec4(0.0);\n\tvec2 vA = vPos.xz - vSpriteDir * 0.5 * vSize.x;\n\tvec2 vB = vPos.xz + vSpriteDir * 0.5 * vSize.x;\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n    float rcpdenom = 1.0 \/ Cross2d( g_vRayDir.xz, vD ); \n    float fHitT = Cross2d( vOA, vD ) * rcpdenom;\n\n    if(fHitT > 0.0)\n    {\n\t    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * rcpdenom;\n        if((fHitU >= 0.0) && (fHitU < 1.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( (fHitT < fClosestT) && (fHitY > vPos.y) && (fHitY < (vPos.y + vSize.y)) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * vSize.x, fHitY - vPos.y, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nbool MaskBarrel(vec2 vTexCoord)\n{\n\tvec2 vSize = vec2(23.0, 32.0);\n\t\n\tvTexCoord = floor(vTexCoord);\n\t\n\t\/\/ remove corner pixels\n\tvec2 vWrapCoord = fract((vTexCoord + vec2(2.0, 1.0) ) \/ vSize) * vSize;\n\t\n\treturn ( (vWrapCoord.x >= 4.0) || (vWrapCoord.y >= 2.0) );\n}\n\n\nvec4 CosApprox( vec4 x )\n{\n\tx = abs(fract(x * (0.5))*2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn( ( x2 * 3.0) - ( 2.0 * x2*x) );\n}\n\nbool MaskCorpseSprite(vec2 vTexCoord)\n{\n\t\/\/vTexCoord = floor(vTexCoord);\n    \n    vec2 vUV = vTexCoord.xy \/ vec2(57.0, 22.0);\n    vec2 vOffset = vUV;\n    vOffset = vOffset * 2.0 -vec2(1.0, 0.8);\n    float fDist = dot(vOffset, vOffset);\n    fDist += dot(CosApprox(vTexCoord.xyxy * vec4(0.55, 0.41, 0.25, 0.1)), vec4(0.2 * -vOffset.y));\n\treturn fDist < 0.4;\n}\n\n#define TEX_BAR1A 32.0\n#define TEX_PLAYW 33.0\n\nvoid BarrelSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(23.0, 32.0), fLightLevel, TEX_BAR1A);\n\t\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskBarrel(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n\nvoid CorpseSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(57.0, 22.0), fLightLevel, TEX_PLAYW );\n\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskCorpseSprite(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n#endif\n\nvoid main(void)\n{\n\tvec2 vOrigUV = gl_FragCoord.xy \/ iResolution.xy;\n    \n    #ifdef PIXELATE_IMAGE\n    vec2 vUV = floor(vOrigUV * vFakeResolution + 0.5) * (1.0 \/ vFakeResolution);\n    #else\n    vec2 vUV = vOrigUV;\n    #endif\n    \n\tvec3 vCameraPos = vec3(0.0);\n\tvec3 vCameraTarget = vec3(0.0);\n        \n    vec2 vMouse = (iMouse.xy \/ iResolution.xy);\n\t\n\tconst vec2 vStart = vec2(1050, -3616);\n\n\tif(iMouse.z > 0.0)\n    {\n        vec2 vDir = normalize((abs(iMouse.zw) \/ iResolution.xy) - 0.5);\n        vec2 vOffset = (iMouse.xy - abs(iMouse.zw)) \/ iResolution.xy;\n\t\tvCameraPos.y = 30.0;\n    \tvCameraPos.xz = (vDir.yx * vec2(1.0, -1.0) * vOffset.x + vDir * vOffset.y) * 5000.0;\n        vCameraPos.xz += vStart;\n        vCameraTarget.xz = vCameraPos.xz + vDir * 10.0;\n\t    vCameraTarget.y = vCameraPos.y;\n    }\n    else\n    {\n        vCameraPos = vec3(1050, 30, -3616);\n        vCameraTarget = vec3(1050, 30, -3500);\n\n        #ifdef DEMO_CAMERA\n        float fCamTime = iGlobalTime - 5.0;\n        if(fCamTime > 0.0) fCamTime = mod(fCamTime, 33.0 - 5.0) + 5.0;\n        if(iGlobalTime==10.0) fCamTime = 0.0; \/\/ hack for shadertoy preview screen\n        vCameraTarget = mix( vCameraTarget, vec3(1834, 30, -3264), smoothstep(5.0, 10.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(1280, 30, -3350), smoothstep(8.0, 13.0, fCamTime));\n        \n        vCameraTarget = mix( vCameraTarget, vec3(1280, 30, -2976), smoothstep(11.0, 16.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(1280, 30, -2976), smoothstep(13.0, 19.0, fCamTime));\n        \n        vCameraTarget = mix( vCameraTarget, vec3(768, 30, -3050), smoothstep(16.0, 20.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(832, 30, -3020), smoothstep(19.0, 23.0, fCamTime));\n\n        vCameraTarget = mix( vCameraTarget, vec3(1256, 30, -3648), smoothstep(20.0, 25.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(768, 30, -3424), smoothstep(23.0, 28.0, fCamTime));\n        \n        vCameraPos = mix( vCameraPos, vec3(1050, 30, -3616), smoothstep(25.0, 30.0, fCamTime));\n        vCameraTarget = mix( vCameraTarget, vec3(1050, 30, -3500), smoothstep(28.0, 33.0, fCamTime));\n        #endif\n    }\n    \n    #ifdef HEAD_BOB\n\tfloat fBob = sin(length(vCameraPos.xz - vStart) * 0.04) * 4.0; \/\/ head bob\n    vCameraPos.y += fBob;\n    vCameraTarget.y += fBob;\n    #endif\n\n    vec2 vWindowCoord =\t(vUV * 2.0 - 1.0) * vec2(iResolution.x \/ iResolution.y, 1.0);\n\t\n    g_vRayOrigin = vCameraPos;\n    g_vRayDir = GetCameraRayDir( vWindowCoord, vCameraPos, vCameraTarget );\n    \n    vec4 vHitInfo;\n    float fClosestT;\n\tfloat fNoFog = 0.0;\n\n\t\n    MapIntersect( fClosestT, vHitInfo );\n\n\tvec3 vForwards = normalize(vCameraTarget - vCameraPos); \n\n    #ifdef ENABLE_SPRITES\n\tvec2 vSpriteDir = -normalize(vec2(-vForwards.z, vForwards.x));\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1088, 0, -2944, 0.565);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 864, 0, -3328, 0.565);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1312, -16, -3264, 0.878);\n    CorpseSprite(fClosestT, vHitInfo, vSpriteDir, 1024, -16, -3264, 0.878);\n    #endif\t\n\t\n\tvHitInfo.z = clamp(vHitInfo.z + kExtraLight, 0.0, 1.0);\n\n    \/\/ sky\n    #ifdef DRAW_SKY\n    float fDoSky = step(0.9, vHitInfo.w) * step(vHitInfo.w, 1.1);\n    \n    fNoFog = max(fNoFog, fDoSky);\n    float fSkyU = (atan(vForwards.x, vForwards.z) * 512.0 \/ radians(180.0)) + vUV.x * 320.0;\n    float fSkyV = vUV.y * 240.0;\n    vHitInfo = mix(vHitInfo, vec4(fSkyU, fSkyV, 1.0, 1.0), fDoSky);\n    #endif\n    \n    \/\/ fade in effect\n\t#ifdef INTRO_EFFECT\n    float fEffectOffset = max(iGlobalTime - 1.0, 0.0) - hash(vUV.x);\n    vec2 vEffectUV = vUV;\n    vEffectUV.y += clamp(fEffectOffset, 0.0, 1.0);\n    \n    float fDoEffect = step(vEffectUV.y, 1.0);       \n    vHitInfo = mix(vHitInfo, vec4(vEffectUV * 128.0, 1.0, 3.0), fDoEffect);\n    fNoFog = max(fNoFog, fDoEffect);\n    #endif    \n\n    float fLightLevel = clamp( vHitInfo.z, 0.0, 1.0 );\n    float fDepth = dot(g_vRayDir, vForwards) * fClosestT;\n    float fDepthFade = fDepth * kDepthFadeScale;\n    float fApplyFog = 1.0 - fNoFog;\n    fLightLevel = clamp( fLightLevel - fDepthFade * fApplyFog, 0.0, 1.0 );\n    \n    vec3 vResult = SampleTexture( vHitInfo.w, vHitInfo.xy ) * fLightLevel;\n    \n    vResult = clamp(vResult * 1.2, 0.0, 1.0);\n    \n    #ifdef QUANTIZE_FINAL_IMAGE\n    vResult = Quantize(vResult);\n    #endif\n    \n    #ifdef DRAW_COMPASS\n    \/\/ a hack - assume we have never clicked the mouse before if coordinate is zero\n    if((iMouse.x > 0.5) && (iMouse.y > 0.5))\n    {\n        if(iMouse.z <= 0.0)\n        {\n            vec2 vCompassUV = vOrigUV - 0.5;\n            vCompassUV.x *= iResolution.x \/ iResolution.y;\n            float fDistNS = ((abs(vCompassUV.x) * 10.0) + abs(vCompassUV.y) - 0.05);\n            float fDistEW = ((abs(vCompassUV.y) * 10.0) + abs(vCompassUV.x) - 0.025);\n            float fDistCircle = abs(0.045 - length(vCompassUV)) * 10.0;\n            float fDist = min(min(fDistNS, fDistEW), fDistCircle);\n            \n            float fAmount = clamp(fDist * 20.0, 0.0, 1.0);\n            float fCol = step(fract((floor(vCompassUV.x) + floor(vCompassUV.y)) * 0.5), 0.25);\n            vResult = mix(vec3(fCol * 0.75 + 0.25), vResult, fAmount);\n        }\n    }\n    #endif\n    \n\tgl_FragColor = vec4(vResult, 1.0);\n}\n\n\/\/ Generated code follows\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\/\/ Textures\n#define TEX_X 0.0\n#define TEX_F_SKY1 1.0\n#define TEX_NUKAGE3 2.0\n#define TEX_FLOOR7_1 3.0\n#define TEX_FLAT5_5 4.0\n#define TEX_FLOOR4_8 5.0\n#define TEX_CEIL3_5 6.0\n#define TEX_TLITE6_4 7.0\n#define TEX_FLAT14 8.0\n#define TEX_FLOOR7_2 9.0\n#define TEX_STEP2 10.0\n#define TEX_TLITE6_1 11.0\n#define TEX_DOOR3 12.0\n#define TEX_LITE3 13.0\n#define TEX_STARTAN3 14.0\n#define TEX_BROWN1 15.0\n#define TEX_DOORSTOP 16.0\n#define TEX_COMPUTE2 17.0\n#define TEX_STEP6 18.0\n#define TEX_BROWN144 19.0\n#define TEX_SUPPORT2 20.0\n#define TEX_STARG3 21.0\n#define TEX_DOORTRAK 22.0\n#define TEX_SLADWALL 23.0\n#define TEX_TEKWALL4 24.0\n#define TEX_SW1COMP 25.0\n#define TEX_BIGDOOR2 26.0\n\n\/\/ Sectors\n\nvoid Sector0( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-80.0, 216.0);\n\n    BeginSector( vSS, vSH );\n    Lower( fT, vInf, vSS, 1520, -3168, 1672, -3104, 164, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1672, -3104, 1896, -3104, 224, fLt-kC, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1896, -3104, 2040, -3144, 149, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 2040, -3144, 2128, -3272, 155, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 2128, -3272, 2064, -3408, 150, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 2064, -3408, 1784, -3448, 282, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1784, -3448, 1544, -3384, 248, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1544, -3384, 1520, -3168, 217, fLt, vSH, -56, TEX_BROWN144 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_NUKAGE3, TEX_F_SKY1) );\n}\n\nvoid Sector1( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 216.0);\n\t\/\/ merge walls from ultimate doom secret\n\n    BeginSector( vSS, vSH );\n    Open( fT, vInf, vSS, 1376, -3200, 1376, -3104, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1376, -3360, 1376, -3264, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Wall( fT, vInf, vSS, 1376, -3264, 1376, -3200, 64, fLt+kC, vSH, TEX_STARTAN3);\n\tWall( fT, vInf, vSS, 1376, -3104, 1376, -2944, 160, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1376, -2944, 1472, -2880, 115, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1856, -2880, 1920, -2920, 75, fLt, vSH, TEX_STARTAN3);\n    Null( vSS, 1520, -3168, 1672, -3104 );\n    Null( vSS, 1672, -3104, 1896, -3104 );\n    Null( vSS, 1896, -3104, 2040, -3144 );\n    Null( vSS, 2040, -3144, 2128, -3272 );\n    Null( vSS, 2128, -3272, 2064, -3408 );\n    Null( vSS, 2064, -3408, 1784, -3448 );\n    Null( vSS, 1784, -3448, 1544, -3384 );\n    Null( vSS, 1544, -3384, 1520, -3168 );\n    Wall( fT, vInf, vSS, 2736, -3360, 2736, -3648, 288, fLt+kC, vSH, TEX_STARTAN3);\n#ifdef CLOSE_NUKAGE_SECTOR\n    Wall( fT, vInf, vSS, 2736, -3648, 1376, -3648, 2736-1376, fLt, vSH, TEX_STARTAN3  );\n#else\n\tNull( vSS, 2736, -3648, 2240, -3648 );\n    Null( vSS, 2240, -3648, 1984, -3648 );\n    Null( vSS, 1984, -3648, 1376, -3648 );\n#endif \n    Wall( fT, vInf, vSS, 2240, -2920, 2272, -3008, 93, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 2272, -3008, 2432, -3112, 190, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 2432, -3112, 2736, -3112, 304, fLt-kC, vSH, TEX_STARTAN3);\n    Open( fT, vInf, vSS, 2736, -3112, 2736, -3360, 248, fLt+kC, vSH, 0, 136, TEX_STARTAN3, TEX_STARTAN3 );\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1376, -3648, 1376, -3360, 3648-3360, fLt+kC, vSH, TEX_STARTAN3);\n\t\/\/Wall( fT, vInf, vSS, 1376, -3648, 1376, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1376, -3392, 1376, -3360, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1376, -3520, 1376, -3392, 128, fLt+kC, vSH, TEX_STARTAN3);\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1472, -2880, 1856, -2880, 1856-1472, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1472, -2880, 1664, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1664, -2880, 1856, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n\t\n\t\/\/ Merge walls\n    Wall( fT, vInf, vSS, 1920, -2920, 2240, -2920, 2240-1920, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1920, -2920, 2176, -2920, 256, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 2176, -2920, 2240, -2920, 64, fLt-kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid Sector3( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 1344, -3264, 1344, -3360 );\n    Null( vSS, 1376, -3360, 1376, -3264 );\n    Wall( fT, vInf, vSS, 1344, -3264, 1376, -3264, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    Wall( fT, vInf, vSS, 1376, -3360, 1344, -3360, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5) );\n}\n\nvoid Sector5( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 1344, -3104, 1344, -3200 );\n    Null( vSS, 1376, -3200, 1376, -3104 );\n    Wall( fT, vInf, vSS, 1376, -3200, 1344, -3200, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    Wall( fT, vInf, vSS, 1344, -3104, 1376, -3104, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5) );\n}\n\nvoid Sector11( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1528, -3680, 1376, -3648, 155, fLt, vSH, TEX_BROWN144);\n    Wall( fT, vInf, vSS, 1672, -3744, 1528, -3680, 157, fLt, vSH, TEX_BROWN144);\n    Wall( fT, vInf, vSS, 1984, -3776, 1672, -3744, 313, fLt, vSH, TEX_BROWN144);\n    Null( vSS, 1984, -3648, 1376, -3648 );\n    Null( vSS, 1984, -3648, 1984, -3776 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid Sector12( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 64.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 2240, -3776, 2208, -3680, 101, fLt, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 2208, -3680, 2176, -3680, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 2016, -3680, 1984, -3776, 101, fLt, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 2048, -3680, 2016, -3680, 32, fLt-kC, vSH, TEX_BROWN1);\n    Upper( fT, vInf, vSS, 2176, -3680, 2048, -3680, 128, fLt-kC, vSH, 16, TEX_BROWN1 );\n    Null( vSS, 2240, -3648, 1984, -3648 );\n    Null( vSS, 1984, -3648, 1984, -3776 );\n    Null( vSS, 2240, -3776, 2240, -3648 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid Sector24( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 144.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1216, -2880, 1248, -2528, 353, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1384, -2592, 1344, -2880, 290, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1472, -2560, 1384, -2592, 93, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1248, -2528, 1472, -2432, 243, fLt, vSH, TEX_STARTAN3);\n    Upper( fT, vInf, vSS, 1344, -2880, 1216, -2880, 128, fLt-kC, vSH, 72, TEX_STARTAN3 );\n    Upper( fT, vInf, vSS, 1472, -2432, 1472, -2560, 128, fLt+kC, vSH, 88, TEX_STARTAN3 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector25( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(0.0, 88.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 1472, -2432, 1472, -2560 );\n    Wall( fT, vInf, vSS, 1536, -2432, 1536, -2560, 128, fLt+kC, vSH, TEX_BIGDOOR2);\n    Wall( fT, vInf, vSS, 1536, -2560, 1472, -2560, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1472, -2432, 1536, -2432, 64, fLt-kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_TLITE6_4) );\n}\n\nvoid Sector27( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.878;\n    const vec2 vSH=vec2(-16.0, 200.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1216, -3392, 1216, -3360, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1216, -3360, 1184, -3360, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3104, 1216, -3104, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1216, -3104, 1216, -3072, 32, fLt+kC, vSH, TEX_BROWN1);\n    Open( fT, vInf, vSS, 1344, -3264, 1344, -3360, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Wall( fT, vInf, vSS, 1344, -3200, 1344, -3264, 64, fLt+kC, vSH, TEX_STARTAN3);\n    Open( fT, vInf, vSS, 1344, -3104, 1344, -3200, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1344, -3360, 1216, -3392, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1216, -3072, 1344, -3104, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 928, -3104, 1184, -3104, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1184, -3360, 928, -3360, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 928, -3360, 928, -3104, 256, fLt+kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) );\n}\n\nvoid Sector28( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.753;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 928, -3392, 928, -3360, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 928, -3360, 896, -3360, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3360, 1184, -3392, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 896, -3104, 928, -3104, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 928, -3104, 928, -3072, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3072, 1184, -3104, 32, fLt+kC, vSH, TEX_BROWN1);\n    Open( fT, vInf, vSS, 1184, -3392, 928, -3392, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 );\n    Null( vSS, 928, -3104, 1184, -3104 );\n    Null( vSS, 1184, -3360, 928, -3360 );\n    Null( vSS, 928, -3360, 928, -3104 );\n    Open( fT, vInf, vSS, 896, -3360, 896, -3104, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 );\n    Open( fT, vInf, vSS, 928, -3072, 1184, -3072, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) );\n}\n\nvoid Sector29( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1152, -3648, 1088, -3648, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1024, -3648, 960, -3648, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1280, -3552, 1152, -3648, 160, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 960, -3648, 832, -3552, 160, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1344, -3552, 1280, -3552, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 832, -3552, 704, -3552, 128, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 896, -3392, 928, -3392, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 896, -3360, 896, -3392, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3392, 1216, -3392, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 896, -3072, 896, -3104, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 928, -3072, 896, -3072, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1216, -3072, 1184, -3072, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1344, -2880, 1344, -3104, 224, fLt+kC, vSH, TEX_STARTAN3);\n    Null( vSS, 1184, -3392, 928, -3392 );\n    Null( vSS, 1344, -3360, 1216, -3392 );\n    Null( vSS, 1216, -3072, 1344, -3104 );\n    Wall( fT, vInf, vSS, 704, -2944, 832, -2944, 128, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 832, -2944, 968, -2880, 150, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 968, -2880, 1216, -2880, 248, fLt-kC, vSH, TEX_STARTAN3);\n    Null( vSS, 1088, -3648, 1024, -3648 );\n    Null( vSS, 896, -3360, 896, -3104 );\n    Null( vSS, 928, -3072, 1184, -3072 );\n#ifdef CLOSE_START_SECTOR\t\n    Wall( fT, vInf, vSS, 704, -3552, 704, -2944, 3552-2944, fLt+kC, vSH, TEX_STARTAN3);\n#else\n    Wall( fT, vInf, vSS, 704, -3552, 704, -3360, 192, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 704, -3104, 704, -2944, 160, fLt+kC, vSH, TEX_STARTAN3);\n    Null( vSS, 704, -3104, 704, -3360 );\n#endif\n    Null( vSS, 1344, -2880, 1216, -2880 );\n    Wall( fT, vInf, vSS, 1344, -3360, 1344, -3392, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1344, -3392, 1344, -3552, 3552 - 3392, fLt+kC, vSH, TEX_STARTAN3);\n\t\/\/Wall( fT, vInf, vSS, 1344, -3520, 1344, -3552, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1344, -3392, 1344, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector30( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    float fLt=(hash(floor(iGlobalTime * 10.0)) > 0.3) ? 0.565 : 1.0;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1088, -3680, 1024, -3680, 64, fLt-kC, vSH, TEX_DOOR3);\n    Wall( fT, vInf, vSS, 1024, -3680, 1024, -3648, 32, fLt+kC, vSH, TEX_LITE3);\n    Wall( fT, vInf, vSS, 1088, -3648, 1088, -3680, 32, fLt+kC, vSH, TEX_LITE3);\n    Null( vSS, 1088, -3648, 1024, -3648 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector31( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH );\n    Open( fT, vInf, vSS, 704, -3104, 704, -3360, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 );\n    Wall( fT, vInf, vSS, 512, -3328, 512, -3304, 24, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 512, -3160, 512, -3136, 24, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 512, -3136, 680, -3104, 171, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 680, -3104, 704, -3104, 24, fLt-kC, vSH, TEX_SUPPORT2);\n    Wall( fT, vInf, vSS, 704, -3360, 680, -3360, 24, fLt-kC, vSH, TEX_SUPPORT2);\n    Wall( fT, vInf, vSS, 680, -3360, 512, -3328, 171, fLt, vSH, TEX_STARTAN3);\n    Null( vSS, 496, -3160, 496, -3304 );\n    Wall( fT, vInf, vSS, 512, -3304, 496, -3304, 16, fLt-kC, vSH, TEX_DOORTRAK);\n    Wall( fT, vInf, vSS, 496, -3160, 512, -3160, 16, fLt-kC, vSH, TEX_DOORTRAK);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector32( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 224.0);\n\n    BeginSector( vSS, vSH );\n    Upper( fT, vInf, vSS, 496, -3160, 496, -3304, 144, fLt+kC, vSH, 120, TEX_STARG3 );\n    Wall( fT, vInf, vSS, 496, -3304, 496, -3328, 24, fLt+kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 496, -3328, 448, -3456, 136, fLt, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 448, -3456, 128, -3456, 320, fLt-kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 128, -3008, 448, -3008, 320, fLt-kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 496, -3136, 496, -3160, 24, fLt+kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 448, -3008, 496, -3136, 136, fLt, vSH, TEX_STARG3);\n    Lower( fT, vInf, vSS, 128, -3264, 160, -3264, 32, fLt-kC, vSH, 88, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 160, -3264, 192, -3264, 32, fLt-kC, vSH, 72, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 192, -3264, 224, -3264, 32, fLt-kC, vSH, 56, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 224, -3264, 256, -3264, 32, fLt-kC, vSH, 40, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 256, -3264, 288, -3264, 32, fLt-kC, vSH, 24, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 288, -3264, 320, -3264, 32, fLt-kC, vSH, 8, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 320, -3264, 320, -3200, 64, fLt+kC, vSH, 8, TEX_STEP6 );\n    Lower( fT, vInf, vSS, 320, -3200, 288, -3200, 32, fLt-kC, vSH, 8, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 288, -3200, 256, -3200, 32, fLt-kC, vSH, 24, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 256, -3200, 224, -3200, 32, fLt-kC, vSH, 40, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 224, -3200, 192, -3200, 32, fLt-kC, vSH, 56, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 192, -3200, 160, -3200, 32, fLt-kC, vSH, 72, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 160, -3200, 128, -3200, 32, fLt-kC, vSH, 88, TEX_SLADWALL );\n    Open( fT, vInf, vSS, 128, -3200, 64, -3072, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 );\n    Wall( fT, vInf, vSS, 64, -3072, 128, -3008, 90, fLt, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 128, -3456, 64, -3392, 90, fLt, vSH, TEX_STARG3);\n    Open( fT, vInf, vSS, 64, -3392, 128, -3264, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 );\n    Open( fT, vInf, vSS, 256, -3136, 320, -3136, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3136, 320, -3072, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3072, 256, -3072, 64, fLt-kC, vSH, 40, 184, TEX_SW1COMP, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 256, -3072, 256, -3136, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 256, -3392, 320, -3392, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3392, 320, -3328, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3328, 256, -3328, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 256, -3328, 256, -3392, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_FLOOR7_2) );\n}\n\nvoid Sector35( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 256, -3392, 320, -3392 );\n    Null( vSS, 320, -3392, 320, -3328 );\n    Null( vSS, 320, -3328, 256, -3328 );\n    Null( vSS, 256, -3328, 256, -3392 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1) );\n}\n\nvoid Sector36( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 256, -3136, 320, -3136 );\n    Null( vSS, 320, -3136, 320, -3072 );\n    Null( vSS, 320, -3072, 256, -3072 );\n    Null( vSS, 256, -3072, 256, -3136 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1) );\n}\n\nvoid Sector63( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 2736, -3648, 2488, -3744, 265, fLt, vSH, TEX_BROWN144);\n    Wall( fT, vInf, vSS, 2488, -3744, 2240, -3776, 250, fLt, vSH, TEX_BROWN144);\n    Null( vSS, 2736, -3648, 2240, -3648 );\n    Null( vSS, 2240, -3776, 2240, -3648 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo )\n{\n    vHitInfo = vec4(0.0);\n    fClosestT = 10000.0;\n\n#ifdef ENABLE_NUKAGE_SECTORS\n    Sector0( fClosestT, vHitInfo );\n    Sector1( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector3( fClosestT, vHitInfo );\n    Sector5( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector11( fClosestT, vHitInfo );\n    Sector12( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector24( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_MISC_SECTORS\t\n    Sector25( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_START_SECTORS\n\tSector27( fClosestT, vHitInfo );\n    Sector28( fClosestT, vHitInfo );\n    Sector29( fClosestT, vHitInfo );\n    Sector30( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_SECTOR_31\n    Sector31( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_MISC_SECTORS\n    Sector32( fClosestT, vHitInfo );\n    Sector35( fClosestT, vHitInfo );\n    Sector36( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector63( fClosestT, vHitInfo );\n#endif\n}\n\n\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ End of generated code\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Texture Helpers\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash2D(vec2 p)\n{\n\treturn hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = hash( fl );\n\tfloat h1 = hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nfloat Indent(vec2 vTexCoord, vec2 vHigh, vec2 vLow, float fHighIntensity, float fLowIntensity)\n{\n\tvec2 vMin = min(vLow, vHigh);\n\tvec2 vMax = max(vLow, vHigh);\n\tif((vTexCoord.x < vMin.x) || (vTexCoord.x > vMax.x) || (vTexCoord.y < vMin.y) || (vTexCoord.y > vMax.y))\n\t\treturn 1.0;\n\n\tif((vTexCoord.x == vHigh.x) || (vTexCoord.y == vHigh.y))\n\t{\n\t\treturn fHighIntensity;\n\t}\n\t\n\tif((vTexCoord.x == vLow.x) || (vTexCoord.y == vLow.y))\n\t{\n\t\treturn fLowIntensity;\n\t}\n\t\n\treturn 1.0;\n}\n\nvec4 SmoothBump(const in vec2 vTexCoord, const in vec2 vMin, const in vec2 vMax, const in vec2 vLightDir, const in float fSize)\n{\n\tvec2 vNearest = min( max(vTexCoord, vMin), vMax );\n\tvec2 vDelta = vNearest - vTexCoord;\n    float fDeltaLen = length(vDelta);\n\tfloat fDist = (fDeltaLen - fSize) \/ fSize;\n\tvec2 vDir = vDelta;\n    if(fDeltaLen > 0.0) vDir = vDir \/ fDeltaLen;\n\tfloat fShade = dot(vDir, vLightDir);\n\t\/\/return clamp(1.0 - (fDist \/ fSize), 0.0, 1.0) * fShade;\n\tfShade *= clamp(1.0 - abs((fDist)), 0.0, 1.0);\n\treturn vec4( fShade, fDist, (vTexCoord - vMin + fSize) \/ (vMax - vMin + fSize * 2.0) );\n}\n\n\nfloat wrap( const in float x , const in float r )\n{\n\treturn fract( x * (1.0 \/ r) ) * r;\n}\n\nvec4 Hexagon( vec2 vUV )\n{\n\tvec2 vIndex;\n\t\n\tfloat fRow = floor(vUV.y);\n\t\n\tvec2 vLocalUV = vUV;\n\tfloat fRowEven = wrap(fRow, 2.0);\n\tif(fRowEven < 0.5)\n\t{\n\t\tvLocalUV.x += 0.5;\n\t}\n\t\n\tvIndex = floor(vLocalUV);\n\t\n\tvec2 vTileUV = fract(vLocalUV);\n\t{\n\t\tfloat m = 2.0 \/ 3.0;\n\t\tfloat c = 2.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven < 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x -= 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat m = -2.0 \/ 3.0;\n\t\tfloat c = 4.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven >= 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x += 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\tvec2 vCenter = vIndex - vec2(0.0, -1.0 \/ 3.0);\n\tif(fRowEven > 0.5)\n\t{\n\t\tvCenter.x += 0.5;\n\t}\n\t\n\tvec2 vDelta = vUV - vCenter;\n\t\n\t\/\/vDelta = abs(vDelta);\n\t\n\tfloat d1 = vDelta.x;\n\tfloat d2 = dot(vDelta, normalize(vec2(2.0\/3.0, 1.0)));\n\tfloat d3 = dot(vDelta, normalize(vec2(-2.0\/3.0, 1.0)));\n\t\n\td2 *= 0.9;\n\td3 *= 0.9;\n\t\n\tfloat fDist = max( abs(d1), abs(d2) );\n\tfDist = max( fDist, abs(d3) );\n\t\n\tfloat fTest = max(max(-d1, -d2), d3);\n\t\n\treturn vec4(vIndex, abs(fDist), fTest);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Textures\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 TexNukage3( vec2 vTexCoord, float fRandom)\n{\n\tfloat fBlend = 0.0;\n\tfBlend = smoothstep(0.8, 0.0, fRandom);\n\tfBlend = min(fBlend, smoothstep(1.0, 0.8, fRandom));\n\tfBlend *= 1.5;\n\tvec3 col = mix( vec3(11.0, 23.0, 7.0), vec3(46.0, 83, 39.0), fBlend) \/ 255.0;\n\t\n\treturn col;\n}\n\nvoid AddMountain( inout float fShade, const in vec2 vUV, const in float fRandom, const in float fHRandom, const in float fXPos, const in float fWidth, const in float fHeight, const in float fFog)\n{\n\tfloat fYPos = 1.0 - smoothstep( 0.0, 1.0, abs(fract(fXPos - vUV.x + vUV.y * 0.05 + 0.5) - 0.5) * fWidth );\n\tfYPos += fHRandom * 0.05 + fRandom * 0.05;\n\tfYPos *= fHeight;\n\tfloat fDist = fYPos - vUV.y;\n\tif(fDist > 0.0)\n\t{\n\t\tfShade = fRandom * ((1.0 - clamp(sqrt(fDist) * 2.0, 0.0, 1.0)) * 0.3 + 0.1);\n\t\tfShade = mix(fShade, 0.6 + 0.1 * fRandom, fFog);\n\t}\t\n}\n\nvec3 TexFSky1(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fShade = 0.6 + 0.1 * fRandom;\n\t\n\tvec2 vUV = vTexCoord * (1.0 \/ vec2(256.0, 128.0));\n\tvUV.y = 1.0 - vUV.y;\n\t\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 0.25, 1.0, 0.85, 0.5 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.5, 4.0, 0.78, 0.2 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.94, 2.51, 0.8, 0.0 );\n\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexFloor7_1( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(51.0, 43.0, 19.0), vec3(79.0, 59, 35.0), fRandom * fRandom * 2.5) \/ 255.0;\n\t\n\treturn col;\n}\n\nvec3 TexFlat5_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(63.0, 47.0, 23.0), vec3(147.0, 123.0, 99.0), fRandom) \/ 255.0;\n\t\n\tcol *= mod(vTexCoord.x, 2.0) * 0.15 + 0.85;\n\t\n\treturn col;\n}\n\nvec3 TexFloor4_8( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(30.0, 30.0, 30.0), vec3(150.0, 150.0, 150.0), fRandom * fRandom) \/ 255.0;\n\n\tvec4 vHex = Hexagon( vTexCoord.yx \/ 32.0 );\n    \n    float fShadow = (clamp((0.5 - vHex.z) * 15.0, 0.0, 1.0) * 0.5 + 0.5);\n    float fHighlight = 1.0 + clamp(1.0 - (abs(0.45 - vHex.w)) * 32.0, 0.0, 1.0) * 0.5;\n    \n\tcol = col * (clamp((0.5 - vHex.z) * 2.0, 0.0, 1.0) * 0.25 + 0.75);\n    col = col * fHighlight;\n\tcol = col * fShadow;\n\t\n\treturn col;\n}\n\nvec3 TexCeil3_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(1.0);\n\t\n\tvec2 vTileCoord = vTexCoord;\n\tvTileCoord.x -= 17.0;\n\tif( (vTileCoord.x >= 0.0) && (vTileCoord.x < 32.0) ) \n\t\tvTileCoord.y -= 58.0;\n\telse \n\t\tvTileCoord.y -= 11.0;\n\tvTileCoord.x = mod(vTileCoord.x, 32.0);\n\tvTileCoord.y = mod(vTileCoord.y, 64.0);\n\t\t\n\tvec2 vBoxClosest = clamp(vTileCoord, vec2(4.0, 4.0), vec2(28.0, 60.0));\n\tvec2 vDelta = vTileCoord - vBoxClosest;\n\tfloat fDist2 = dot(vDelta, vDelta);\n\n\tconst float fLight1 = 59.0 \/ 255.0;\n\tconst float fMed1 = 55.0 \/ 255.0;\n\tconst float fDark1 = 47.0 \/ 255.0;\n\tconst float fDark2 = 39.0 \/ 255.0;\n\n\tfloat fShade = fMed1;\t\n\tfShade = mix( fShade, fLight1, smoothstep(0.6, 0.45, fRandom) );\n\tfShade = mix( fShade, fDark1, smoothstep(0.45, 0.35, fRandom) );\n\t\n\tfShade = mix( fShade, fDark1, step(1.5, fDist2) );\n\tfShade = mix( fShade, fDark2, step(13.5, fDist2) );\n\t\t\n\tcol *= fShade;\n\t\n\tif((vTileCoord.x < 12.0) || (vTileCoord.x > 20.0) || (vTileCoord.y < 12.0) || (vTileCoord.y > 52.0))\n\t{\n\t\tfloat fRRow = floor(mod(vTileCoord.y - 3.5, 7.5));\n\t\tfloat fRColumn = mod(vTileCoord.x - 15.0, 10.0);\n\t\tif((fRRow == 2.0) && (fRColumn == 0.0))\n\t\t{\n\t\t\tcol -= 0.05;\n\t\t}\n\t\tif((fRRow <= 2.0) && (fRColumn <= 2.0))\n\t\t{\n\t\t\tvec2 vOffset = vec2(fRRow - 1.0, fRColumn - 1.0);\n\t\t\tfloat fDist2 = dot(vOffset, vOffset) \/ 2.0;\n\t\t\tcol += clamp(1.0 - fDist2, 0.0, 1.0) * 0.05;\n\t\t}\n\t}\n\t\n\treturn col;\n}\n\nvec3 TexFlat14( vec2 vTexCoord, float fRandom )\n{\n\treturn mix( vec3(0.0, 0.0, 35.0 \/ 255.0), vec3(0.0, 0.0, 200.0 \/ 255.0), fRandom * fRandom);\n}\n\nvec3 TexDoor3(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fVNoise = fHRandom + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\n\tfloat fShade = 1.0;\n\t\n\tfShade = 1.0 - abs((vTexCoord.y \/ 72.0) - 0.5) * 2.0;\n\tfShade = fShade * fShade;\n\tfShade = fShade * 0.2 + 0.3;\n\t\n\tfShade = fShade * (fHRandom * 0.2 + 0.8);\n\t\n\tfShade *= Indent( vTexCoord, vec2(8.0, 8.0), vec2(64.0 - 8.0, 72.0 - 16.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(8.0, 72.0 - 15.0), vec2(64.0 - 8.0, 72.0 - 8.0), 0.8, 1.2);\n\t\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 46.0), vec2(46.0, 32.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 56.0), vec2(46.0, 52.0), 0.8, 1.2);\n\t\n\tfShade += fRandom * 0.1;\n\n\tfloat fStreakTopAmount = smoothstep( 32.0, 0.0, vTexCoord.y );\n\tfloat fStreakBottomAmount = smoothstep( 72.0 -32.0, 72.0, vTexCoord.y );\n\t\n\tfShade *= 1.0 - fStreak * max(fStreakTopAmount, fStreakBottomAmount) * 0.2;\n\t\n\tif( (vTexCoord.x > 8.0) && (vTexCoord.x < 52.0) )\n\t{\n\t\tvec2 vRepeatCoord = mod( vTexCoord, vec2( 8.0, 48.0 ) );\n\t\tvRepeatCoord += vec2(4.0, -12.0);\n\t\tif( vRepeatCoord.x == 4.0 )\n\t\t{\n\t\t\tif(vRepeatCoord.y == 0.0)\n\t\t\t{\n\t\t\t\tfShade += 0.1;\n\t\t\t}\n\t\t\tif(vRepeatCoord.y > 0.0)\n\t\t\t{\n\t\t\t\tfShade *= clamp(vRepeatCoord.y \/ 16.0, 0.0, 1.0) * 0.3 + 0.7;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexLite3( vec2 vTexCoord )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord.y = mod(vLocalCoord.y, 8.0 );\n\t\n\tvec2 vClosest = min( max( vLocalCoord, vec2(4.0, 3.5) ), vec2(32.0 - 5.0, 3.5) );\n\tvec2 vDelta = vLocalCoord - vClosest;\n\tfloat fDist = max(abs(vDelta.x), abs(vDelta.y)) \/ 3.9;\n\t\n\treturn vec3(1.0 - fDist * 0.65);\n}\n\nvec3 TexStartan3( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(0.6);\n\t\n\tfloat fVNoise = noise1D(vTexCoord.x * 0.5) - ((vTexCoord.y) \/ 128.0) + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\t\n\tfloat fBlend2 = smoothstep( 0.0, 32.0, abs(vTexCoord.x - 64.0) );\n\tfBlend2 *= fBlend2;\n\tfBlend2 *= fStreak * 0.5 + 0.5;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) \/ 255.0, fBlend2 * 0.5);\n\t\n\tfloat fBlend = smoothstep( 24.0, 56.0, abs(vTexCoord.x - 64.0) );\n\tfBlend *= fBlend;\n\tfBlend *= fStreak * 0.7 + 0.3;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) * 1.1 \/ 255.0, fBlend);\n\t\n\tcol *= fRandom * fRandom * 0.3 + 0.7;\n\n\tvec2 vCoord = vTexCoord;\n\tvCoord.x = mod(vCoord.x, 32.0);\n\t\n\tfloat fStreakHL = fStreak * 0.075 + 0.075;\n\t\n\tfloat fDistMin = 1.0;\n\tfloat fShade = 0.0;\n\t\n\tvec4 vBump = SmoothBump( vCoord, vec2(6.0, 8.0), vec2(32.0 - 5.0, 9.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfDistMin = min(fDistMin, vBump.y);\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tvBump = SmoothBump( vCoord, vec2(6.0, 20.0), vec2(32.0 - 6.0, 40.0), normalize(vec2(0.0, 1.0)), 3.0 ); \n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vCoord, vec2(6.0, 64.0), vec2(32.0 - 6.0, 65.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vCoord, vec2(6.0, 76.0), vec2(32.0 - 6.0, 110.0), normalize(vec2(0.0, 1.0)), 3.0 ) ;\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 50.0), vec2(256.0, 52.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 122.0), vec2(256.0, 200.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.05;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tcol *= 1.0 + fShade * 3.0;\n\n\tcol *= clamp((1.0 - fDistMin) * 1.0, 0.0, 1.0) * 0.3 + 0.7;\n\n\treturn col;\n}\n\nvec3 TexBrown1( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(119.0, 95.0, 63.0), vec3(147.0, 123.0, 99.0), fRandom * fRandom) \/ 255.0;\n\n\tif(vTexCoord.x >= 64.0)\n\t{\n\t\tcol = col * vec3(1.0, 0.848, 0.646);\n\t\t\n\t\tcol = mix( col, vec3( 0.111, 0.414, 0.3), clamp((fRandom -0.5) * 2.0, 0.0, 1.0)); \/\/ green bits\n\t}\n\t\n\tfloat fVNoise = fHRandom + fRandom;\n\t\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\n\tvec2 vRepeatCoord = vTexCoord;\n\tvRepeatCoord.x = mod(vRepeatCoord.x, 13.0);\n\t\n\tvec4 vBump = SmoothBump( vRepeatCoord, vec2( 5.0, 6.0 ), vec2( 5.0, 12.0), vec2(0.0, 1.0), 1.5);\n\tfloat fMask = clamp(1.0 - vBump.y, 0.0, 1.0);\n\t\n\tfloat fStreakAmount = 1.0;\n\tfStreakAmount *= smoothstep( 0.0, 8.0, vRepeatCoord.y );\n\tfloat fStreakWidth = smoothstep( 64.0, 12.0, vRepeatCoord.y );\n\tfloat fBase1Dist = smoothstep( 24.0, 75.0, vRepeatCoord.y ) * step(vRepeatCoord.y, 75.0);\n\tfloat fBase2Dist = smoothstep( 96.0, 127.0, vRepeatCoord.y );\/\/ * step(75.0, vRepeatCoord.y);\n\tfloat fBaseDist = max(fBase1Dist, fBase2Dist);\n\tfStreakWidth = max( fStreakWidth, fBaseDist);\n\tfloat fTop2Dist = smoothstep( 127.0, 75.0, vRepeatCoord.y ) * step(75.0, vRepeatCoord.y);\n\tfStreakWidth = max(fStreakWidth, fTop2Dist);\n\tfloat fStreakX = abs(vRepeatCoord.x - 5.0) \/ 8.0;\n\tfStreakAmount *= fStreakWidth;\n\tfStreakAmount *= smoothstep( fStreakWidth, 0.0, fStreakX);\n\tfStreakAmount = max(fStreakAmount, (fBaseDist - 0.75) * 4.0);\n\tfStreakAmount *= 1.0 - fMask; \n\tcol = mix(col, vec3(0.3, 0.2, 0.1), fStreakAmount * (fStreak * 0.5 + 0.5) );\n\t\n\tcol += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (vBump.w) * (1.0-vBump.y) * 0.05 : 0.0;\n\t\n\tif((vTexCoord.y == 17.0) || (vTexCoord.y == 73.0)) col *= 0.9;\n\tif((vTexCoord.y == 19.0) || (vTexCoord.y == 75.0)) col *= 1.2;\n\n\tcol *= 1.0 + clamp(vBump.x, -1.0, 0.0) * 0.6;\n\t\t\n\treturn col;\n}\n\nvec3 TexDoorstop( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = 1.0 - abs(vTexCoord.x - 3.4) \/ 4.0;\n\t\n\tfShade = fShade * 0.2 + 0.2;\n\t\n\tfloat fSin = sin((vTexCoord.y - 16.0) * 3.14150 * 4.0 \/ 128.0) * 0.5 + 0.5;\n\tfShade *= 0.8 + fRandom * 1.2 * fSin;\n\t\n\treturn vec3(fShade);\n}\n\nvoid DrawScreen(inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, const in vec3 vCol)\n{\n\tvec2 vScreenCoord = vTexCoord - vPos;\n\tcol *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);\n\n\tif((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))\n\t{\n\t\tcol = vCol;\n\t}\n}\n\nvec3 TexCompute2( vec2 vTexCoord, float fRandom )\n{\n    fRandom = 1.0 - fRandom * fRandom;\n\tvec3 col = vec3(35.0 \/ 255.0);\n\t\n\tcol *= Indent( vTexCoord, vec2( -8.0, 0.0), vec2(300.0, 10.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 11.0), vec2(300.0, 27.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 28.0), vec2(300.0, 43.0), 1.3, 0.5);\n\t{\n\t\tvec2 vLocalCoord = vTexCoord;\n\t\tvLocalCoord.x = mod(vLocalCoord.x, 21.0);\n\t\tcol *= Indent( vLocalCoord, vec2( 0.0, 44.0), vec2(20.0, 55.0), 1.3, 0.5);\n\t}\n\n\tif(vTexCoord.y < 40.0)\n\t{\n\t\tvec2 vTileSize = vec2(48.0, 14.0);\n\t\tvec2 vIndex = floor(vTexCoord \/ vTileSize);\n\n\t\tfloat fIndex = vIndex.x + vIndex.y * 13.0;\n\t\tvec2 vMin = vIndex * vTileSize + vec2(hash(fIndex) * 32.0, 4.0);\n\t\tvec2 vSize = vec2(8.0 + hash(fIndex + 1.0) * 32.0, 4.0);\n\n\t\tvec3 vCol = vec3(0.0);\n\t\tfloat iIndex = floor(mod(fIndex, 5.0));\n\t\tif( iIndex < 0.5 ) \n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.25, 0.0), fRandom);\n\t\t}\n\t\telse if(iIndex < 1.5)\n\t\t{\n\t\t\tvCol = mix(vec3(1.0, 0.6, 0.02), vec3(0.1), fRandom);\n\t\t}\n\t\telse if(iIndex < 2.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.5);\n\t\t}\n\t\telse if(iIndex < 3.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.25);\n\t\t}\n\t\telse if(iIndex < 4.5)\n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.0, 0.5), vec3(0.1), fRandom);\n\t\t}\n\t\tDrawScreen(col, vTexCoord, vMin, vSize, vCol);\n\t}\n\n\treturn col;\n}\n\nvec3 TexStep6( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(87.0, 67.0, 51.0), vec3(119.0, 95.0, 75.0), fRandom) \/ 255.0;\n\n\tcol *= Indent( vTexCoord, vec2(-1.0, 3.0), vec2(32.0, 1.0), 1.3, 0.7);\n\tcol *= Indent( vTexCoord, vec2(-1.0, 8.0), vec2(32.0, 0.0), 1.3, 0.9);\n\n\tfloat fStreak = clamp((vTexCoord.y \/ 16.0) * 1.5 - fHRandom, 0.0, 1.0);\n\n\tcol *= fStreak * 0.3 + 0.7;\n\t\n\treturn col;\n}\n\nvec3 TexSupport2( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col;\n\tfloat fShade = 0.5;\n\t\n\tfloat f1 = abs(fract((vTexCoord.y + 32.0) \/ 70.0) - 0.5) * 2.0;\n\tfloat f2 = abs(fract((vTexCoord.x + 16.0) \/ 16.0) - 0.5) * 2.0;\n\tfShade += f1 * 0.75 + f2 * 0.25;\n\tfShade = fShade * fShade;\n\n\tfShade = fShade * 0.2 + 0.05;\n\tfShade *= 1.0 + fRandom * 0.4;\n\n\tvec2 vLocalCoord = vTexCoord;\n\tif((vLocalCoord.y < 64.0) || (vLocalCoord.y > 75.0))\n\t{\n\t\tif(vLocalCoord.y > 64.0) vLocalCoord.y -= 8.0;\n\t\tvLocalCoord = mod( vLocalCoord, vec2(20.0, 16.0));\n\t\tfloat fIndent = Indent( vLocalCoord, vec2(8.0, 8.0), vec2(16.0, 15.0), 0.9, 1.1);\n\t\tfShade += fIndent - 1.0;\n\t}\n\t\n\tcol = vec3(fShade);\n\t\n\treturn col;\n}\n\nvec3 TexDoorTrak( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = fRandom * 0.5;\n\tfShade *= mod(vTexCoord.x, 2.0) * 0.6 + 0.4;\n\treturn vec3(fShade);\n}\n\nvec3 TexBrown144( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(39.0, 39.0, 39.0), vec3(51.0, 43.0, 19.0), fRandom) \/ 255.0;\n\t\n\tfloat fBlend = fHRandom - 0.1;\n\tfBlend = clamp(fBlend, 0.0, 1.0);\n\tcol = mix( col, col * 2.0 * vec3(0.893, 0.725, 0.161), fBlend);\n\treturn col;\n}\n\n#ifdef ENABLE_SPRITES\n\nvec3 TexBar1A( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = vec3(123.0, 127.0, 99.0) \/ 255.0;\n\t\n\tfloat fBrownStreakBlend = smoothstep( 2.0, 1.0, abs(vTexCoord.x - 3.5));\n\tcol = mix(col, vec3(0.724, 0.736, 0.438), fBrownStreakBlend);\n\t\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 3.0) && (vTexCoord.x < 18.0) )\n\t{\n\t\tcol = col * clamp(((vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\telse\n\t{\n\t\tcol = col * clamp((1.0 - (vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\t\n\tfloat fNukageBlend = 0.0;\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 8.0) && (vTexCoord.x < 14.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tif( (vTexCoord.y == 2.0) && (vTexCoord.x > 2.0) && (vTexCoord.x < 20.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tcol = mix(col, vec3(0.172, 0.560, 0.144) * fRandom, fNukageBlend);\n\t\n\t\n\tif(vTexCoord.x < 1.0)\n\t{\n\t\tcol += 0.1;\n\t}\n\t\n\tfloat fBlend = clamp(((vTexCoord.x - 20.0) \/ 3.0), 0.0, 1.0);\n\tcol += fBlend * 0.2;\n\t\n\tfloat fBumpY = 8.0;\n\tif(vTexCoord.y > 14.0) fBumpY += 9.0;\n\tif(vTexCoord.y > 23.0) fBumpY += 8.0;\n\n\tvec4 vBump = SmoothBump( vTexCoord, vec2(2.0, fBumpY), vec2(23.0 - 2.0, fBumpY), normalize(vec2(-0.2, 1.0)), 1.25 );\t\n\tcol += vBump.x * 0.2;\n\n\t\/\/ rim highlights\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(17.0, 0.0)) \/ vec2(8.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(20.0, 1.0)) \/ vec2(4.0, 1.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(3.0, 2.0)) \/ vec2(4.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t\n\tcol *= 0.5 + fRandom * 0.5;\n\t\n\treturn col;\n}\n\nvec3 TexPlayW( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 col = mix(vec3(190.0, 10.0, 10.0), vec3(50, 16.0, 16.0 ), fRandom * vTexCoord.y\/18.0) \/ 255.0;\n\treturn col;\n}\n\n#endif \n\nvec3 SampleTexture( const in float fTexture, const in vec2 _vUV )\n{\n    vec3 col = vec3(1.0, 0.0, 1.0);\n    vec2 vUV = _vUV;\n    \n    vec2 vSize = vec2(64.0);\n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;\n\n\tif(fTexture == TEX_NUKAGE3)\n\t{\n        float fTest = fract(floor(iGlobalTime * 6.0) * (1.0 \/ 3.0));\n        if( fTest < 0.3 )\n        {\n\t        vUV += 0.3 * vSize;\n        }\n        else if(fTest < 0.6)\n        {\n            vUV = vUV.yx - 0.3; \n        }\n        else\n        {\n            vUV = vUV + 0.45;\n        }\n\t}\n\t\n\t     if(fTexture == TEX_NUKAGE3) { fPersistence = 1.0; }\n\telse if(fTexture == TEX_F_SKY1) { vSize = vec2(256.0, 128.0); fNoise2Freq = 0.3; }\n    else if(fTexture == TEX_FLOOR7_1) { vSize = vec2(64.0, 32.0); fPersistence = 1.0; }\t\n    else if(fTexture == TEX_FLAT5_5) { fPersistence = 3.0; }\n    else if(fTexture == TEX_FLOOR4_8) { fPersistence = 0.3; }\n    else if(fTexture == TEX_CEIL3_5) { fPersistence = 0.9; }\t\n    else if(fTexture == TEX_FLAT14) { fPersistence = 2.0; }\n    else if(fTexture == TEX_DOOR3) { vSize = vec2(64.0, 72.0); }\t\n    else if(fTexture == TEX_LITE3) { vSize = vec2(32.0, 128.0); }\t\n    else if(fTexture == TEX_STARTAN3) { vSize = vec2(128.0); fPersistence = 1.0; }\t\n\telse if(fTexture == TEX_BROWN1) { vSize = vec2(128.0); fPersistence = 0.7; }\t\n    else if(fTexture == TEX_DOORSTOP) { vSize = vec2(8.0, 128.0); fPersistence = 0.7; }\n    else if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 56.0); fPersistence = 1.5; }\n    else if(fTexture == TEX_STEP6) { vSize = vec2(32.0, 16.0); fPersistence = 0.9; }\n    else if(fTexture == TEX_SUPPORT2) { vSize = vec2(64.0, 128.0); }\n    else if(fTexture == TEX_DOORTRAK) { vSize = vec2(8.0, 128.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(23.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(57.0, 22.0); fPersistence = 1.0; }\n#endif\n\t\n#ifdef PREVIEW\n\t     if(fTexture == TEX_DOOR3) {\tvSize = vec2(128.0, 128.0); }\t\n\telse if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 64.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(32.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(64.0, 32.0); }\t\n#endif\n#endif\n\t\n\t\n#ifdef PREVIEW\n    vec2 vTexCoord = floor(fract(vUV) * vSize);\n#else\n    vec2 vTexCoord = fract(vUV \/ vSize) * vSize;\n    #ifdef PIXELATE_TEXTURES\n    vTexCoord = floor(vTexCoord);\n    #endif\n    vTexCoord.y = vSize.y - vTexCoord.y - 1.0;\n#endif\n\tfloat fRandom = fbm( vTexCoord, fPersistence );\n\tfloat fHRandom = noise1D(vTexCoord.x * fNoise2Freq) - ((vTexCoord.y) \/ vSize.y);\n    \n\t     if(fTexture == TEX_NUKAGE3) \tcol = TexNukage3( vTexCoord, fRandom );\n\telse if(fTexture == TEX_F_SKY1) \tcol = TexFSky1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_FLOOR7_1) \tcol = TexFloor7_1( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLAT5_5) \tcol = TexFlat5_5( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLOOR4_8) \tcol = TexFloor4_8( vTexCoord, fRandom );\n    else if(fTexture == TEX_CEIL3_5) \tcol = TexCeil3_5( vTexCoord, fRandom );\n\telse if(fTexture == TEX_FLAT14) \tcol = TexFlat14( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOOR3) \t\tcol = TexDoor3( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_LITE3) \t\tcol = TexLite3( vTexCoord );\n    else if(fTexture == TEX_STARTAN3) \tcol = TexStartan3( vTexCoord, fRandom );\n    else if(fTexture == TEX_BROWN1) \tcol = TexBrown1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_DOORSTOP) \tcol = TexDoorstop( vTexCoord, fRandom );\n    else if(fTexture == TEX_COMPUTE2) \tcol = TexCompute2( vTexCoord, fRandom );\n    else if(fTexture == TEX_STEP6) \t\tcol = TexStep6( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_SUPPORT2) \tcol = TexSupport2( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOORTRAK) \tcol = TexDoorTrak( vTexCoord, fRandom );\n\telse if(fTexture == TEX_BROWN144) \tcol = TexBrown144( vTexCoord, fRandom, fHRandom );\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) \t\tcol = TexBar1A( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_PLAYW) \t\tcol = TexPlayW( vTexCoord, fRandom, fHRandom );\t\n#endif\n\t\n    #ifdef QUANTIZE_TEXTURES\n    col = Quantize(col);\n    #endif\n\n    return col;\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define N(T,N) t+=float(T); if(x>t) r=vec2(N,t);\n#define L(T,N,X) t+=float(T); if((x>t) && (x<(t+float(X)))) r=vec2(N,t);\n\nvec2 GetTrack1Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(1628,40,8)N(24,40)N(28,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,12)N(28,40)N(24,47)N(26,48)L(26,40,4)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)N(28,48)L(24,40,10)N(26,40)N(26,46)L(126,40,10)N(26,40)N(24,52)L(28,40,8)N(24,40)N(26,50)L(26,40,10)N(24,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,8)N(24,40)N(28,47)N(24,48)L(26,40,8)N(26,40)N(24,52)L(26,40,10)N(26,40)N(24,50)L(26,40,8)N(26,40)L(24,63,14)L(14,60,14)L(14,59,12)L(12,63,12)L(12,66,12)L(12,64,14)L(14,63,12)L(12,59,14)L(14,63,12)L(12,64,12)L(12,66,12)L(12,67,14)L(14,66,14)L(14,64,12)L(12,63,12)L(12,59,12)L(12,40,8)N(26,40)N(26,52)L(24,40,8)N(28,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,8)N(26,40)N(24,46)L(26,40,10)N(26,40)N(24,47)N(28,48)L(24,40,4)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,10)N(28,40)N(24,46)L(128,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(28,50)L(24,40,10)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,8)N(26,40)N(26,47)N(24,48)L(28,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)L(26,67,14)L(14,64,12)L(12,59,12)L(12,64,12)L(12,67,14)L(14,64,14)L(14,67,12)L(12,71,12)L(12,67,12)L(12,64,14)\n    return r;\n}\n\nvec2 GetTrack2Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(0,40,8)N(24,40)N(26,52)L(26,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,12)N(26,40)N(26,47)N(26,48)L(26,40,4)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)N(26,48)L(26,40,10)N(26,40)N(26,46)L(126,40,10)N(26,40)N(24,52)L(26,40,10)N(26,40)N(26,50)L(26,40,10)N(24,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,8)N(24,40)N(26,47)N(26,48)L(26,40,8)N(26,40)N(24,52)L(26,40,10)N(26,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,10)N(26,40)N(26,46)L(126,40,8)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(26,40,8)N(26,40)N(24,48)L(26,40,8)N(26,40)N(24,46)L(26,40,10)N(26,40)N(24,47)N(26,48)L(26,40,4)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,10)N(26,40)N(26,46)L(128,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,10)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,8)N(26,40)N(26,47)N(24,48)L(26,40,10)N(26,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)L(26,66,14)L(14,64,12)L(12,63,12)L(12,66,12)L(12,69,14)L(14,67,12)L(12,66,14)L(14,63,12)L(12,66,12)L(12,67,14)L(14,69,12)L(12,71,14)L(14,69,12)L(12,67,12)L(12,66,12)L(12,63,14)L(14,40,6)N(26,40)N(24,52)L(26,40,8)N(26,40)N(24,50)L(26,40,10)N(26,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,10)N(24,40)N(26,47)N(26,48)L(24,40,6)N(26,40)N(26,52)L(26,40,8)N(26,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,10)N(26,40)N(24,46)L(128,40,8)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,12)N(26,40)N(26,48)L(26,40,8)N(26,40)N(24,46)L(26,40,8)N(26,40)N(24,47)N(26,48)L(26,40,8)N(24,40)N(26,52)L(26,40,8)N(26,40)N(26,50)L(24,40,8)L(26,40,14)L(26,71,12)L(12,67,12)L(12,64,14)L(14,67,12)L(12,71,14)L(14,67,12)L(12,71,12)L(12,76,12)L(12,71,14)L(14,67,12)\n    return r;\n}\n\nvec2 GetTrack3Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,40)N(406,40)N(406,40)N(408,40)N(408,40)N(408,40)N(406,40)N(408,40)N(406,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)\n    return r;\n}\n\nvec2 GetTrack4ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,36)N(406,36)N(406,36)N(408,36)N(408,36)L(38,49,8)N(370,36)L(36,49,10)N(370,36)L(38,49,8)N(370,36)L(38,49,8)L(164,36,12)L(28,36,10)L(24,36,12)L(26,36,14)L(26,36,10)L(24,36,12)L(26,36,10)L(26,36,12)N(24,36)N(2,46)N(50,40)N(2,46)L(50,36,12)N(2,46)N(22,36)N(26,40)N(2,46)N(48,36)N(2,46)N(50,40)N(4,46)L(46,36,14)N(2,46)N(24,36)N(24,40)N(4,46)N(48,36)N(2,46)N(50,40)N(2,46)L(48,36,14)N(6,46)N(20,36)N(24,40)N(4,46)N(48,36)N(52,40)N(48,46)L(2,36,14)N(26,36)N(24,40)N(2,46)N(48,46)N(2,36)N(50,46)N(50,46)L(28,36,14)N(24,46)N(52,36)N(50,40)N(2,46)N(48,36)N(52,40)N(2,46)N(50,36)N(48,46)N(2,40)N(50,46)N(26,36)N(26,40)L(50,36,6)L(2,50,8)L(24,36,8)L(24,36,8)L(4,40,6)L(24,36,8)L(24,36,8)L(4,45,8)L(2,40,6)\n    return r;\n}\n\nvec2 GetTrack4BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,40)N(406,40)N(406,40)N(408,40)N(408,40)L(38,57,8)N(370,40)L(36,57,10)N(370,40)L(38,57,8)N(370,40)L(38,57,8)L(164,40,12)L(28,40,8)L(24,40,14)L(26,40,12)L(26,40,12)L(24,40,12)L(26,40,14)L(26,40,12)N(636,46)N(52,46)N(202,40)N(50,36)N(52,40)N(52,46)N(100,46)N(104,46)L(100,36,14)N(52,46)L(52,40,8)L(52,47,8)\n    return r;\n}\n\nvec2 GetTrack4CNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,41)N(406,41)N(406,41)N(408,41)N(408,41)N(408,41)N(406,41)N(408,41)L(202,41,12)L(28,41,8)L(24,41,12)L(26,41,10)L(26,41,12)L(24,41,12)L(26,41,12)L(26,41,12)\n    return r;\n}\n\nvec2 GetTrack4DNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1628,49)N(408,49)N(406,49)N(408,49)\n    return r;\n}\n\nvec2 GetTrack4ENote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1628,57)N(408,57)L(406,57,14)L(408,57,14)\n    return r;\n}\n\n\n\/\/ ------------------- 8< ------------------- 8< ------------------- 8< -------------------\n\n#define PI radians(180.0)\n#define TWO_PI radians(360.0)\n\nfloat NoteToHz(float n)\n{  \t\n\treturn 440.0*pow( 2.0, (n-69.0)\/12.0 );\n}\n\nfloat Tri( float t )\n{\n\treturn abs(fract( t ) * 4.0 - 2.0) - 1.0;\n}\n\nfloat Saw( float t )\n{\n\treturn fract( t ) * 2.0 - 1.0;\n}\n\nvec4 Saw4( vec4 x )\n{\n\treturn fract( x ) * 2.0 - 1.0;\n}\n\nfloat Cos( float t )\n{\n\treturn cos( t * radians(360.0) );\n}\n\nvec4 Cos4( vec4 x )\n{\n\tx = abs(fract(x) * 2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn x2 * 6.0 - x2*x * 4.0  - 1.0;\n}\n\nfloat Square( float t )\n{\n\treturn step( fract(t), 0.5 ) * 2.0 - 1.0;\n}\n\n\/\/ Thanks to Dave_Hoskins for the hash\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat Noise( float x )\n{\n\treturn Hash( floor(x * 32.0) ) * 2.0 - 1.0;\n}\n\nfloat SmoothNoise( float t )\n{\n\tfloat noiset = t * 32.0;\n\tfloat tfloor = floor(noiset);\n\tfloat ffract = fract(noiset);\n\t\n\tfloat n0 = Hash(tfloor);\n\tfloat n1 = Hash(tfloor + 1.0);\n\tfloat blend = ffract*ffract*(3.0 - 2.0*ffract);\n\treturn mix(n0, n1, blend) * 2.0 - 1.0;\n}\n\nfloat FBM( float t, float persistence )\n{\n    float result = 0.0;\n    \n    float a = 1.0;\n    float tot = 0.0;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    tot += a; \n    return result \/ tot;\n}\n\n\nfloat StepNoise( float t, float freq )\n{\n\tfloat noiset = t * freq;\n\tfloat tfloor = floor(noiset);\n\t\n\tfloat n = Hash(tfloor);\n\treturn n * 2.0 - 1.0;\n}\n\nfloat Cos4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Cos4((x+phase) * freq), amp);\n}\n\nfloat Saw4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Saw4((x+phase) * freq), amp);\n}\n\n\nfloat Test( float t )\n{\n\treturn Saw4(t, vec4(0.0, 0.5, 0.1, 0.4), vec4(1.0, 1.50, 2.00, -3.00), vec4(1.0, 0.5, 0.25, 0.125));\n}\n\nfloat Envelope( float time, float decay )\n{\t\n\treturn exp2( -time * (5.0 \/ decay) );\n}\n\nfloat Envelope( float time, float attack, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time\/attack;\n\t}\n\n\ttime -= attack;\n\n\treturn Envelope( time, decay );\n}\n\nfloat Test2(float f)\n{\n    return Test(f) + Test(f - 0.0454) * 0.4 + Test(f - 0.1123) * 0.3 + Test(f - 0.1523) * 0.1;\n}\nfloat Instrument( const in vec2 vFreqTime )\n{\n    return Test2( vFreqTime.x * vFreqTime.y ) * Envelope( vFreqTime.y, 0.01, 1.0 );    \n}\n\nfloat Track1Instrument( const in vec2 vFreqTime )\n{\n    return Instrument( vFreqTime * vec2(2.0, 1.0) ) * 0.75;\n}\n\nfloat Track2Instrument( const in vec2 vFreqTime )\n{\n    return Instrument( vFreqTime );\n}\n\nfloat Track3Basic(float x)\n{\n    return FBM(x, 0.5);\n}\n\nfloat Track3Instrument( const in vec2 vFreqTime )\n{\n    return Track3Basic(vFreqTime.y * vFreqTime.x) * Envelope(vFreqTime.y, 0.4) * 2.0;\n}\n\nfloat kick(float freq, float fNoteTime){\n    float a = clamp(1.0-fNoteTime,0.0,1.0);\n    float osc = sin(pow(a,5.0)*freq);\n    return osc * pow(a, 2.0);\n}\n\nfloat Track4Instrument( const in vec2 vFreqTime )\n{\n    return FBM(vFreqTime.y * vFreqTime.x * 8.0, 2.0) * Envelope(vFreqTime.y, 0.5);\n}\n\n\nconst float kMidiTimebase = 200.0;\nconst float kInvMidiTimebase = 1.0 \/ kMidiTimebase;\n\nvec2 GetNoteData( const in vec2 vMidiResult, const in float fMidiTime )\n{\n    return vec2( NoteToHz(vMidiResult.x), (fMidiTime - vMidiResult.y) * kInvMidiTimebase );\n}\n\nfloat PlayMidi( const in float time )\n{\n    if(time < 0.0)\n\t\treturn 0.0;\n    \n    float fMidiTime = time * kMidiTimebase;\n    \n    float fResult = 0.0;\n    \n    fResult += Track1Instrument( GetNoteData( GetTrack1Note(fMidiTime), fMidiTime ) );\n    fResult += Track2Instrument( GetNoteData( GetTrack2Note(fMidiTime), fMidiTime ) );\n    fResult += Track3Instrument( GetNoteData( GetTrack3Note(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4ANote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4BNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4CNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4DNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4ENote(fMidiTime), fMidiTime ) );\n    \n    fResult = clamp(fResult * 0.1, -1.0, 1.0);\n    \n    float fFadeEnd = 20.0 * 240.0 \/ kMidiTimebase;\n    float fFadeTime = 5.0;\n    float fFade = (time - (fFadeEnd - fFadeTime)) \/ fFadeTime;    \n    fResult *= clamp(1.0 - fFade, 0.0, 1.0);\n    \n    return fResult;\n}\n\nvec2 mainSound(float time)\n{\n    return vec2( PlayMidi(time - 3.0) );\n}\n\n\/\/#define IMAGE_SHADER\n\n#ifdef IMAGE_SHADER\n\nfloat Function( float x )\n{\n\treturn mainSound( iGlobalTime + x \/ (44100.0 \/ 60.0) ).x * 0.5 + 0.5;\n}\n\nfloat Plot( vec2 uv )\n{\n\tfloat y = Function(uv.x);\n\t\n\treturn abs(y - uv.y) * iResolution.y;\t\n}\n\nvoid main()\n{\n\t\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n\t\n\tvec3 vResult = vec3(0.0);\n\t\n\tvResult += Plot(uv);\n\t\n\tgl_FragColor = vec4((vResult),1.0);\n}\n#endif\n\n","name":"","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"MdlGW7","date":"1372661086","viewed":16670,"name":"Cloudy Terrain","username":"iq","description":"A terrain full of trees or something (up to your interpretation). Distance field raymarching for the terrain. Linearly volumetric raymarching for the foliage. Linearly volumetric raymarching for clouds. Plain plane Raytraced for lakes.","likes":77,"published":1,"tags":["procedural","3d","raymarching","distancefield","clouds","volumetric"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":1},{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":3},{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n#if 0\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#else\n    float a = texture2D( iChannel0, x.xy\/256.0 + (p.z+0.0)*120.7123 ).x;\n    float b = texture2D( iChannel0, x.xy\/256.0 + (p.z+1.0)*120.7123 ).x;\n\treturn mix( a, b, f.z );\n#endif\t\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat envelope( vec3 p )\n{\n\tfloat isLake = 1.0-smoothstep( 0.62, 0.72, texture2D( iChannel0, 0.001*p.zx,-100.0).x );\n\treturn 0.1 + isLake*0.9*texture2D( iChannel1, 0.01*p.xz ).x;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y - envelope(pos);\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 50.0;\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    h = mapTerrain( ro+rd*t );\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 lig = normalize( vec3(0.7,0.4,0.2) );\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           0.5*2.0*eps.x,\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec4 mapTrees( in vec3 pos, in vec3 rd )\n{\n    vec3  col = vec3(0.0);\t\n\tfloat den = 1.0;\n\n\tfloat kklake = texture2D( iChannel0, 0.001*pos.zx,-100.0).x;\n\tfloat isLake = smoothstep( 0.7, 0.71, kklake );\n\t\n\tif( pos.y>1.0 || pos.y<0.0 ) \n\t{\n\t\tden = 0.0;\n\t}\n\telse\n\t{\n\t\t\n\t\tfloat h = pos.y;\n\t\tfloat e = envelope( pos );\n\t\tfloat r = clamp(h\/e,0.0,1.0);\n\t\t\n        den = smoothstep( r, 1.0, texture2D(iChannel0, pos.xz*0.15, -100.0).x );\n        \n\t\tden *= 1.0-0.95*clamp( (r-0.75)\/(1.0-0.75) ,0.0,1.0);\n\t\t\n        float id = texture2D( iChannel0, pos.xz,-100.0).x;\n        float oc = pow( r, 2.0 );\n\n\t\tvec3  nor = calcNormal( pos );\n\t\tvec3  dif = vec3(1.0)*clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n\t\t\n\t\tfloat w = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos+w*lig)*0.35 );\n\t\tc = smoothstep( 0.38, 0.6, c );\n\t\tdif *= pow( vec3(c), vec3(0.8, 1.0, 1.5 ) );\n\t\t\t\n\t\tvec3  brdf = 1.7*vec3(1.5,1.0,0.8)*dif*(0.1+0.9*oc) + 1.3*amb*vec3(0.1,0.15,0.2)*oc;\n\n\t\tvec3 mate = 0.6*vec3(0.5,0.5,0.1);\n\t\tmate += 0.3*texture2D( iChannel1, 0.1*pos.xz ).zyx;\n\t\t\n\t\tcol = brdf * mate;\n\n\t\tden *= 1.0-isLake;\n\t}\n\n\treturn vec4( col, den );\n}\n\n\nvec4 raymarchTrees( in vec3 ro, in vec3 rd, float tmax, vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n    float t = tmax;\n\tfor( int i=0; i<512; i++ )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tif( sum.a>0.99 || pos.y<0.0  || t>20.0 ) break;\n\t\t\n\t\tvec4 col = mapTrees( pos, rd );\n\n\t\tcol.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0018*t*t) );\n        \n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\t\t\n\t\tt += 0.0035*t;\n\t}\n\n\tsum.xyz \/= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec4 mapClouds( in vec3 p )\n{\n\tfloat d = 1.0-0.3*abs(2.8 - p.y);\n\td -= 1.6 * fbm( p*0.35 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 0.8*vec3(1.0,0.95,0.8), 0.2*vec3(0.6,0.6,0.6), res.x );\n\tres.xyz *= 0.65;\n\t\n\treturn res;\n}\n\nfloat kk = 0.0;\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tfloat t = 0.0;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.w>0.99 || t>tmax ) break;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\n\t\tfloat dt = max(0.1,0.05*t);\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos + lig*h)*0.35 );\n\t\t\/\/kk += 0.05*dt*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a);\n\t\tkk += 0.02*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a)*(1.0-smoothstep(2.75,2.8,pos.y));\n\t\n\t\t\n\t\tcol.xyz *= vec3(0.4,0.52,0.6);\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*pow( sun, 6.0 )*(1.0-col.w);\n\t\t\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*t*t) );\n\t\t\n\t\tcol.a *= 0.5;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += dt;\/\/max(0.1,0.05*t);\n\t}\nkk = clamp( kk, 0.0, 1.0 );\n\tsum.xyz \/= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 32.0*cos(0.2+0.75*.1*time*1.5), 1.2, 32.0*sin(0.1+0.75*0.11*time*1.5) );\n\t\n}\n\n\nvoid main(void)\n{\n    vec2 q = gl_FragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\tfloat time = 23.5+iGlobalTime;\n\t\n    \/\/ camera\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+1.0 );\n\tta.y *= 0.2;\n\tfloat roll = 0.3*cos(0.07*time);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.75*cw );\n\n    \/\/ sky\t \n\tvec3 col = vec3(0.84,0.95,1.0)*0.77 - rd.y*0.6;\n\tcol *= 0.75;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n    col += vec3(1.0,0.7,0.3)*0.3*pow( sun, 6.0 );\n\tvec3 bcol = col;\n\n    \/\/ lakes\n    float gt = (0.0-ro.y)\/rd.y;\n    if( gt>0.0 )\n    {\n        vec3 pos = ro + rd*gt;\n\n\t\tvec3 nor = vec3(0.0,1.0,0.0);\n\t    nor.xz  = 0.10*(-1.0 + 2.0*texture2D( iChannel3, 1.5*pos.xz ).xz);\n\t    nor.xz += 0.15*(-1.0 + 2.0*texture2D( iChannel3, 3.2*pos.xz ).xz);\n\t    nor.xz += 0.20*(-1.0 + 2.0*texture2D( iChannel3, 6.0*pos.xz ).xz);\n\t\tnor = normalize(nor);\n\n\t\tvec3 ref = reflect( rd, nor );\n\t    vec3 sref = reflect( rd, vec3(0.0,1.0,0.0) );\n\t\tfloat sunr = clamp( dot(ref,lig), 0.0, 1.0 );\n\n\t    float kklake = texture2D( iChannel0, 0.001*pos.zx,-100.0).x;\n\t\tcol = vec3(0.1,0.1,0.0);\n        vec3 lcol = vec3(0.2,0.5,0.7);\n\t\tcol = mix( lcol, 1.1*vec3(0.2,0.6,0.7), 1.0-smoothstep(0.7,0.81,kklake) );\n\t\t\n\t\tcol *= 0.12;\n\n\t    float fre = 1.0 - max(sref.y,0.0);\n\t\tcol += 0.8*vec3(1.0,0.9,0.8)*pow( sunr, 64.0 )*pow(fre,1.0);\n\t\tcol += 0.5*vec3(1.0,0.9,0.8)*pow( fre, 10.0 );\n\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n        float c = fbm( (pos+h*lig)*0.35 );\n\t\tcol *= 0.4 + 0.6*smoothstep( 0.38, 0.6, c );\n\n\t    col *= smoothstep(0.7,0.701,kklake);\n\n\t    col.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*gt*gt) );\n    }\n\n\n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n        \/\/ trees\t\t\n        vec4 res = raymarchTrees( ro, rd, t, bcol );\n\t    col = mix( col, res.xyz, res.w );\n\t}\n\n\t\/\/ sun glow\n    col += vec3(1.0,0.5,0.2)*0.35*pow( sun, 3.0 );\n\n    \/\/ clouds\t\n\t{\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t );\n\tcol = mix( col, res.xyz, res.w );\n\t}\n\n\t\/\/col += 0.2*vec3(1.0,0.8,0.7)*(kk);\n\t\/\/col = vec3(smoothstep(0.3,0.4,kk));\n\tcol += (1.0-0.8*col)*kk*kk*kk*0.3*vec3(1.0,0.8,0.7);\n\tcol = clamp( col, 0.0, 1.0 );\n\n\t\n    \/\/ gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= vec3(1.06,1.05,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n\t\n\tgl_FragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Msl3Rr","date":"1362385890","viewed":14797,"name":"Cubescape","username":"iq","description":"Raymarched rounded pulsating cubes","likes":76,"published":1,"tags":["procedural","3d","raymarching","distancefield","sound","reactive","music"],"hasliked":0},"renderpass":[{"inputs":[{"id":18,"src":"\/presets\/mzk01.mp3","ctype":"music","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n               -0.80,  0.36, -0.48,\n               -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m3*p*2.02;\n    f += 0.2500*noise( p ); p = m3*p*2.03;\n    f += 0.1250*noise( p ); p = m3*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f\/0.9375;\n}\n\n\n\nfloat dbox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat freqs[4];\n\nvec3 map( in vec3 pos )\n{\n\n\tvec2 fpos = fract( pos.xz ); \n\tvec2 ipos = floor( pos.xz );\n\t\n\t\/\/ipos.x += floor(10.0*sin( iGlobalTime + 0.1*ipos.y));\n\t\n    float f = 0.0;\t\n\tfloat id = hash( ipos.x + ipos.y*57.0 );\n\t#if 1\n\tf  = freqs[0] * clamp(1.0 - abs(id-0.20)\/0.30, 0.0, 1.0 );\n\tf += freqs[1] * clamp(1.0 - abs(id-0.40)\/0.30, 0.0, 1.0 );\n\tf += freqs[2] * clamp(1.0 - abs(id-0.60)\/0.30, 0.0, 1.0 );\n\tf += freqs[3] * clamp(1.0 - abs(id-0.80)\/0.30, 0.0, 1.0 );\n\tf = pow( clamp( f*0.75, 0.0, 1.0 ), 2.0 );\n\t#endif\n    float h = 0.01 + 4.0*f;\n\tfloat dis = dbox( vec3(fpos.x-0.5,pos.y-0.5*h,fpos.y-0.5), vec3(0.3,h*0.5,0.3), 0.1 );\n\n    return vec3( dis,id, f );\n}\n\n\nconst float surface = 0.001;\n\nvec3 trace( in vec3 ro, in vec3 rd, in float startf, in float maxd )\n{ \n    float s = surface*2.0;\n    float t = startf;\n\n    float sid = -1.0;\n\tfloat alt = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        if( s<surface || t>maxd ) break;\n        t += 0.15*s;\n\t    vec3 res = map( ro + rd*t );\n        s   = res.x;\n\t    sid = res.y;\n\t\talt = res.z;\n    }\n    if( t>maxd ) sid = -1.0;\n    return vec3( t, sid, alt );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float dt = 0.02;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h\/t );\n        t += max( 0.05, dt );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(surface*0.5,0.0,0.0);\n\tvec3 nor;\n\tnor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n\tnor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n\tnor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n\treturn normalize(nor);\n}\n\n\nvoid main( void )\n{\n    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy \/ iResolution.xy;\n    xy.x *= iResolution.x\/iResolution.y;\n\t\n    float time = 5.0 + 0.2*iGlobalTime + 20.0*iMouse.x\/iResolution.x;\n\n\tfreqs[0] = texture2D( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture2D( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture2D( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture2D( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n    \/\/ camera\t\n\tvec3 ro = vec3( 8.5*cos(0.2+.33*time), 5.0+2.0*cos(0.1*time), 8.5*sin(0.1+0.37*time) );\n\tvec3 ta = vec3( -2.5+3.0*cos(1.2+.41*time), 0.0, 2.0+3.0*sin(2.0+0.38*time) );\n\tfloat roll = 0.2*sin(0.1*time);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.75*cw );\n\t\n    \/\/ image\n    vec3 col = vec3( 0.0 );\n\t\n    vec3 res = trace( ro, rd, 0.025, 40.0 );\n    float t = res.x;\n    float sid = res.y;\n\n\n\tvec3 light1 = vec3(  0.577, 0.577, -0.577 );\n    vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n    vec3 lpos = vec3(0.0) + 6.0*light1;\n\t\n    if (sid>-0.5)\n    {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n\t    \n\t  \n    \/\/ lighting\n    vec3  ldif = pos - lpos;\n    float llen = length( ldif );\n    ldif \/= llen;\n\tfloat con = dot(-light1,ldif);\n\tfloat occ = mix( clamp( pos.y\/4.0, 0.0, 1.0 ), 1.0, max(0.0,nor.y) );\n\tfloat sha =  softshadow( pos, -ldif, 0.01, 5.0, 32.0 );;\n\t\t\n    float bb = smoothstep( 0.5, 0.8, con );\n    float lkey = clamp( dot(nor,-ldif), 0.0, 1.0 );\n\tvec3  lkat = vec3(1.0);\n          lkat *= vec3(bb*bb*0.6+0.4*bb,bb*0.5+0.5*bb*bb,bb).zyx;\n          lkat \/= 1.0+0.25*llen*llen;\t\t\n\t\t  lkat *= 25.0;\n          lkat *= sha;\n    float lbac = clamp( 0.1 + 0.9*dot( light2, nor ), 0.0, 1.0 );\n          lbac *= smoothstep( 0.0, 0.8, con );\n\t\t  lbac \/= 1.0+0.2*llen*llen;\t\t\n\t\t  lbac *= 4.0;\n\tfloat lamb = 1.0 - 0.5*nor.y;\n          lamb *= 1.0-smoothstep( 10.0, 25.0, length(pos.xz) );\n\t\t  lamb *= 0.25 + 0.75*smoothstep( 0.0, 0.8, con );\n\t\t  lamb *= 0.25;\n\t\t\n    vec3 lin  = 1.0*vec3(0.20,0.05,0.02)*lamb*occ;\n         lin += 1.0*vec3(1.60,0.70,0.30)*lkey*lkat*(0.5+0.5*occ);\n         lin += 1.0*vec3(0.70,0.20,0.08)*lbac*occ;\n         lin *= vec3(1.3,1.1,1.0);\n\n\t\t\n    \/\/ material\t\n\tcol = 0.5 + 0.5*vec3( cos(0.0+6.2831*sid),\t\t\n                          cos(0.4+6.2831*sid),\n                          cos(0.8+6.2831*sid) );\n    float ff = fbm( 10.0*vec3(pos.x,4.0*res.z-pos.y,pos.z)*vec3(1.0,0.1,1.0) );\t\n    col *= 0.2 + 0.8*ff;\n\t\t\n\tcol = col*lin;\n\n    vec3 spe = vec3(1.0)*occ*lkat*pow( clamp(dot( reflect(rd,nor), -ldif  ),0.0,1.0), 4.0 );\n\tcol += (0.5+0.5*ff)*0.5*spe*vec3(1.0,0.9,0.7);\n    }\n\n\t\n\tcol = sqrt( col );\n\t\n\n    \/\/ vigneting\n\tvec2 q = gl_FragCoord.xy\/iResolution.xy;\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    gl_FragColor=vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dXGR4","date":"1363057754","viewed":13955,"name":"Main Sequence Star","username":"flight404","description":"Inspired by trisomie21's 3d noise fireball, I made some tweaks and ended up with a star.\n\nEDIT: Fixed the negative sqrt issue as per iq's suggestion.","likes":124,"published":1,"tags":["3dnoise","perlin","star","corona"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0},{"id":13,"src":"\/presets\/mzk00.mp3","ctype":"music","channel":1}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ based on https:\/\/www.shadertoy.com\/view\/lsf3RH by\r\n\/\/ trisomie21 (THANKS!)\r\n\/\/ My apologies for the ugly code.\r\n\r\nfloat snoise(vec3 uv, float res)\t\/\/ by trisomie21\r\n{\r\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\r\n\t\r\n\tuv *= res;\r\n\t\r\n\tvec3 uv0 = floor(mod(uv, res))*s;\r\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\r\n\t\r\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\r\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\r\n\t\r\n\tvec4 r = fract(sin(v*1e-3)*1e5);\r\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\t\r\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\r\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\t\r\n\treturn mix(r0, r1, f.z)*2.-1.;\r\n}\r\n\r\nfloat freqs[4];\r\n\r\nvoid main(void)\r\n{\r\n\tfreqs[0] = texture2D( iChannel1, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture2D( iChannel1, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture2D( iChannel1, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture2D( iChannel1, vec2( 0.30, 0.25 ) ).x;\r\n\r\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\r\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\r\n\tfloat invRadius \t= 1.0\/radius;\r\n\t\r\n\tvec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 );\r\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\r\n\tfloat time\t\t= iGlobalTime * 0.1;\r\n\tfloat aspect\t= iResolution.x\/iResolution.y;\r\n\tvec2 uv\t\t\t= gl_FragCoord.xy \/ iResolution.xy;\r\n\tvec2 p \t\t\t= -0.5 + uv;\r\n\tp.x *= aspect;\r\n\r\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\r\n\tfloat fVal1\t\t= 1.0 - fade;\r\n\tfloat fVal2\t\t= 1.0 - fade;\r\n\t\r\n\tfloat angle\t\t= atan( p.x, p.y )\/6.2832;\r\n\tfloat dist\t\t= length(p);\r\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\r\n\t\r\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\r\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\r\n\tfor( int i=1; i<=7; i++ ){\r\n\t\tfloat power = pow( 2.0, float(i + 1) );\r\n\t\tfVal1 += ( 0.5 \/ power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\r\n\t\tfVal2 += ( 0.5 \/ power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\r\n\t}\r\n\t\r\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\r\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\r\n\tcorona\t\t\t\t*= 1.2 - newTime1;\r\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\r\n\tvec3 dir \t\t\t= vec3( 0.0 );\r\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\r\n\tvec3 starSphere\t\t= vec3( 0.0 );\r\n\t\r\n\tvec2 sp = -1.0 + 2.0 * uv;\r\n\tsp.x *= aspect;\r\n\tsp *= ( 2.0 - brightness );\r\n  \tfloat r = dot(sp,sp);\r\n\tfloat f = (1.0-sqrt(abs(1.0-r)))\/(r) + brightness * 0.5;\r\n\tif( dist < radius ){\r\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\r\n  \t\tvec2 newUv;\r\n \t\tnewUv.x = sp.x*f;\r\n  \t\tnewUv.y = sp.y*f;\r\n\t\tnewUv += vec2( time, 0.0 );\r\n\t\t\r\n\t\tvec3 texSample \t= texture2D( iChannel0, newUv ).rgb;\r\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\r\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\r\n\t\tstarSphere\t\t= texture2D( iChannel0, starUV ).rgb;\r\n\t}\r\n\t\r\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\r\n\t\/\/gl_FragColor.rgb\t= vec3( r );\r\n\tgl_FragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\r\n\tgl_FragColor.a\t\t= 1.0;\r\n}\r\n\r\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MsXGWr","date":"1367548764","viewed":13623,"name":"Mike","username":"iq","description":"Raymarching (a simplified version of) Mike's procedural distance field. Modeling and shading are pretty arbitrary, and made after the first picture you get in google image when you type his name. You can see him in 3D if you uncomment line 9.","likes":42,"published":1,"tags":["3d","raymarching","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Made with love after a famous movie character. Modeling is pretty arbitrary and was \n\/\/ done by visual inspiration from the first picture you get in google images when you \n\/\/ type \"mike wazowski\".\n\n\/\/ Uncomment the following define in order to see Mike in 3D!\n\/\/#define STEREO \n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f\/0.9375;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture2D( sa, p.yz ).xyz;\n\tvec3 y = texture2D( sa, p.zx ).xyz;\n\tvec3 z = texture2D( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/----------------------------------------------------------------\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat smin( float a, float b )\n{\n\tif( iMouse.z>0.0 && iMouse.x>gl_FragCoord.x ) return min(a,b);\n\t\n\t\n    float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n\tp.x = abs(p.x);\n\n\tvec3 q = p;\n\tq.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\tq.y *= 1.05;\n\tq.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n    float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\tfloat am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t\n\tfloat d1 = length( q ) - 0.9 + fo + fo2;\n    vec2 res = vec2( d1, 1.0 );\n\n\t\/\/ arms\n\tvec2 h = sdSegment( vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1), p );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1), p );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2 );\n\t\n\t\/\/ hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iGlobalTime);\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2), p );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2 );\n\t}\n\t\n\t\/\/ legs\n\tif( p.y<0.0 )\n\t{\n\th = sdSegment( vec3(0.5,-0.5,0.0), vec3(0.6,-1.2,0.1), p );\n\td2 = h.x - 0.14 + h.y*0.08;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(0.6,-1.2,0.1), vec3(0.5,-1.8,0.0), p );\n\td2 = h.x - 0.06;\n\tres.x = smin( res.x, d2 );\n\t}\n\n    \/\/ feet\n\tif( p.y<-1.5 )\n\t{\n\th = sdSegment( vec3(0.5,-1.8,0.0), vec3(0.6,-1.8,0.4), p );\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(0.5,-1.8,0.0), vec3(0.77,-1.8,0.35), p );\n\td2 = h.x - 0.08 + 0.02*h.y;\n\tres.x = smin( res.x, d2 );\n\th = sdSegment( vec3(0.5,-1.8,0.0), vec3(0.9,-1.8,0.2), p );\n\td2 = h.x - 0.07 + 0.02*h.y;\n\tres.x = smin( res.x, d2 );\n\t}\n\t\n\t\/\/ horns\n\tvec3 hp = p - vec3(0.0,0.8,0.0);\n\tfloat hh = -2.5*hp.x*hp.x;\n\tfloat co = cos(hh);\n\tfloat si = sin(hh);\n\thp.xy = mat2(co,si,-si,co)*hp.xy;\n\tfloat d4 = length( hp*vec3(0.3,1.0,1.0) ) - 0.19;\n\td4 *= 0.5;\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n\n\t\/\/ eyes\n\tfloat d3 = length( (p - vec3(0.0,0.25,0.35))*vec3(1.0,0.8,1.0) ) - 0.5;\n\tif( d3<res.x ) res = vec2( d3, 2.0 );\n\n\t\/\/ mouth\n\tfloat mo = length( (q-vec3(0.0,-0.35,1.0))*vec3(1.0,1.2,0.25)\/1.2 ) -0.3\/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n\n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n\n    \/\/ teeth\t\n\tif( p.x<0.3 )\n\t{\n    p.x = mod( p.x, 0.16 )-0.08;\t\n    float d5 = length( (p-vec3(0.0,-0.37,0.65))*vec3(1.0,2.0,1.0))-0.08;\n\tif( d5<res.x )\n\t\tres = vec2( d5, 2.0 );\n\t}\n\t\n\treturn vec2(res.x*0.8,res.y);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    \/\/ plane\t\n\tfloat tf = (0.0-ro.y)\/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t\/\/ mike\n\tfloat maxd = min(10.0,mint);\n\tfloat precis = 0.001;\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t\td = res.y;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<30; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n\t\tif( res<0.01 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid main(void)\n{\n\tvec2 q = gl_FragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 m = vec2(0.5);\n\t\/\/if( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n\t#ifdef STEREO\n\tfloat eyeID = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\n    #endif\n\n    \/\/-----------------------------------------------------\n    \/\/ animate\n    \/\/-----------------------------------------------------\n\t\n\tfloat ctime = iGlobalTime;\n\n\t\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*ctime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(3.5*sin(an),1.8,3.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\t#ifdef STEREO\n\tvec3 fo = ro + rd*7.0; \/\/ put focus plane behind Mike\n\tro -= 0.1*uu*eyeID;    \/\/ eye separation\n\trd = normalize(fo-ro);\n    #endif\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t\/\/ raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        \/\/ materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0\/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(0.16,0.32,0.0,0.8);\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.3,0.4,0.0), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.3,0.4,0.0), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\n\t\t}\n\t\telse if( tmat.z<2.5 )\n\t\t{\n\t\t\tvec3 q = pos-vec3(0.0,1.8,0.0) - vec3(0.0,0.44,0.35);\n\n\t\t\tfloat an2 = an + 0.015*(-1.0+2.0*noise( 6.0*iGlobalTime ));\n            vec3 oq = q;\t\t\t\n\t\t\tq.x += -2.0*0.15*clamp(sin(an2),-0.42,0.42);\n\t\t\tfloat f = length( q.xy );\n\t\t\t\n\t\t\tmate2.y = 1.0-0.3*smoothstep(0.24,0.35,length( oq.xy-vec2(0.0,0.035) ));\n\t\t\t\n\t\t\tmate = vec4(0.5,0.5,0.5,1.0);\n\t\t\tmate.xyz = mix( mate.xyz, vec3(0.6,0.4,0.3), 0.5*smoothstep(0.1,0.4,f) );\n\t\t\t\n            vec3 c1 = vec3(0.0,0.15,0.05)*(1.0-0.85*f\/0.19);\n\t\t\tfloat a = atan(q.y,q.x);\n\t\t\tc1 *= 0.3 + 5.0*fbm( 20.0*vec2(0.3*a,1.0*f) );\n\t\t\tmate.xyz = mix( mate.xyz, c1, 1.0-smoothstep( 0.18, 0.19, f ) );\n\n\t\t\toq.x += -2.0*0.19*clamp(sin(an2),-0.42,0.42);\n\t\t\tf = length( oq.xy );\n\t\t\tmate.xyz *= smoothstep( 0.07, 0.10, f );\n\t\t\t\n\t\t\tmate.w = 2.0;\n            mate2.x = 32.0;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.6,0.0);\n            mate2.x = 0.0;\n\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\t\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(0.5,0.25,0.1,0.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\n\t\t\/\/ lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), mate2.x ) );\n\t\t\n\t\t\/\/ lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\t\tlin += 1.0*spe*vec3(1.0)*occ*mate.w*dif*sha;\n\n\t\t\/\/ surface-light interacion\n\t\tcol = mate.xyz* lin + vec3(0.3)*mate.w*pow(spe,2.0)*sha;\n\t}\n\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t\/\/ vigneting\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n\n    #ifdef STEREO\t\n    col *= vec3( eyeID, 1.0-eyeID, 1.0-eyeID );\t\n\t#endif\n\n\tif( iMouse.z>0.0 )\n    {\n\tfloat f = abs(iMouse.x-gl_FragCoord.x);\n\tf = 1.0 - smoothstep( 1.0, 2.0, f );\n\tcol = mix( col, vec3(0.0), f );\n    }\n\t   \n    gl_FragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldsGWB","date":"1378824091","viewed":10831,"name":"Shiny Toy","username":"eiffie","description":"Who is more drunk, the driver, pilot, camera operator, road surveyor or coder? Up the \"Rays\" value for a better quality.","likes":62,"published":1,"tags":["pathmarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ Shiny Toy Car by eiffie\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ V2 Sedan Version: simplified car, added quadcop, bushs and the speed, lighting fix. \n\nconst int Rays=2, RaySteps=48, maxBounces=6;\/\/up the Rays value for less fuzz\nconst float fov = 4.5,blurAmount = 0.005,maxDepth=11.0,HitDistance=0.001;\nconst vec3 sunColor=vec3(1.0,0.9,0.8),sunDir=vec3(0.35,0.5,-0.35),skyColor=vec3(0.13,0.14,0.15);\nconst vec2 ve=vec2(0.0001,0.0);\nint obj=0;\nfloat tim;\nmat2 rmx;\n#define tex iChannel0\n#define time iGlobalTime*0.5\n#define size iResolution\n\nstruct material {vec3 color;float difExp,spec,specExp;};\n\nfloat smin(float a,float b,float k){return -log(exp(-k*a)+exp(-k*b))\/k;}\/\/from iq\n#define TAO 6.283\nvoid Rotate(inout vec2 v, float angle) {v*=mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvoid Kaleido(inout vec2 v,float power){Rotate(v,floor(0.5+atan(v.x,-v.y)*power\/TAO)*TAO\/power);}\n\nfloat DE(in vec3 p0){\/\/carcar\n\tp0.z+=tim;\n\tvec3 p=p0+vec3(0.0,1.24,0.0);\n\tfloat r=length(p.yz);\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\n\tr=length(p.yz);\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\n\td=max(d,-max(p.x-0.165,r-0.24));\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\n\tfloat d3=length(vec2(max(p.x-0.11,0.0),r-0.18))-0.02;\n\tif(p0.z<0.0)p.yz=p.yz*rmx;\n\telse p.yz=rmx*p.yz;\n\tKaleido(p.yz,9.0);\n\td3=min(d3,length(max(abs(p.xyz)-vec3(0.07,0.0,0.17),0.0))-0.01);\n\td=min(min(p0.y,d),min(d2,d3));\n\tif(obj<0){\n\t\tif(d==d2)obj=1;\n\t\telse if(d==d3)obj=2;\n\t\telse if(d==p0.y)obj=3;\n\t\telse obj=0;\n\t}\n\treturn d;\n}\n\nmaterial getMaterial( in vec3 p0, inout vec3 nor )\n{\/\/return material properties\n\tvec3 dif=vec3(0.0);\n\tif(obj==0){\/\/body\n\t\tif(abs(p0.y-0.6)>0.1 || abs(p0.x)>0.43 || p0.z+tim<-0.9900)dif=vec3(0.9,0.9,0.4);\n\t\treturn material(dif,pow(2.0,10.0),1.0,pow(2.0,14.0));\n\t}else if(obj==1){\/\/tire\n\t\treturn material(dif,4.0,0.75,32.0);\n\t}else if(obj==2){\/\/rim\n\t\treturn material(vec3(0.8),pow(2.0,16.0),1.0,2048.0);\n\t}else {\/\/ground\n\t\tp0.x+=(sin(p0.z*0.1)+sin(p0.z*0.13))*0.5;\n\t\tif(abs(abs(p0.x-1.0)-2.5)<0.05 || (abs(p0.x-1.0)<0.05 && fract(p0.z*0.25)<0.25))dif=vec3(1.0);\n\t\telse if(abs(p0.x-1.0)<3.25-texture2D(tex,p0.xz*0.5).r*0.2)dif=vec3(0.25);\n\t\telse dif=vec3(0.6,0.5,0.3);\n\t\tvec3 col=min(10.0,abs(p0.x))*0.01*texture2D(tex,p0.xz*0.05).rgb;\n\t\tnor=normalize(nor+col);\n\t\tdif+=col;\n\t\treturn material(dif,3.0,0.5,1024.0);\n\t}\n}\n\nfloat DEQCop(vec2 z){\n\tvec2 p=abs(z)-vec2(2.0);\n\tp*=rmx;\n\tfloat d=max(abs(p.x)-1.5,abs(p.y)-0.1);\n\tp=abs(z*mat2(0.707,-0.707,0.707,0.707));\n\td=min(d,length(p)-1.0);\n\td=min(d,max(p.x-3.0,p.y-0.1));\n\td=min(d,max(p.x-0.1,p.y-3.0));\n\treturn step(0.0,d)*0.75+0.25;\n}\n\nvec3 getBackground( in vec3 ro, vec3 rd, vec3 qcop  ){\n\tvec2 pt=vec2(rd.x+rd.z*0.6,rd.y*2.0);\n\tif(rd.y<texture2D(tex,pt).r*0.02)return vec3(0.05,0.1,0.025)+max(0.0,rd.y)*vec3(8.0,4.0,0.0);\n\tvec3 clouds=texture2D(tex,pt*0.1).rgb*0.05+texture2D(tex,pt*0.3).rgb*0.025;\n\tfloat t=1.0;\n\tif(ro!=qcop){\n\t\tt=(qcop.y-ro.y)\/rd.y;\n\t\tif(t>0.0){\n\t\t\tpt=ro.xz+rd.xz*t-qcop.xz;\n\t\t\tt=DEQCop(pt);\n\t\t}else t=1.0;\n\t}\n\n\treturn t*(clouds+skyColor+rd*0.05+sunColor*(pow(max(0.0,dot(rd,sunDir)),2.0)*0.5+pow(max(0.0,dot(rd,sunDir)),80.0)));\n}\n\nfloat BBox(vec3 p, vec3 rd, vec3 bs)\n{\n\tvec3 t0=(-bs-p)\/rd,t1=(bs-p)\/rd;\n\tvec3 n=min(t0,t1),f=max(t0,t1);\n\tfloat tmin=max(n.x,max(n.y,n.z)),tmax=min(f.x,min(f.y,f.z));\n\tif(tmin<=tmax) return tmin;\n\treturn maxDepth;\n}\n\n\/\/the code below can be left as is so if you don't understand it that makes two of us :)\n\n\/\/random seed and generator\nvec2 randv2;\nvec2 rand2(){\/\/ implementation derived from one found at: lumina.sourceforge.net\/Tutorials\/Noise.html\n\trandv2+=vec2(1.0,1.0);\n\treturn vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n \nvec3 powDir(vec3 nor, vec3  dir, float power) \/\/modified from syntopia's code\n{\/\/creates a biased random sample without penetrating the surface (approx Schlick's)\n\tfloat ddn=max(0.01,abs(dot(dir,nor)));\n\tvec2 r=rand2()*vec2(TAO,1.0);\n\tvec3 nr=(ddn<0.99)?nor:((abs(nor.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0));\n\tvec3 sdir=normalize(cross(dir,nr));\n\tr.y=pow(r.y,1.0\/power);\n\tvec3 ro= normalize(sqrt(1.0-r.y*r.y)*(cos(r.x)*sdir + sin(r.x)*cross(dir,sdir)*ddn) + r.y*dir);\n\treturn (dot(ro,nor)<0.0)?reflect(ro,nor):ro;\n}\n\nvec3 scene(vec3 ro, vec3 rd) \n{\/\/ find color of scene\n\tvec3 fcol=vec3(1.333),qcop=ro;\n\tfloat d,t=min(ro.y\/-rd.y,BBox(ro-vec3(0.0,0.22,-tim-0.33),rd,vec3(0.8,0.51,1.75)));\/\/bounding\n\tint iHitCount=0;\n\tfor(int i=0; i<RaySteps; i++ ){\/\/ march loop\n\t\tif(t>=maxDepth)continue;\n\t\tt+=d=DE(ro+t*rd);\/\/march\n\t\tif(abs(d)<HitDistance*t){\/\/hit\n\t\t\tobj=-1;\/\/turn on material mapping\n\t\t\tt+=d=DE(ro+t*rd);\/\/move closer while coloring\n\t\t\tro+=rd*t;\/\/ advance ray position to hit point\n        \t\tvec3 nor = normalize(vec3(-DE(ro-ve.xyy)+DE(ro+ve.xyy),\n\t\t\t\t-DE(ro-ve.yxy)+DE(ro+ve.yxy),\n\t\t\t\t-DE(ro-ve.yyx)+DE(ro+ve.yyx)));\/\/ get the surface normal\n\t\t\tmaterial m=getMaterial( ro, nor );\/\/and material\n\t\t\tvec3 refl=reflect(rd,nor);\/\/setting up for a new ray direction and defaulting to a reflection\n\t\t\trd=powDir(nor,refl,m.difExp);\/\/redirect the ray\n\t\t\tm.color+=mix(vec3(-0.2,0.0,0.2),vec3(0.2,0.0,-0.2),0.25+0.75*dot(rd,nor));\n\t\t\t\/\/the next line calcs the amount of energy left in the ray based on how it bounced (diffuse vs specular) \n\t\t\tfcol*=mix(m.color,vec3(1.0),min(pow(max(0.0,dot(rd,refl)),m.specExp)*m.spec,1.0));\n\t\t\tt=max(d*5.0,HitDistance);\/\/hopefully pushs thru the surface\n\t\t\tif(iHitCount++>maxBounces || dot(fcol,fcol)<0.01)t=maxDepth;\n\t\t}\n\t}\n\tif(rd.y<0.0){\/\/one more ground hit for good luck\n\t\tobj=3;\n\t\tt=ro.y\/-rd.y;\/\/calc the intersection\n\t\tro+=rd*t;\/\/ advance ray position to hit point\n        \tvec3 nor = vec3(0.0,1.0,0.0);\n\t\tmaterial m=getMaterial( ro, nor );\n\t\tvec3 refl=reflect(rd,nor);\/\/setting up for a new ray direction and defaulting to a reflection\n\t\trd=powDir(nor,refl,m.difExp);\/\/redirect the ray\n\t\tm.color+=mix(vec3(-0.2,0.0,0.2),vec3(0.2,0.0,-0.2),0.25+0.75*dot(rd,nor));\n\t\tfcol*=mix(m.color,vec3(1.0),min(pow(max(0.0,dot(rd,refl)),m.specExp)*m.spec,1.0));\t\n\t}\n\treturn fcol*getBackground(ro,rd,qcop);\/\/light the scene\n}\t\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid main() {\n\trandv2=fract(cos((gl_FragCoord.xy+gl_FragCoord.yx*vec2(1000.0,1000.0))+vec2(time)*10.0)*10000.0);\n\tvec3 clr=vec3(0.0);\n\tfor(int iRay=0;iRay<Rays;iRay++){\n\t\tfloat tim3=time+0.02*float(iRay)\/float(Rays);\n\t\ttim=tim3*tim3;\/\/14.4;\n\t\tfloat tim2=tim3*0.15;\n\t\tfloat ct=cos(tim*1.25),st=sin(tim*1.25);\n\t\tvec3 ro=vec3(cos(tim2)*vec2(sin(tim2*6.4),cos(tim2*6.4)),sin(tim2))*(6.0+3.0*sin(tim2*3.0));\n\t\tro.y=ro.y*0.2+2.5;\n\t\tfloat focusDistance=max(length(ro)-0.1,0.01);\n\t\tmat3 rotCam=lookat(-ro+texture2D(tex,vec2(tim2,tim2*1.3)).rgb*0.125+vec3(cos(tim2*0.75),sin(tim2*0.4),sin(tim2*0.6))*0.5,vec3(0.0,1.0+cos(tim2*25.0)*0.125,0.125*sin(tim2*25.0)));\n\t\tro.z-=tim;\n\t\trmx=mat2(ct,st,-st,ct);\n\t\tvec2 pxl=(-size.xy+2.0*(gl_FragCoord.xy+rand2()))\/size.y;\n\t\tvec3 er = normalize( vec3( pxl.xy, fov ) );\n\t\tvec3 go = blurAmount*focusDistance*vec3( -1.0 + 2.0*rand2(), 0.0 );\n       \tvec3 gd = normalize( er*focusDistance - go );gd.z=0.0;\n\t\tclr+=scene(ro+rotCam*go,normalize(rotCam*(er+gd)));\n\t}\n\tclr\/=vec3(Rays);\n\tgl_FragColor = vec4(sqrt(clr)*1.4-0.25,1.0);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/sorry, couldn't help myself\n\/*float sawtooth(float time){return fract(time)-0.5;}\n\nvec2 mainSound(float time)\n{\n    return vec2( sawtooth(time*time) );\n}*\/\n\/\/v2 with LOTS of gears\nfloat saw(float time){return clamp(fract(time)*2.0-1.0,-0.5,0.5);}\nvec2 mainSound(float time)\n{\n    float t=pow(time+1.0,0.75);\n    t=mod(t,2.0)+1.0+floor(t*0.25+0.5);\n    t=pow(t,4.0);\n    return vec2( saw(t),saw(t+sin(time)) )*0.2;\n}\n","name":"","description":"","type":"sound"}]}]