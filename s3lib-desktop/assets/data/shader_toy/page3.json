[{"ver":"0.1","info":{"id":"ld2SRw","date":"1410543198","viewed":51,"name":"my first ray tracer :)","username":"Spaceoff","description":"Just slowly trying to figure this shit out.\nWriting my working out as I go, just in case it's ever helpful to someone (or me, after I forget it all again).","likes":0,"published":1,"tags":["3d","test","ray","casting","noobish"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"const float pi = 3.14159, two_pi = pi*2.0, half_pi = pi\/2.0;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0), white = vec4(1.0),\n\tred   =  vec4(1.0, 0.0, 0.0, 1.0),\n    green =  vec4(0.0, 1.0, 0.0, 1.0),\n    blue  =  vec4(0.0, 0.0, 1.0, 1.0);\n\n\nstruct Ray { vec3 o, d; };\nstruct Sphere { vec3 o; float r; vec4 col; };\nstruct YPlane { float y; vec4 col; };\nstruct Collision { Ray r; float t; vec3 o; vec4 col; };\nstruct Light { vec3 o; float str; vec4 col; };\n\n\nCollision iSphere(in Ray r, in Sphere s)\n{\n\/*\nRo = ray origin, Rd = ray direction\nt = arbitrary scalar multiplier for ray\nray, Ro + tRd\n\nSo = sphere origin, r = sphere radius\nP = arbitrary point on sphere\n|P-So| = r\n(P-So)^2 = r^2\nP.P - 2P.So +So.So = r^2\nP.P = r^2 + 2P.So -So.So\n|P|^2 = P.P\n\nFor simplicity, So = 0, Rso = Ro - So\nP.P = r^2\n\nIntersection:\nRso + tRd = P\n(Rso + tRd)^2 = P^2 = |P|^2 = P.P = r^2\nRso(Rso + tRd) + tRd(Rso + tRd) = r^2\nRso.Rso + tRso.Rd + tRso.Rd + (t^2)Rd.Rd - r^2 = 0\nRd.Rd(t^2) + (2Rso.Rd)t + (Rso.Rso - r^2) = 0\nin quadratic form, ax^2 +bx +c = 0\n\ta = Rd.Rd, Rd is a unit vector thus |Rd|=1 thus |Rd|^2=1\n\ta = 1\n\tb = 2Rso.Rd\n\tc = Rso.Rso -r^2\n\nt = (-b +\/- sqrt(b^2 -4ac))\/2a\nroot = b^2 -4ac\nif root < 0, no real roots thus no intersection\nif root = 0, one intersection.\notherwise 2.\nThe closest intersection (smallest t value) is what's needed (duh).\nAs the root is always positive for 2 intersections, can choose always-smaller root:\n\t(-b -sqrt(root))\/2a\n\n*\/\n    vec3 Rso = r.o - s.o;\n    \n    const float a = 1.0;\n    float b = 2.0*dot(Rso, r.d);\n    float c = dot(Rso, Rso) -s.r*s.r;\n    float root = b*b - 4.0*a*c;\n    if (root < 0.0)\n    {\n        return Collision(r, -1.0, r.o, black);;\n    }\n    else\n    {\n        return Collision(r, (-b -sqrt(root))\/(2.0*a), s.o, s.col);\n        \/\/ return Collision(1.0, s.col);\n    }\n}\n\nCollision iYPlane(in Ray r, in YPlane p)\n{\n\/*\nplane: y = p.y\nray: Ro + tRd\n\nintersect:\nRo.y + tRd.y = p.y\n\ntRd.y = p.y -Ro.y\nt = (p.y -Ro.y)\/Rd.y\n*\/\n    float t = (p.y - r.o.y)\/r.d.y;\n    vec3 off = vec3(r.o + t*r.d);\n    return Collision(r, t, off, p.col);\n}\n\n\/\/ Collision castShadowRay(in Ray r)\n\nCollision castRay(in Ray r)\n{\n    float xs = sin(-0.5*4.0), ys = cos(-1.0*4.0);\n    Sphere s1 = Sphere(vec3(0.0, 1.5, 0.0), 1.5, red),\n        s2 = Sphere(vec3(5.0, 3.5, -7.0), 2.5, blue),\n        s3 = Sphere(vec3(-4.0*xs, 0.5, -3.0*ys), 0.5, red+green);\n    const YPlane p = YPlane(0.0, green);\n    Collision colmin = iSphere(r, s1);\n    \n    Collision colcur = iSphere(r, s2);\n    if ((colcur.t >= 0.0) && (colcur.t < colmin.t || colmin.t < 0.0))\n        colmin = colcur;\n   \t\n    colcur = iSphere(r, s3);\n    if ((colcur.t >= 0.0) && (colcur.t < colmin.t || colmin.t < 0.0))\n        colmin = colcur;\n    \n    colcur = iYPlane(r, p);\n    if ((colcur.t >= 0.0) && (colcur.t < colmin.t || colmin.t < 0.0))\n        colmin = colcur;\n\t\n    return colmin;\n}\n\nvec4 castShadowRay(in Collision c, in float ambiance)\n{\n    float xs = sin(iGlobalTime), ys = -cos(iGlobalTime);\n    \n    Light l = Light(vec3(-8.0*xs, 6.0, -5.0*ys), 5.0, white);\n    float rel_ambiance = 1.0\/c.t;\n        \n    vec3 ray_orig = c.r.o + c.t*c.r.d;\n    \n    vec3 ray_dif = l.o - ray_orig;\n    vec3 ray_dir = normalize(ray_dif);\n    Ray r = Ray(ray_orig + (ray_dir*0.001), ray_dir);\n    Collision lc = castRay(r);\n    \n    float ang_f = ambiance + (1.0-ambiance)*dot(normalize(ray_orig-c.o), r.d); \/\/ 90' away from src = darker\n    float str = ((l.str+rel_ambiance)\/length(ray_dif))*ang_f;\n    \n    vec4 col_v = (l.col*(ang_f)*0.5 + c.col*(1.5-ang_f))*str;\n    if (lc.t < 0.0)\n    {\n        return col_v;\n\t}\n    else\n    {\n        float blur = min(lc.t, 1.0);\n        return (col_v)*blur + (white*ambiance)*(rel_ambiance)*(1.0-blur);\n    }\n}\n\nvec4 trace(in Ray r, in float ambiance)\n{\n    return castShadowRay(castRay(r), ambiance);\n}\n\nvoid main(void)\n{\n    vec2 res_distort = normalize(iResolution.xy);   \/\/ To adjust distortion caused by width\/height ratio\n\tvec2 uv = ((gl_FragCoord.xy \/ iResolution.xy) * 2.0 - 1.0) * res_distort;\n    \n\tgl_FragColor = black;\n    \n    vec3 camera_orig = vec3(2.0, 1.5, 6.0);\n    vec3 camera_dir = vec3(-.05, -0.1, -1.0);\n    \n    \/\/ vec2 mouse_dir = (2.0*(iMouse.xy\/iResolution.xy) - 1.0)*res_distort;\n    \/\/ vec3 mouse_3dir = vec3(-mouse_dir.x, 0.0, mouse_dir.y);\n    vec3 mouse_3dir = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ray_orig = vec3(0.0, 0.0, 0.0) + camera_orig;\n    vec3 ray_dir = vec3(uv, 0.0) + camera_dir + mouse_3dir;\n    \n    vec3 dir_off = vec3(0.5\/iResolution.xy, 0.0);\n    \n    float a = 0.3; \/\/ambiance\n    \n    \n    \/\/ Cheap hacky 2xMSAA\n    Ray r1 = Ray(ray_orig, normalize(ray_dir)),\n    \tr2 = Ray(ray_orig, normalize(vec3(ray_dir.x+dir_off.x, ray_dir.yz))),\n        r3 = Ray(ray_orig, normalize(vec3(ray_dir.x-dir_off.x, ray_dir.yz))),\n        r4 = Ray(ray_orig, normalize(vec3(ray_dir.x, ray_dir.y+dir_off.y, ray_dir.z))),\n        r5 = Ray(ray_orig, normalize(vec3(ray_dir.x, ray_dir.y-dir_off.y, ray_dir.z))),\n        r6 = Ray(ray_orig, normalize(vec3(ray_dir.x+dir_off.x, ray_dir.y+dir_off.y, ray_dir.z))),\n        r7 = Ray(ray_orig, normalize(vec3(ray_dir.x+dir_off.y, ray_dir.y-dir_off.y, ray_dir.z))),\n        r8 = Ray(ray_orig, normalize(vec3(ray_dir.x-dir_off.x, ray_dir.y+dir_off.y, ray_dir.z))),\n        r9 = Ray(ray_orig, normalize(vec3(ray_dir.x-dir_off.y, ray_dir.y-dir_off.y, ray_dir.z)));\n\n\tgl_FragColor = (trace(r1,a)*2.0\n                   + trace(r2,a) + trace(r3,a) + trace(r4,a) + trace(r5,a)\n                   + trace(r6,a) + trace(r7,a) + trace(r8,a) + trace(r9,a))\/10.0;\n\t\n    \/*\n    Ray r = Ray(ray_orig, normalize(ray_dir));\n    gl_FragColor = trace(r, 0.1);\n\t*\/\n    \n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdjXRm","date":"1410530438","viewed":98,"name":"50 shades of grey","username":"goffmog","description":"Well ok, 48 shades of grey + black + white","likes":0,"published":1,"tags":["nsfw","50shadesofgrey"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"void main(void)\n{\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n    float col = 0.02 * floor(uv.x \/ 0.02);\n\tgl_FragColor = vec4(col,col,col,1);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsSXzw","date":"1410491649","viewed":113,"name":"Reproduction III","username":"yonatan","description":"M. C. Escher's \"Cubic Space Division\"","likes":0,"published":1,"tags":["raymarching","escher"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ raymarcher from https:\/\/www.shadertoy.com\/view\/XsB3Rm\n\n\/\/ ray marching\nconst int max_iterations = 80;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.0001;\nconst float clip_far = 1000.0;\n\n\/\/ math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI \/ 180.0;\n\n\n\/\/ get distance in the world\nfloat dist_field(vec3 p) {\n    p = mod(p, 8.0) - 4.0;\n    p = abs(p);\n    float cube = length(max(p - 1.0, 0.0));\n    \/\/return cube;\n    float xd = max(p.y,p.z);\n    float yd = max(p.x,p.z);\n    float zd = max(p.x,p.y);\n    float beams = min(zd, min(xd, yd)) - 0.25;\n    \/\/return beams;\n    return min(beams, cube);\n}\n\/\/ phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\tvec3 light_pos   = vec3( 100.0 * cos(iGlobalTime*0.2), 200.0 * sin(iGlobalTime*0.4), 20.0 );\n\tvec3 light_color = vec3( 0.2 );\n\tvec3 vl = normalize( light_pos - v );\n\tfloat diffuse  = abs(dot( vl, n ) );\n\treturn light_color * diffuse; \n}\n\n\/\/ get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n\/\/ ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n\/\/ get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\/\/ camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid main(void)\n{\n\t\/\/ default ray dir\n\tvec3 dir = ray_dir( 35.0, iResolution.xy, gl_FragCoord.xy );\n\t\n\t\/\/ default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 10.0 );\n\n\t\/\/ rotate camera\n\tmat3 rot = rotationXY( vec2( iGlobalTime * 0.13, iGlobalTime * 0.19 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n    eye.z -=  mod(iGlobalTime * 4.0, 8.0);\n    eye.y = eye.x = 0.0;\n\t\n\t\/\/ ray marching\n\tfloat depth = ray_marching( eye, dir, 3.75, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tgl_FragColor = vec4(1.0);\n    } else {\n\t\t\/\/ shading\n\t\tvec3 pos = eye + dir * depth;\n\t\tvec3 n = gradient( pos );\n\t\tgl_FragColor = vec4( shading( pos, n, eye ) , 1.0 );\n        gl_FragColor += depth\/clip_far * 12.0;\n    }\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsjSzw","date":"1410466273","viewed":64,"name":"sound-input-one","username":"cybero","description":"soundinputone, experimental rework of iq's sound input example https:\/\/www.shadertoy.com\/view\/Xds3Rr#","likes":0,"published":1,"tags":["soundinputone"],"hasliked":0},"renderpass":[{"inputs":[{"id":20,"src":"\/presets\/mzk03.mp3","ctype":"music","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 Distort(vec2 p)\n{\n    float theta  = atan(p.y, p.x);\n    float radius = length(p);\n    radius = pow(radius, 1.3);\n    p.x = radius * cos(theta);\n    p.y = radius * sin(theta);\n    return 0.5 * (p + 1.0);\n}\nvec4 pattern(vec2 p)\n{\n\tvec2 m=mod(p.xy+p.x+p.y,2.)-1.;\n\treturn vec4(length(m+p*0.1));\n}\n\nfloat hash(const float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise(const vec3 x)\n{\n\tvec3 p=floor(x);\n\tvec3 f=fract(x);\n\n    \tf=f*f*(3.0-2.0*f);\n\n    \tfloat n=p.x+p.y*57.0+p.z*43.0;\n\n    \tfloat r1=mix(mix(hash(n+0.0),hash(n+1.0),f.x),mix(hash(n+57.0),hash(n+57.0+1.0),f.x),f.y);\n    \tfloat r2=mix(mix(hash(n+43.0),hash(n+43.0+1.0),f.x),mix(hash(n+43.0+57.0),hash(n+43.0+57.0+1.0),f.x),f.y);\n\n\treturn mix(r1,r2,f.z);\n}\nvoid main(void)\n{\n    \/\/ create pixel coordinates\n\tvec2 uv = (gl_FragCoord.xy \/ (iResolution.xy \/ 0.4));\n\t\/\/added by cybero\n\tfloat off = noise(uv.xyx + iGlobalTime);\n    vec4 c = pattern(Distort(uv*off));\n    c.xy = Distort(c.xy);\n\t\/\/ first texture row is frequency data\n\tfloat fft  = texture2D( iChannel0, vec2(uv.x,0.25) ).x; \n\t\n    \/\/ second texture row is the sound wave\n\tfloat wave = texture2D( iChannel0, vec2(uv.x,0.75) ).x;\n\t\n\t\/\/ convert frequency to colors\n\tvec3 col = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n    \/\/ add wave form on top\t\n\tcol += 1.0 -  smoothstep( 0.0, 0.15, abs(wave - uv.y) );\n\t\n\t\/\/ output final color\n\tgl_FragColor = vec4(col.x * off, pow(sin(c.y) - off, 0.5), pow(cos(c.z), 3.0), 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsSXzD","date":"1410462817","viewed":18559,"name":"E1M1 - Hangar","username":"P_Malin","description":"The start area of Doom E1M1.\nHold down the mouse button and drag the mouse to move.\nWhere you click relative to the center of the screen sets the view direction.\n\nAlso, check out Reinder's excellent Doom2 shader: https:\/\/www.shadertoy.com\/view\/lsB3zD","likes":25,"published":1,"tags":["doom","e1m1","hangar"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ E1M1 - Hangar\n\/\/ by @P_Malin\n\n\/\/ Procedural version of Doom E1M1\n\n\/\/ The start area of Doom E1M1.\n\/\/ Click and drag the mouse to move.\n\/\/ Where you click relative to the center of the screen sets the view direction.\n\n\/\/ Also, check out Reinder's excellent Doom2 shader: https:\/\/www.shadertoy.com\/view\/lsB3zD\n\n\/\/ The sectors we draw by default\n#define ENABLE_NUKAGE_SECTORS\n#define ENABLE_START_SECTORS\n\n\/\/ Adding this compiles with \"Unknown Error\" on some machines. Uncomment if you are feeling lucky.\n\/\/#define ENABLE_SECTOR_31\n\n\/\/ Some additional sectors, may need to comment out some of the default ones\n\/\/#define ENABLE_EXTRA_NUKAGE_SECTORS\n\/\/#define ENABLE_MISC_SECTORS\n\n#define ENABLE_SPRITES\n\n#define DEMO_CAMERA\n#define INTRO_EFFECT\n#define DRAW_SKY\n#define HEAD_BOB\n\n#define PIXELATE_IMAGE\n#define QUANTIZE_FINAL_IMAGE\n#define QUANTIZE_TEXTURES\n#define PIXELATE_TEXTURES\n\n\/\/#define DRAW_COMPASS\n\n\/\/ Add walls to close entrances to sectors we are not rendering\n#ifndef ENABLE_EXTRA_NUKAGE_SECTORS\n\t#define CLOSE_NUKAGE_SECTOR\n#endif\n#ifndef ENABLE_SECTOR_31\n\t#define CLOSE_START_SECTOR\n#endif\n\n#define FAR_CLIP 10000.0\n\nconst vec2 vFakeResolution = vec2(320.0, 240.0);\n\nconst float kDepthFadeScale = (1.0 \/ 3500.0);\nconst float kExtraLight = 0.0;\n\n\/\/ Light level adjustment to East-West and North-South walls\nconst float kC = (1.0 \/ 16.0);\n\nvec3 SampleTexture( const in float fTexture, const in vec2 vUV );\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo );\nfloat hash(float p);\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    const float kFOV = 1.8;\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * kFOV);\n\n\treturn vDir;\n}\n\nvec3 Quantize( const in vec3 col )\n{\n\treturn floor( col * 48.0 + 0.5 ) * (1.0 \/ 48.0);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    \/\/return cross( vec3(vA, 0.0), vec3(vB, 0.0) ).z;\n  \treturn vA.x * vB.y - vA.y * vB.x;\n\n    \/\/return dot(vA * vB.yx, vec2(1.0, -1.0)); \n}\n\nvec3 g_vRayOrigin;\nvec3 g_vRayDir;\nvec2 g_vSpriteDir;\n\nvoid BeginSector( out vec4 vSectorState, const in vec2 vSectorHeights )\n{\n    \/\/ store the infinite floor-ceiling plane intersect depth in vSectorState.xy\n    vSectorState.xy = (vSectorHeights - g_vRayOrigin.y) \/ g_vRayDir.y;   \n    vSectorState.zw = vec2(0.0);\n}\n\n\/\/ Intersect a sidedef that meets another sector with the same floor and ceiling height\nvoid Null( inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n   \tif((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n    \tvSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n    }\n}\n\nvoid Wall( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in float fTexture )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n\n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {        \n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * fLen, fHitY, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nvoid Open( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in int iUpperHeight, const in float fLowerTexture, const in float fUpperTexture )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    float fLowerHeight = float(iLowerHeight);\n\t\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\nvoid Upper( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iUpperHeight, const in float fUpperTexture )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( fHitY < vSectorHeights.y )\n            {           \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\n\nvoid Lower( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in float fLowerTexture )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fLowerHeight = float(iLowerHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( fHitY > vSectorHeights.x )\n            {           \n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n            }\n        }\n    }\n}\n\nvoid EndSector( inout float fClosestT, inout vec4 vHitInfo, in vec4 vSectorState, const in float fLightLevel, const in vec2 vFloorCeilingTextures )\n{\n    \/\/ Test the even-odd state of our sector floor\/ceiling in-out values\n    vec2 vInOutTest = fract( vSectorState.zw * 0.5 ) * 2.0;\n\n    if( fClosestT > vSectorState.x )\n    {\n        if((vInOutTest.x > 0.5) && (vSectorState.x > 0.0))\n        {\n            vec3 vFloorPos = g_vRayOrigin + g_vRayDir * vSectorState.x;        \n            if( g_vRayOrigin.y > vFloorPos.y )\n            {\n                fClosestT = vSectorState.x;\n                vHitInfo = vec4( vFloorPos.xz, fLightLevel, vFloorCeilingTextures.x);\n            }\n        }\n    }\n\n    if( fClosestT > vSectorState.y )\n    {\n        if((vInOutTest.y > 0.5) && (vSectorState.y > 0.0))\n        {\n            vec3 vCeilingPos = g_vRayOrigin + g_vRayDir * vSectorState.y;        \n            if( g_vRayOrigin.y < vCeilingPos.y )\n            {\n                fClosestT = vSectorState.y;\n                vHitInfo = vec4( vCeilingPos.xz, fLightLevel, vFloorCeilingTextures.y);\n            }\n        }            \n    }\n}\n\n#ifdef ENABLE_SPRITES\n\nvoid Sprite( out float fClosestT, out vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, vec2 vSize, float fLightLevel, float fTexture )\n{\n\tvec3 vPos = vec3(iX, iY, iZ);\n\tfClosestT = FAR_CLIP;\n\tvHitInfo = vec4(0.0);\n\tvec2 vA = vPos.xz - vSpriteDir * 0.5 * vSize.x;\n\tvec2 vB = vPos.xz + vSpriteDir * 0.5 * vSize.x;\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n    float rcpdenom = 1.0 \/ Cross2d( g_vRayDir.xz, vD ); \n    float fHitT = Cross2d( vOA, vD ) * rcpdenom;\n\n    if(fHitT > 0.0)\n    {\n\t    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * rcpdenom;\n        if((fHitU >= 0.0) && (fHitU < 1.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( (fHitT < fClosestT) && (fHitY > vPos.y) && (fHitY < (vPos.y + vSize.y)) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * vSize.x, fHitY - vPos.y, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nbool MaskBarrel(vec2 vTexCoord)\n{\n\tvec2 vSize = vec2(23.0, 32.0);\n\t\n\tvTexCoord = floor(vTexCoord);\n\t\n\t\/\/ remove corner pixels\n\tvec2 vWrapCoord = fract((vTexCoord + vec2(2.0, 1.0) ) \/ vSize) * vSize;\n\t\n\treturn ( (vWrapCoord.x >= 4.0) || (vWrapCoord.y >= 2.0) );\n}\n\n\nvec4 CosApprox( vec4 x )\n{\n\tx = abs(fract(x * (0.5))*2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn( ( x2 * 3.0) - ( 2.0 * x2*x) );\n}\n\nbool MaskCorpseSprite(vec2 vTexCoord)\n{\n\t\/\/vTexCoord = floor(vTexCoord);\n    \n    vec2 vUV = vTexCoord.xy \/ vec2(57.0, 22.0);\n    vec2 vOffset = vUV;\n    vOffset = vOffset * 2.0 -vec2(1.0, 0.8);\n    float fDist = dot(vOffset, vOffset);\n    fDist += dot(CosApprox(vTexCoord.xyxy * vec4(0.55, 0.41, 0.25, 0.1)), vec4(0.2 * -vOffset.y));\n\treturn fDist < 0.4;\n}\n\n#define TEX_BAR1A 32.0\n#define TEX_PLAYW 33.0\n\nvoid BarrelSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(23.0, 32.0), fLightLevel, TEX_BAR1A);\n\t\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskBarrel(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n\nvoid CorpseSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(57.0, 22.0), fLightLevel, TEX_PLAYW );\n\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskCorpseSprite(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n#endif\n\nvoid main(void)\n{\n\tvec2 vOrigUV = gl_FragCoord.xy \/ iResolution.xy;\n    \n    #ifdef PIXELATE_IMAGE\n    vec2 vUV = floor(vOrigUV * vFakeResolution + 0.5) * (1.0 \/ vFakeResolution);\n    #else\n    vec2 vUV = vOrigUV;\n    #endif\n    \n\tvec3 vCameraPos = vec3(0.0);\n\tvec3 vCameraTarget = vec3(0.0);\n        \n    vec2 vMouse = (iMouse.xy \/ iResolution.xy);\n\t\n\tconst vec2 vStart = vec2(1050, -3616);\n\n\tif(iMouse.z > 0.0)\n    {\n        vec2 vDir = normalize((abs(iMouse.zw) \/ iResolution.xy) - 0.5);\n        vec2 vOffset = (iMouse.xy - abs(iMouse.zw)) \/ iResolution.xy;\n\t\tvCameraPos.y = 30.0;\n    \tvCameraPos.xz = (vDir.yx * vec2(1.0, -1.0) * vOffset.x + vDir * vOffset.y) * 5000.0;\n        vCameraPos.xz += vStart;\n        vCameraTarget.xz = vCameraPos.xz + vDir * 10.0;\n\t    vCameraTarget.y = vCameraPos.y;\n    }\n    else\n    {\n        vCameraPos = vec3(1050, 30, -3616);\n        vCameraTarget = vec3(1050, 30, -3500);\n\n        #ifdef DEMO_CAMERA\n        float fCamTime = iGlobalTime - 5.0;\n        if(fCamTime > 0.0) fCamTime = mod(fCamTime, 33.0 - 5.0) + 5.0;\n        if(iGlobalTime==10.0) fCamTime = 0.0; \/\/ hack for shadertoy preview screen\n        vCameraTarget = mix( vCameraTarget, vec3(1834, 30, -3264), smoothstep(5.0, 10.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(1280, 30, -3350), smoothstep(8.0, 13.0, fCamTime));\n        \n        vCameraTarget = mix( vCameraTarget, vec3(1280, 30, -2976), smoothstep(11.0, 16.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(1280, 30, -2976), smoothstep(13.0, 19.0, fCamTime));\n        \n        vCameraTarget = mix( vCameraTarget, vec3(768, 30, -3050), smoothstep(16.0, 20.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(832, 30, -3020), smoothstep(19.0, 23.0, fCamTime));\n\n        vCameraTarget = mix( vCameraTarget, vec3(1256, 30, -3648), smoothstep(20.0, 25.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(768, 30, -3424), smoothstep(23.0, 28.0, fCamTime));\n        \n        vCameraPos = mix( vCameraPos, vec3(1050, 30, -3616), smoothstep(25.0, 30.0, fCamTime));\n        vCameraTarget = mix( vCameraTarget, vec3(1050, 30, -3500), smoothstep(28.0, 33.0, fCamTime));\n        #endif\n    }\n    \n    #ifdef HEAD_BOB\n\tfloat fBob = sin(length(vCameraPos.xz - vStart) * 0.04) * 4.0; \/\/ head bob\n    vCameraPos.y += fBob;\n    vCameraTarget.y += fBob;\n    #endif\n\n    vec2 vWindowCoord =\t(vUV * 2.0 - 1.0) * vec2(iResolution.x \/ iResolution.y, 1.0);\n\t\n    g_vRayOrigin = vCameraPos;\n    g_vRayDir = GetCameraRayDir( vWindowCoord, vCameraPos, vCameraTarget );\n    \n    vec4 vHitInfo;\n    float fClosestT;\n\tfloat fNoFog = 0.0;\n\n\t\n    MapIntersect( fClosestT, vHitInfo );\n\n\tvec3 vForwards = normalize(vCameraTarget - vCameraPos); \n\n    #ifdef ENABLE_SPRITES\n\tvec2 vSpriteDir = -normalize(vec2(-vForwards.z, vForwards.x));\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1088, 0, -2944, 0.565);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 864, 0, -3328, 0.565);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1312, -16, -3264, 0.878);\n    CorpseSprite(fClosestT, vHitInfo, vSpriteDir, 1024, -16, -3264, 0.878);\n    #endif\t\n\t\n\tvHitInfo.z = clamp(vHitInfo.z + kExtraLight, 0.0, 1.0);\n\n    \/\/ sky\n    #ifdef DRAW_SKY\n    float fDoSky = step(0.9, vHitInfo.w) * step(vHitInfo.w, 1.1);\n    \n    fNoFog = max(fNoFog, fDoSky);\n    float fSkyU = (atan(vForwards.x, vForwards.z) * 512.0 \/ radians(180.0)) + vUV.x * 320.0;\n    float fSkyV = vUV.y * 240.0;\n    vHitInfo = mix(vHitInfo, vec4(fSkyU, fSkyV, 1.0, 1.0), fDoSky);\n    #endif\n    \n    \/\/ fade in effect\n\t#ifdef INTRO_EFFECT\n    float fEffectOffset = max(iGlobalTime - 1.0, 0.0) - hash(vUV.x);\n    vec2 vEffectUV = vUV;\n    vEffectUV.y += clamp(fEffectOffset, 0.0, 1.0);\n    \n    float fDoEffect = step(vEffectUV.y, 1.0);       \n    vHitInfo = mix(vHitInfo, vec4(vEffectUV * 128.0, 1.0, 3.0), fDoEffect);\n    fNoFog = max(fNoFog, fDoEffect);\n    #endif    \n\n    float fLightLevel = clamp( vHitInfo.z, 0.0, 1.0 );\n    float fDepth = dot(g_vRayDir, vForwards) * fClosestT;\n    float fDepthFade = fDepth * kDepthFadeScale;\n    float fApplyFog = 1.0 - fNoFog;\n    fLightLevel = clamp( fLightLevel - fDepthFade * fApplyFog, 0.0, 1.0 );\n    \n    vec3 vResult = SampleTexture( vHitInfo.w, vHitInfo.xy ) * fLightLevel;\n    \n    vResult = clamp(vResult * 1.2, 0.0, 1.0);\n    \n    #ifdef QUANTIZE_FINAL_IMAGE\n    vResult = Quantize(vResult);\n    #endif\n    \n    #ifdef DRAW_COMPASS\n    \/\/ a hack - assume we have never clicked the mouse before if coordinate is zero\n    if((iMouse.x > 0.5) && (iMouse.y > 0.5))\n    {\n        if(iMouse.z <= 0.0)\n        {\n            vec2 vCompassUV = vOrigUV - 0.5;\n            vCompassUV.x *= iResolution.x \/ iResolution.y;\n            float fDistNS = ((abs(vCompassUV.x) * 10.0) + abs(vCompassUV.y) - 0.05);\n            float fDistEW = ((abs(vCompassUV.y) * 10.0) + abs(vCompassUV.x) - 0.025);\n            float fDistCircle = abs(0.045 - length(vCompassUV)) * 10.0;\n            float fDist = min(min(fDistNS, fDistEW), fDistCircle);\n            \n            float fAmount = clamp(fDist * 20.0, 0.0, 1.0);\n            float fCol = step(fract((floor(vCompassUV.x) + floor(vCompassUV.y)) * 0.5), 0.25);\n            vResult = mix(vec3(fCol * 0.75 + 0.25), vResult, fAmount);\n        }\n    }\n    #endif\n    \n\tgl_FragColor = vec4(vResult, 1.0);\n}\n\n\/\/ Generated code follows\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\/\/ Textures\n#define TEX_X 0.0\n#define TEX_F_SKY1 1.0\n#define TEX_NUKAGE3 2.0\n#define TEX_FLOOR7_1 3.0\n#define TEX_FLAT5_5 4.0\n#define TEX_FLOOR4_8 5.0\n#define TEX_CEIL3_5 6.0\n#define TEX_TLITE6_4 7.0\n#define TEX_FLAT14 8.0\n#define TEX_FLOOR7_2 9.0\n#define TEX_STEP2 10.0\n#define TEX_TLITE6_1 11.0\n#define TEX_DOOR3 12.0\n#define TEX_LITE3 13.0\n#define TEX_STARTAN3 14.0\n#define TEX_BROWN1 15.0\n#define TEX_DOORSTOP 16.0\n#define TEX_COMPUTE2 17.0\n#define TEX_STEP6 18.0\n#define TEX_BROWN144 19.0\n#define TEX_SUPPORT2 20.0\n#define TEX_STARG3 21.0\n#define TEX_DOORTRAK 22.0\n#define TEX_SLADWALL 23.0\n#define TEX_TEKWALL4 24.0\n#define TEX_SW1COMP 25.0\n#define TEX_BIGDOOR2 26.0\n\n\/\/ Sectors\n\nvoid Sector0( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-80.0, 216.0);\n\n    BeginSector( vSS, vSH );\n    Lower( fT, vInf, vSS, 1520, -3168, 1672, -3104, 164, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1672, -3104, 1896, -3104, 224, fLt-kC, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1896, -3104, 2040, -3144, 149, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 2040, -3144, 2128, -3272, 155, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 2128, -3272, 2064, -3408, 150, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 2064, -3408, 1784, -3448, 282, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1784, -3448, 1544, -3384, 248, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1544, -3384, 1520, -3168, 217, fLt, vSH, -56, TEX_BROWN144 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_NUKAGE3, TEX_F_SKY1) );\n}\n\nvoid Sector1( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 216.0);\n\t\/\/ merge walls from ultimate doom secret\n\n    BeginSector( vSS, vSH );\n    Open( fT, vInf, vSS, 1376, -3200, 1376, -3104, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1376, -3360, 1376, -3264, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Wall( fT, vInf, vSS, 1376, -3264, 1376, -3200, 64, fLt+kC, vSH, TEX_STARTAN3);\n\tWall( fT, vInf, vSS, 1376, -3104, 1376, -2944, 160, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1376, -2944, 1472, -2880, 115, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1856, -2880, 1920, -2920, 75, fLt, vSH, TEX_STARTAN3);\n    Null( vSS, 1520, -3168, 1672, -3104 );\n    Null( vSS, 1672, -3104, 1896, -3104 );\n    Null( vSS, 1896, -3104, 2040, -3144 );\n    Null( vSS, 2040, -3144, 2128, -3272 );\n    Null( vSS, 2128, -3272, 2064, -3408 );\n    Null( vSS, 2064, -3408, 1784, -3448 );\n    Null( vSS, 1784, -3448, 1544, -3384 );\n    Null( vSS, 1544, -3384, 1520, -3168 );\n    Wall( fT, vInf, vSS, 2736, -3360, 2736, -3648, 288, fLt+kC, vSH, TEX_STARTAN3);\n#ifdef CLOSE_NUKAGE_SECTOR\n    Wall( fT, vInf, vSS, 2736, -3648, 1376, -3648, 2736-1376, fLt, vSH, TEX_STARTAN3  );\n#else\n\tNull( vSS, 2736, -3648, 2240, -3648 );\n    Null( vSS, 2240, -3648, 1984, -3648 );\n    Null( vSS, 1984, -3648, 1376, -3648 );\n#endif \n    Wall( fT, vInf, vSS, 2240, -2920, 2272, -3008, 93, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 2272, -3008, 2432, -3112, 190, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 2432, -3112, 2736, -3112, 304, fLt-kC, vSH, TEX_STARTAN3);\n    Open( fT, vInf, vSS, 2736, -3112, 2736, -3360, 248, fLt+kC, vSH, 0, 136, TEX_STARTAN3, TEX_STARTAN3 );\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1376, -3648, 1376, -3360, 3648-3360, fLt+kC, vSH, TEX_STARTAN3);\n\t\/\/Wall( fT, vInf, vSS, 1376, -3648, 1376, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1376, -3392, 1376, -3360, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1376, -3520, 1376, -3392, 128, fLt+kC, vSH, TEX_STARTAN3);\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1472, -2880, 1856, -2880, 1856-1472, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1472, -2880, 1664, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1664, -2880, 1856, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n\t\n\t\/\/ Merge walls\n    Wall( fT, vInf, vSS, 1920, -2920, 2240, -2920, 2240-1920, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1920, -2920, 2176, -2920, 256, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 2176, -2920, 2240, -2920, 64, fLt-kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid Sector3( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 1344, -3264, 1344, -3360 );\n    Null( vSS, 1376, -3360, 1376, -3264 );\n    Wall( fT, vInf, vSS, 1344, -3264, 1376, -3264, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    Wall( fT, vInf, vSS, 1376, -3360, 1344, -3360, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5) );\n}\n\nvoid Sector5( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 1344, -3104, 1344, -3200 );\n    Null( vSS, 1376, -3200, 1376, -3104 );\n    Wall( fT, vInf, vSS, 1376, -3200, 1344, -3200, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    Wall( fT, vInf, vSS, 1344, -3104, 1376, -3104, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5) );\n}\n\nvoid Sector11( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1528, -3680, 1376, -3648, 155, fLt, vSH, TEX_BROWN144);\n    Wall( fT, vInf, vSS, 1672, -3744, 1528, -3680, 157, fLt, vSH, TEX_BROWN144);\n    Wall( fT, vInf, vSS, 1984, -3776, 1672, -3744, 313, fLt, vSH, TEX_BROWN144);\n    Null( vSS, 1984, -3648, 1376, -3648 );\n    Null( vSS, 1984, -3648, 1984, -3776 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid Sector12( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 64.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 2240, -3776, 2208, -3680, 101, fLt, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 2208, -3680, 2176, -3680, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 2016, -3680, 1984, -3776, 101, fLt, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 2048, -3680, 2016, -3680, 32, fLt-kC, vSH, TEX_BROWN1);\n    Upper( fT, vInf, vSS, 2176, -3680, 2048, -3680, 128, fLt-kC, vSH, 16, TEX_BROWN1 );\n    Null( vSS, 2240, -3648, 1984, -3648 );\n    Null( vSS, 1984, -3648, 1984, -3776 );\n    Null( vSS, 2240, -3776, 2240, -3648 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid Sector24( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 144.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1216, -2880, 1248, -2528, 353, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1384, -2592, 1344, -2880, 290, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1472, -2560, 1384, -2592, 93, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1248, -2528, 1472, -2432, 243, fLt, vSH, TEX_STARTAN3);\n    Upper( fT, vInf, vSS, 1344, -2880, 1216, -2880, 128, fLt-kC, vSH, 72, TEX_STARTAN3 );\n    Upper( fT, vInf, vSS, 1472, -2432, 1472, -2560, 128, fLt+kC, vSH, 88, TEX_STARTAN3 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector25( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(0.0, 88.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 1472, -2432, 1472, -2560 );\n    Wall( fT, vInf, vSS, 1536, -2432, 1536, -2560, 128, fLt+kC, vSH, TEX_BIGDOOR2);\n    Wall( fT, vInf, vSS, 1536, -2560, 1472, -2560, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1472, -2432, 1536, -2432, 64, fLt-kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_TLITE6_4) );\n}\n\nvoid Sector27( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.878;\n    const vec2 vSH=vec2(-16.0, 200.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1216, -3392, 1216, -3360, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1216, -3360, 1184, -3360, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3104, 1216, -3104, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1216, -3104, 1216, -3072, 32, fLt+kC, vSH, TEX_BROWN1);\n    Open( fT, vInf, vSS, 1344, -3264, 1344, -3360, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Wall( fT, vInf, vSS, 1344, -3200, 1344, -3264, 64, fLt+kC, vSH, TEX_STARTAN3);\n    Open( fT, vInf, vSS, 1344, -3104, 1344, -3200, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1344, -3360, 1216, -3392, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1216, -3072, 1344, -3104, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 928, -3104, 1184, -3104, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1184, -3360, 928, -3360, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 928, -3360, 928, -3104, 256, fLt+kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) );\n}\n\nvoid Sector28( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.753;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 928, -3392, 928, -3360, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 928, -3360, 896, -3360, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3360, 1184, -3392, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 896, -3104, 928, -3104, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 928, -3104, 928, -3072, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3072, 1184, -3104, 32, fLt+kC, vSH, TEX_BROWN1);\n    Open( fT, vInf, vSS, 1184, -3392, 928, -3392, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 );\n    Null( vSS, 928, -3104, 1184, -3104 );\n    Null( vSS, 1184, -3360, 928, -3360 );\n    Null( vSS, 928, -3360, 928, -3104 );\n    Open( fT, vInf, vSS, 896, -3360, 896, -3104, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 );\n    Open( fT, vInf, vSS, 928, -3072, 1184, -3072, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) );\n}\n\nvoid Sector29( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1152, -3648, 1088, -3648, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1024, -3648, 960, -3648, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1280, -3552, 1152, -3648, 160, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 960, -3648, 832, -3552, 160, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1344, -3552, 1280, -3552, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 832, -3552, 704, -3552, 128, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 896, -3392, 928, -3392, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 896, -3360, 896, -3392, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3392, 1216, -3392, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 896, -3072, 896, -3104, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 928, -3072, 896, -3072, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1216, -3072, 1184, -3072, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1344, -2880, 1344, -3104, 224, fLt+kC, vSH, TEX_STARTAN3);\n    Null( vSS, 1184, -3392, 928, -3392 );\n    Null( vSS, 1344, -3360, 1216, -3392 );\n    Null( vSS, 1216, -3072, 1344, -3104 );\n    Wall( fT, vInf, vSS, 704, -2944, 832, -2944, 128, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 832, -2944, 968, -2880, 150, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 968, -2880, 1216, -2880, 248, fLt-kC, vSH, TEX_STARTAN3);\n    Null( vSS, 1088, -3648, 1024, -3648 );\n    Null( vSS, 896, -3360, 896, -3104 );\n    Null( vSS, 928, -3072, 1184, -3072 );\n#ifdef CLOSE_START_SECTOR\t\n    Wall( fT, vInf, vSS, 704, -3552, 704, -2944, 3552-2944, fLt+kC, vSH, TEX_STARTAN3);\n#else\n    Wall( fT, vInf, vSS, 704, -3552, 704, -3360, 192, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 704, -3104, 704, -2944, 160, fLt+kC, vSH, TEX_STARTAN3);\n    Null( vSS, 704, -3104, 704, -3360 );\n#endif\n    Null( vSS, 1344, -2880, 1216, -2880 );\n    Wall( fT, vInf, vSS, 1344, -3360, 1344, -3392, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1344, -3392, 1344, -3552, 3552 - 3392, fLt+kC, vSH, TEX_STARTAN3);\n\t\/\/Wall( fT, vInf, vSS, 1344, -3520, 1344, -3552, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1344, -3392, 1344, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector30( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    float fLt=(hash(floor(iGlobalTime * 10.0)) > 0.3) ? 0.565 : 1.0;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1088, -3680, 1024, -3680, 64, fLt-kC, vSH, TEX_DOOR3);\n    Wall( fT, vInf, vSS, 1024, -3680, 1024, -3648, 32, fLt+kC, vSH, TEX_LITE3);\n    Wall( fT, vInf, vSS, 1088, -3648, 1088, -3680, 32, fLt+kC, vSH, TEX_LITE3);\n    Null( vSS, 1088, -3648, 1024, -3648 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector31( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH );\n    Open( fT, vInf, vSS, 704, -3104, 704, -3360, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 );\n    Wall( fT, vInf, vSS, 512, -3328, 512, -3304, 24, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 512, -3160, 512, -3136, 24, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 512, -3136, 680, -3104, 171, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 680, -3104, 704, -3104, 24, fLt-kC, vSH, TEX_SUPPORT2);\n    Wall( fT, vInf, vSS, 704, -3360, 680, -3360, 24, fLt-kC, vSH, TEX_SUPPORT2);\n    Wall( fT, vInf, vSS, 680, -3360, 512, -3328, 171, fLt, vSH, TEX_STARTAN3);\n    Null( vSS, 496, -3160, 496, -3304 );\n    Wall( fT, vInf, vSS, 512, -3304, 496, -3304, 16, fLt-kC, vSH, TEX_DOORTRAK);\n    Wall( fT, vInf, vSS, 496, -3160, 512, -3160, 16, fLt-kC, vSH, TEX_DOORTRAK);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector32( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 224.0);\n\n    BeginSector( vSS, vSH );\n    Upper( fT, vInf, vSS, 496, -3160, 496, -3304, 144, fLt+kC, vSH, 120, TEX_STARG3 );\n    Wall( fT, vInf, vSS, 496, -3304, 496, -3328, 24, fLt+kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 496, -3328, 448, -3456, 136, fLt, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 448, -3456, 128, -3456, 320, fLt-kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 128, -3008, 448, -3008, 320, fLt-kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 496, -3136, 496, -3160, 24, fLt+kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 448, -3008, 496, -3136, 136, fLt, vSH, TEX_STARG3);\n    Lower( fT, vInf, vSS, 128, -3264, 160, -3264, 32, fLt-kC, vSH, 88, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 160, -3264, 192, -3264, 32, fLt-kC, vSH, 72, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 192, -3264, 224, -3264, 32, fLt-kC, vSH, 56, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 224, -3264, 256, -3264, 32, fLt-kC, vSH, 40, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 256, -3264, 288, -3264, 32, fLt-kC, vSH, 24, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 288, -3264, 320, -3264, 32, fLt-kC, vSH, 8, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 320, -3264, 320, -3200, 64, fLt+kC, vSH, 8, TEX_STEP6 );\n    Lower( fT, vInf, vSS, 320, -3200, 288, -3200, 32, fLt-kC, vSH, 8, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 288, -3200, 256, -3200, 32, fLt-kC, vSH, 24, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 256, -3200, 224, -3200, 32, fLt-kC, vSH, 40, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 224, -3200, 192, -3200, 32, fLt-kC, vSH, 56, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 192, -3200, 160, -3200, 32, fLt-kC, vSH, 72, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 160, -3200, 128, -3200, 32, fLt-kC, vSH, 88, TEX_SLADWALL );\n    Open( fT, vInf, vSS, 128, -3200, 64, -3072, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 );\n    Wall( fT, vInf, vSS, 64, -3072, 128, -3008, 90, fLt, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 128, -3456, 64, -3392, 90, fLt, vSH, TEX_STARG3);\n    Open( fT, vInf, vSS, 64, -3392, 128, -3264, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 );\n    Open( fT, vInf, vSS, 256, -3136, 320, -3136, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3136, 320, -3072, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3072, 256, -3072, 64, fLt-kC, vSH, 40, 184, TEX_SW1COMP, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 256, -3072, 256, -3136, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 256, -3392, 320, -3392, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3392, 320, -3328, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3328, 256, -3328, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 256, -3328, 256, -3392, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_FLOOR7_2) );\n}\n\nvoid Sector35( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 256, -3392, 320, -3392 );\n    Null( vSS, 320, -3392, 320, -3328 );\n    Null( vSS, 320, -3328, 256, -3328 );\n    Null( vSS, 256, -3328, 256, -3392 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1) );\n}\n\nvoid Sector36( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 256, -3136, 320, -3136 );\n    Null( vSS, 320, -3136, 320, -3072 );\n    Null( vSS, 320, -3072, 256, -3072 );\n    Null( vSS, 256, -3072, 256, -3136 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1) );\n}\n\nvoid Sector63( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 2736, -3648, 2488, -3744, 265, fLt, vSH, TEX_BROWN144);\n    Wall( fT, vInf, vSS, 2488, -3744, 2240, -3776, 250, fLt, vSH, TEX_BROWN144);\n    Null( vSS, 2736, -3648, 2240, -3648 );\n    Null( vSS, 2240, -3776, 2240, -3648 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo )\n{\n    vHitInfo = vec4(0.0);\n    fClosestT = 10000.0;\n\n#ifdef ENABLE_NUKAGE_SECTORS\n    Sector0( fClosestT, vHitInfo );\n    Sector1( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector3( fClosestT, vHitInfo );\n    Sector5( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector11( fClosestT, vHitInfo );\n    Sector12( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector24( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_MISC_SECTORS\t\n    Sector25( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_START_SECTORS\n\tSector27( fClosestT, vHitInfo );\n    Sector28( fClosestT, vHitInfo );\n    Sector29( fClosestT, vHitInfo );\n    Sector30( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_SECTOR_31\n    Sector31( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_MISC_SECTORS\n    Sector32( fClosestT, vHitInfo );\n    Sector35( fClosestT, vHitInfo );\n    Sector36( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector63( fClosestT, vHitInfo );\n#endif\n}\n\n\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ End of generated code\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Texture Helpers\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash2D(vec2 p)\n{\n\treturn hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = hash( fl );\n\tfloat h1 = hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nfloat Indent(vec2 vTexCoord, vec2 vHigh, vec2 vLow, float fHighIntensity, float fLowIntensity)\n{\n\tvec2 vMin = min(vLow, vHigh);\n\tvec2 vMax = max(vLow, vHigh);\n\tif((vTexCoord.x < vMin.x) || (vTexCoord.x > vMax.x) || (vTexCoord.y < vMin.y) || (vTexCoord.y > vMax.y))\n\t\treturn 1.0;\n\n\tif((vTexCoord.x == vHigh.x) || (vTexCoord.y == vHigh.y))\n\t{\n\t\treturn fHighIntensity;\n\t}\n\t\n\tif((vTexCoord.x == vLow.x) || (vTexCoord.y == vLow.y))\n\t{\n\t\treturn fLowIntensity;\n\t}\n\t\n\treturn 1.0;\n}\n\nvec4 SmoothBump(const in vec2 vTexCoord, const in vec2 vMin, const in vec2 vMax, const in vec2 vLightDir, const in float fSize)\n{\n\tvec2 vNearest = min( max(vTexCoord, vMin), vMax );\n\tvec2 vDelta = vNearest - vTexCoord;\n    float fDeltaLen = length(vDelta);\n\tfloat fDist = (fDeltaLen - fSize) \/ fSize;\n\tvec2 vDir = vDelta;\n    if(fDeltaLen > 0.0) vDir = vDir \/ fDeltaLen;\n\tfloat fShade = dot(vDir, vLightDir);\n\t\/\/return clamp(1.0 - (fDist \/ fSize), 0.0, 1.0) * fShade;\n\tfShade *= clamp(1.0 - abs((fDist)), 0.0, 1.0);\n\treturn vec4( fShade, fDist, (vTexCoord - vMin + fSize) \/ (vMax - vMin + fSize * 2.0) );\n}\n\n\nfloat wrap( const in float x , const in float r )\n{\n\treturn fract( x * (1.0 \/ r) ) * r;\n}\n\nvec4 Hexagon( vec2 vUV )\n{\n\tvec2 vIndex;\n\t\n\tfloat fRow = floor(vUV.y);\n\t\n\tvec2 vLocalUV = vUV;\n\tfloat fRowEven = wrap(fRow, 2.0);\n\tif(fRowEven < 0.5)\n\t{\n\t\tvLocalUV.x += 0.5;\n\t}\n\t\n\tvIndex = floor(vLocalUV);\n\t\n\tvec2 vTileUV = fract(vLocalUV);\n\t{\n\t\tfloat m = 2.0 \/ 3.0;\n\t\tfloat c = 2.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven < 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x -= 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat m = -2.0 \/ 3.0;\n\t\tfloat c = 4.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven >= 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x += 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\tvec2 vCenter = vIndex - vec2(0.0, -1.0 \/ 3.0);\n\tif(fRowEven > 0.5)\n\t{\n\t\tvCenter.x += 0.5;\n\t}\n\t\n\tvec2 vDelta = vUV - vCenter;\n\t\n\t\/\/vDelta = abs(vDelta);\n\t\n\tfloat d1 = vDelta.x;\n\tfloat d2 = dot(vDelta, normalize(vec2(2.0\/3.0, 1.0)));\n\tfloat d3 = dot(vDelta, normalize(vec2(-2.0\/3.0, 1.0)));\n\t\n\td2 *= 0.9;\n\td3 *= 0.9;\n\t\n\tfloat fDist = max( abs(d1), abs(d2) );\n\tfDist = max( fDist, abs(d3) );\n\t\n\tfloat fTest = max(max(-d1, -d2), d3);\n\t\n\treturn vec4(vIndex, abs(fDist), fTest);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Textures\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 TexNukage3( vec2 vTexCoord, float fRandom)\n{\n\tfloat fBlend = 0.0;\n\tfBlend = smoothstep(0.8, 0.0, fRandom);\n\tfBlend = min(fBlend, smoothstep(1.0, 0.8, fRandom));\n\tfBlend *= 1.5;\n\tvec3 col = mix( vec3(11.0, 23.0, 7.0), vec3(46.0, 83, 39.0), fBlend) \/ 255.0;\n\t\n\treturn col;\n}\n\nvoid AddMountain( inout float fShade, const in vec2 vUV, const in float fRandom, const in float fHRandom, const in float fXPos, const in float fWidth, const in float fHeight, const in float fFog)\n{\n\tfloat fYPos = 1.0 - smoothstep( 0.0, 1.0, abs(fract(fXPos - vUV.x + vUV.y * 0.05 + 0.5) - 0.5) * fWidth );\n\tfYPos += fHRandom * 0.05 + fRandom * 0.05;\n\tfYPos *= fHeight;\n\tfloat fDist = fYPos - vUV.y;\n\tif(fDist > 0.0)\n\t{\n\t\tfShade = fRandom * ((1.0 - clamp(sqrt(fDist) * 2.0, 0.0, 1.0)) * 0.3 + 0.1);\n\t\tfShade = mix(fShade, 0.6 + 0.1 * fRandom, fFog);\n\t}\t\n}\n\nvec3 TexFSky1(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fShade = 0.6 + 0.1 * fRandom;\n\t\n\tvec2 vUV = vTexCoord * (1.0 \/ vec2(256.0, 128.0));\n\tvUV.y = 1.0 - vUV.y;\n\t\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 0.25, 1.0, 0.85, 0.5 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.5, 4.0, 0.78, 0.2 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.94, 2.51, 0.8, 0.0 );\n\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexFloor7_1( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(51.0, 43.0, 19.0), vec3(79.0, 59, 35.0), fRandom * fRandom * 2.5) \/ 255.0;\n\t\n\treturn col;\n}\n\nvec3 TexFlat5_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(63.0, 47.0, 23.0), vec3(147.0, 123.0, 99.0), fRandom) \/ 255.0;\n\t\n\tcol *= mod(vTexCoord.x, 2.0) * 0.15 + 0.85;\n\t\n\treturn col;\n}\n\nvec3 TexFloor4_8( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(30.0, 30.0, 30.0), vec3(150.0, 150.0, 150.0), fRandom * fRandom) \/ 255.0;\n\n\tvec4 vHex = Hexagon( vTexCoord.yx \/ 32.0 );\n    \n    float fShadow = (clamp((0.5 - vHex.z) * 15.0, 0.0, 1.0) * 0.5 + 0.5);\n    float fHighlight = 1.0 + clamp(1.0 - (abs(0.45 - vHex.w)) * 32.0, 0.0, 1.0) * 0.5;\n    \n\tcol = col * (clamp((0.5 - vHex.z) * 2.0, 0.0, 1.0) * 0.25 + 0.75);\n    col = col * fHighlight;\n\tcol = col * fShadow;\n\t\n\treturn col;\n}\n\nvec3 TexCeil3_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(1.0);\n\t\n\tvec2 vTileCoord = vTexCoord;\n\tvTileCoord.x -= 17.0;\n\tif( (vTileCoord.x >= 0.0) && (vTileCoord.x < 32.0) ) \n\t\tvTileCoord.y -= 58.0;\n\telse \n\t\tvTileCoord.y -= 11.0;\n\tvTileCoord.x = mod(vTileCoord.x, 32.0);\n\tvTileCoord.y = mod(vTileCoord.y, 64.0);\n\t\t\n\tvec2 vBoxClosest = clamp(vTileCoord, vec2(4.0, 4.0), vec2(28.0, 60.0));\n\tvec2 vDelta = vTileCoord - vBoxClosest;\n\tfloat fDist2 = dot(vDelta, vDelta);\n\n\tconst float fLight1 = 59.0 \/ 255.0;\n\tconst float fMed1 = 55.0 \/ 255.0;\n\tconst float fDark1 = 47.0 \/ 255.0;\n\tconst float fDark2 = 39.0 \/ 255.0;\n\n\tfloat fShade = fMed1;\t\n\tfShade = mix( fShade, fLight1, smoothstep(0.6, 0.45, fRandom) );\n\tfShade = mix( fShade, fDark1, smoothstep(0.45, 0.35, fRandom) );\n\t\n\tfShade = mix( fShade, fDark1, step(1.5, fDist2) );\n\tfShade = mix( fShade, fDark2, step(13.5, fDist2) );\n\t\t\n\tcol *= fShade;\n\t\n\tif((vTileCoord.x < 12.0) || (vTileCoord.x > 20.0) || (vTileCoord.y < 12.0) || (vTileCoord.y > 52.0))\n\t{\n\t\tfloat fRRow = floor(mod(vTileCoord.y - 3.5, 7.5));\n\t\tfloat fRColumn = mod(vTileCoord.x - 15.0, 10.0);\n\t\tif((fRRow == 2.0) && (fRColumn == 0.0))\n\t\t{\n\t\t\tcol -= 0.05;\n\t\t}\n\t\tif((fRRow <= 2.0) && (fRColumn <= 2.0))\n\t\t{\n\t\t\tvec2 vOffset = vec2(fRRow - 1.0, fRColumn - 1.0);\n\t\t\tfloat fDist2 = dot(vOffset, vOffset) \/ 2.0;\n\t\t\tcol += clamp(1.0 - fDist2, 0.0, 1.0) * 0.05;\n\t\t}\n\t}\n\t\n\treturn col;\n}\n\nvec3 TexFlat14( vec2 vTexCoord, float fRandom )\n{\n\treturn mix( vec3(0.0, 0.0, 35.0 \/ 255.0), vec3(0.0, 0.0, 200.0 \/ 255.0), fRandom * fRandom);\n}\n\nvec3 TexDoor3(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fVNoise = fHRandom + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\n\tfloat fShade = 1.0;\n\t\n\tfShade = 1.0 - abs((vTexCoord.y \/ 72.0) - 0.5) * 2.0;\n\tfShade = fShade * fShade;\n\tfShade = fShade * 0.2 + 0.3;\n\t\n\tfShade = fShade * (fHRandom * 0.2 + 0.8);\n\t\n\tfShade *= Indent( vTexCoord, vec2(8.0, 8.0), vec2(64.0 - 8.0, 72.0 - 16.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(8.0, 72.0 - 15.0), vec2(64.0 - 8.0, 72.0 - 8.0), 0.8, 1.2);\n\t\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 46.0), vec2(46.0, 32.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 56.0), vec2(46.0, 52.0), 0.8, 1.2);\n\t\n\tfShade += fRandom * 0.1;\n\n\tfloat fStreakTopAmount = smoothstep( 32.0, 0.0, vTexCoord.y );\n\tfloat fStreakBottomAmount = smoothstep( 72.0 -32.0, 72.0, vTexCoord.y );\n\t\n\tfShade *= 1.0 - fStreak * max(fStreakTopAmount, fStreakBottomAmount) * 0.2;\n\t\n\tif( (vTexCoord.x > 8.0) && (vTexCoord.x < 52.0) )\n\t{\n\t\tvec2 vRepeatCoord = mod( vTexCoord, vec2( 8.0, 48.0 ) );\n\t\tvRepeatCoord += vec2(4.0, -12.0);\n\t\tif( vRepeatCoord.x == 4.0 )\n\t\t{\n\t\t\tif(vRepeatCoord.y == 0.0)\n\t\t\t{\n\t\t\t\tfShade += 0.1;\n\t\t\t}\n\t\t\tif(vRepeatCoord.y > 0.0)\n\t\t\t{\n\t\t\t\tfShade *= clamp(vRepeatCoord.y \/ 16.0, 0.0, 1.0) * 0.3 + 0.7;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexLite3( vec2 vTexCoord )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord.y = mod(vLocalCoord.y, 8.0 );\n\t\n\tvec2 vClosest = min( max( vLocalCoord, vec2(4.0, 3.5) ), vec2(32.0 - 5.0, 3.5) );\n\tvec2 vDelta = vLocalCoord - vClosest;\n\tfloat fDist = max(abs(vDelta.x), abs(vDelta.y)) \/ 3.9;\n\t\n\treturn vec3(1.0 - fDist * 0.65);\n}\n\nvec3 TexStartan3( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(0.6);\n\t\n\tfloat fVNoise = noise1D(vTexCoord.x * 0.5) - ((vTexCoord.y) \/ 128.0) + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\t\n\tfloat fBlend2 = smoothstep( 0.0, 32.0, abs(vTexCoord.x - 64.0) );\n\tfBlend2 *= fBlend2;\n\tfBlend2 *= fStreak * 0.5 + 0.5;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) \/ 255.0, fBlend2 * 0.5);\n\t\n\tfloat fBlend = smoothstep( 24.0, 56.0, abs(vTexCoord.x - 64.0) );\n\tfBlend *= fBlend;\n\tfBlend *= fStreak * 0.7 + 0.3;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) * 1.1 \/ 255.0, fBlend);\n\t\n\tcol *= fRandom * fRandom * 0.3 + 0.7;\n\n\tvec2 vCoord = vTexCoord;\n\tvCoord.x = mod(vCoord.x, 32.0);\n\t\n\tfloat fStreakHL = fStreak * 0.075 + 0.075;\n\t\n\tfloat fDistMin = 1.0;\n\tfloat fShade = 0.0;\n\t\n\tvec4 vBump = SmoothBump( vCoord, vec2(6.0, 8.0), vec2(32.0 - 5.0, 9.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfDistMin = min(fDistMin, vBump.y);\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tvBump = SmoothBump( vCoord, vec2(6.0, 20.0), vec2(32.0 - 6.0, 40.0), normalize(vec2(0.0, 1.0)), 3.0 ); \n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vCoord, vec2(6.0, 64.0), vec2(32.0 - 6.0, 65.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vCoord, vec2(6.0, 76.0), vec2(32.0 - 6.0, 110.0), normalize(vec2(0.0, 1.0)), 3.0 ) ;\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 50.0), vec2(256.0, 52.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 122.0), vec2(256.0, 200.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.05;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tcol *= 1.0 + fShade * 3.0;\n\n\tcol *= clamp((1.0 - fDistMin) * 1.0, 0.0, 1.0) * 0.3 + 0.7;\n\n\treturn col;\n}\n\nvec3 TexBrown1( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(119.0, 95.0, 63.0), vec3(147.0, 123.0, 99.0), fRandom * fRandom) \/ 255.0;\n\n\tif(vTexCoord.x >= 64.0)\n\t{\n\t\tcol = col * vec3(1.0, 0.848, 0.646);\n\t\t\n\t\tcol = mix( col, vec3( 0.111, 0.414, 0.3), clamp((fRandom -0.5) * 2.0, 0.0, 1.0)); \/\/ green bits\n\t}\n\t\n\tfloat fVNoise = fHRandom + fRandom;\n\t\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\n\tvec2 vRepeatCoord = vTexCoord;\n\tvRepeatCoord.x = mod(vRepeatCoord.x, 13.0);\n\t\n\tvec4 vBump = SmoothBump( vRepeatCoord, vec2( 5.0, 6.0 ), vec2( 5.0, 12.0), vec2(0.0, 1.0), 1.5);\n\tfloat fMask = clamp(1.0 - vBump.y, 0.0, 1.0);\n\t\n\tfloat fStreakAmount = 1.0;\n\tfStreakAmount *= smoothstep( 0.0, 8.0, vRepeatCoord.y );\n\tfloat fStreakWidth = smoothstep( 64.0, 12.0, vRepeatCoord.y );\n\tfloat fBase1Dist = smoothstep( 24.0, 75.0, vRepeatCoord.y ) * step(vRepeatCoord.y, 75.0);\n\tfloat fBase2Dist = smoothstep( 96.0, 127.0, vRepeatCoord.y );\/\/ * step(75.0, vRepeatCoord.y);\n\tfloat fBaseDist = max(fBase1Dist, fBase2Dist);\n\tfStreakWidth = max( fStreakWidth, fBaseDist);\n\tfloat fTop2Dist = smoothstep( 127.0, 75.0, vRepeatCoord.y ) * step(75.0, vRepeatCoord.y);\n\tfStreakWidth = max(fStreakWidth, fTop2Dist);\n\tfloat fStreakX = abs(vRepeatCoord.x - 5.0) \/ 8.0;\n\tfStreakAmount *= fStreakWidth;\n\tfStreakAmount *= smoothstep( fStreakWidth, 0.0, fStreakX);\n\tfStreakAmount = max(fStreakAmount, (fBaseDist - 0.75) * 4.0);\n\tfStreakAmount *= 1.0 - fMask; \n\tcol = mix(col, vec3(0.3, 0.2, 0.1), fStreakAmount * (fStreak * 0.5 + 0.5) );\n\t\n\tcol += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (vBump.w) * (1.0-vBump.y) * 0.05 : 0.0;\n\t\n\tif((vTexCoord.y == 17.0) || (vTexCoord.y == 73.0)) col *= 0.9;\n\tif((vTexCoord.y == 19.0) || (vTexCoord.y == 75.0)) col *= 1.2;\n\n\tcol *= 1.0 + clamp(vBump.x, -1.0, 0.0) * 0.6;\n\t\t\n\treturn col;\n}\n\nvec3 TexDoorstop( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = 1.0 - abs(vTexCoord.x - 3.4) \/ 4.0;\n\t\n\tfShade = fShade * 0.2 + 0.2;\n\t\n\tfloat fSin = sin((vTexCoord.y - 16.0) * 3.14150 * 4.0 \/ 128.0) * 0.5 + 0.5;\n\tfShade *= 0.8 + fRandom * 1.2 * fSin;\n\t\n\treturn vec3(fShade);\n}\n\nvoid DrawScreen(inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, const in vec3 vCol)\n{\n\tvec2 vScreenCoord = vTexCoord - vPos;\n\tcol *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);\n\n\tif((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))\n\t{\n\t\tcol = vCol;\n\t}\n}\n\nvec3 TexCompute2( vec2 vTexCoord, float fRandom )\n{\n    fRandom = 1.0 - fRandom * fRandom;\n\tvec3 col = vec3(35.0 \/ 255.0);\n\t\n\tcol *= Indent( vTexCoord, vec2( -8.0, 0.0), vec2(300.0, 10.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 11.0), vec2(300.0, 27.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 28.0), vec2(300.0, 43.0), 1.3, 0.5);\n\t{\n\t\tvec2 vLocalCoord = vTexCoord;\n\t\tvLocalCoord.x = mod(vLocalCoord.x, 21.0);\n\t\tcol *= Indent( vLocalCoord, vec2( 0.0, 44.0), vec2(20.0, 55.0), 1.3, 0.5);\n\t}\n\n\tif(vTexCoord.y < 40.0)\n\t{\n\t\tvec2 vTileSize = vec2(48.0, 14.0);\n\t\tvec2 vIndex = floor(vTexCoord \/ vTileSize);\n\n\t\tfloat fIndex = vIndex.x + vIndex.y * 13.0;\n\t\tvec2 vMin = vIndex * vTileSize + vec2(hash(fIndex) * 32.0, 4.0);\n\t\tvec2 vSize = vec2(8.0 + hash(fIndex + 1.0) * 32.0, 4.0);\n\n\t\tvec3 vCol = vec3(0.0);\n\t\tfloat iIndex = floor(mod(fIndex, 5.0));\n\t\tif( iIndex < 0.5 ) \n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.25, 0.0), fRandom);\n\t\t}\n\t\telse if(iIndex < 1.5)\n\t\t{\n\t\t\tvCol = mix(vec3(1.0, 0.6, 0.02), vec3(0.1), fRandom);\n\t\t}\n\t\telse if(iIndex < 2.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.5);\n\t\t}\n\t\telse if(iIndex < 3.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.25);\n\t\t}\n\t\telse if(iIndex < 4.5)\n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.0, 0.5), vec3(0.1), fRandom);\n\t\t}\n\t\tDrawScreen(col, vTexCoord, vMin, vSize, vCol);\n\t}\n\n\treturn col;\n}\n\nvec3 TexStep6( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(87.0, 67.0, 51.0), vec3(119.0, 95.0, 75.0), fRandom) \/ 255.0;\n\n\tcol *= Indent( vTexCoord, vec2(-1.0, 3.0), vec2(32.0, 1.0), 1.3, 0.7);\n\tcol *= Indent( vTexCoord, vec2(-1.0, 8.0), vec2(32.0, 0.0), 1.3, 0.9);\n\n\tfloat fStreak = clamp((vTexCoord.y \/ 16.0) * 1.5 - fHRandom, 0.0, 1.0);\n\n\tcol *= fStreak * 0.3 + 0.7;\n\t\n\treturn col;\n}\n\nvec3 TexSupport2( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col;\n\tfloat fShade = 0.5;\n\t\n\tfloat f1 = abs(fract((vTexCoord.y + 32.0) \/ 70.0) - 0.5) * 2.0;\n\tfloat f2 = abs(fract((vTexCoord.x + 16.0) \/ 16.0) - 0.5) * 2.0;\n\tfShade += f1 * 0.75 + f2 * 0.25;\n\tfShade = fShade * fShade;\n\n\tfShade = fShade * 0.2 + 0.05;\n\tfShade *= 1.0 + fRandom * 0.4;\n\n\tvec2 vLocalCoord = vTexCoord;\n\tif((vLocalCoord.y < 64.0) || (vLocalCoord.y > 75.0))\n\t{\n\t\tif(vLocalCoord.y > 64.0) vLocalCoord.y -= 8.0;\n\t\tvLocalCoord = mod( vLocalCoord, vec2(20.0, 16.0));\n\t\tfloat fIndent = Indent( vLocalCoord, vec2(8.0, 8.0), vec2(16.0, 15.0), 0.9, 1.1);\n\t\tfShade += fIndent - 1.0;\n\t}\n\t\n\tcol = vec3(fShade);\n\t\n\treturn col;\n}\n\nvec3 TexDoorTrak( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = fRandom * 0.5;\n\tfShade *= mod(vTexCoord.x, 2.0) * 0.6 + 0.4;\n\treturn vec3(fShade);\n}\n\nvec3 TexBrown144( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(39.0, 39.0, 39.0), vec3(51.0, 43.0, 19.0), fRandom) \/ 255.0;\n\t\n\tfloat fBlend = fHRandom - 0.1;\n\tfBlend = clamp(fBlend, 0.0, 1.0);\n\tcol = mix( col, col * 2.0 * vec3(0.893, 0.725, 0.161), fBlend);\n\treturn col;\n}\n\n#ifdef ENABLE_SPRITES\n\nvec3 TexBar1A( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = vec3(123.0, 127.0, 99.0) \/ 255.0;\n\t\n\tfloat fBrownStreakBlend = smoothstep( 2.0, 1.0, abs(vTexCoord.x - 3.5));\n\tcol = mix(col, vec3(0.724, 0.736, 0.438), fBrownStreakBlend);\n\t\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 3.0) && (vTexCoord.x < 18.0) )\n\t{\n\t\tcol = col * clamp(((vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\telse\n\t{\n\t\tcol = col * clamp((1.0 - (vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\t\n\tfloat fNukageBlend = 0.0;\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 8.0) && (vTexCoord.x < 14.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tif( (vTexCoord.y == 2.0) && (vTexCoord.x > 2.0) && (vTexCoord.x < 20.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tcol = mix(col, vec3(0.172, 0.560, 0.144) * fRandom, fNukageBlend);\n\t\n\t\n\tif(vTexCoord.x < 1.0)\n\t{\n\t\tcol += 0.1;\n\t}\n\t\n\tfloat fBlend = clamp(((vTexCoord.x - 20.0) \/ 3.0), 0.0, 1.0);\n\tcol += fBlend * 0.2;\n\t\n\tfloat fBumpY = 8.0;\n\tif(vTexCoord.y > 14.0) fBumpY += 9.0;\n\tif(vTexCoord.y > 23.0) fBumpY += 8.0;\n\n\tvec4 vBump = SmoothBump( vTexCoord, vec2(2.0, fBumpY), vec2(23.0 - 2.0, fBumpY), normalize(vec2(-0.2, 1.0)), 1.25 );\t\n\tcol += vBump.x * 0.2;\n\n\t\/\/ rim highlights\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(17.0, 0.0)) \/ vec2(8.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(20.0, 1.0)) \/ vec2(4.0, 1.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(3.0, 2.0)) \/ vec2(4.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t\n\tcol *= 0.5 + fRandom * 0.5;\n\t\n\treturn col;\n}\n\nvec3 TexPlayW( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 col = mix(vec3(190.0, 10.0, 10.0), vec3(50, 16.0, 16.0 ), fRandom * vTexCoord.y\/18.0) \/ 255.0;\n\treturn col;\n}\n\n#endif \n\nvec3 SampleTexture( const in float fTexture, const in vec2 _vUV )\n{\n    vec3 col = vec3(1.0, 0.0, 1.0);\n    vec2 vUV = _vUV;\n    \n    vec2 vSize = vec2(64.0);\n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;\n\n\tif(fTexture == TEX_NUKAGE3)\n\t{\n        float fTest = fract(floor(iGlobalTime * 6.0) * (1.0 \/ 3.0));\n        if( fTest < 0.3 )\n        {\n\t        vUV += 0.3 * vSize;\n        }\n        else if(fTest < 0.6)\n        {\n            vUV = vUV.yx - 0.3; \n        }\n        else\n        {\n            vUV = vUV + 0.45;\n        }\n\t}\n\t\n\t     if(fTexture == TEX_NUKAGE3) { fPersistence = 1.0; }\n\telse if(fTexture == TEX_F_SKY1) { vSize = vec2(256.0, 128.0); fNoise2Freq = 0.3; }\n    else if(fTexture == TEX_FLOOR7_1) { vSize = vec2(64.0, 32.0); fPersistence = 1.0; }\t\n    else if(fTexture == TEX_FLAT5_5) { fPersistence = 3.0; }\n    else if(fTexture == TEX_FLOOR4_8) { fPersistence = 0.3; }\n    else if(fTexture == TEX_CEIL3_5) { fPersistence = 0.9; }\t\n    else if(fTexture == TEX_FLAT14) { fPersistence = 2.0; }\n    else if(fTexture == TEX_DOOR3) { vSize = vec2(64.0, 72.0); }\t\n    else if(fTexture == TEX_LITE3) { vSize = vec2(32.0, 128.0); }\t\n    else if(fTexture == TEX_STARTAN3) { vSize = vec2(128.0); fPersistence = 1.0; }\t\n\telse if(fTexture == TEX_BROWN1) { vSize = vec2(128.0); fPersistence = 0.7; }\t\n    else if(fTexture == TEX_DOORSTOP) { vSize = vec2(8.0, 128.0); fPersistence = 0.7; }\n    else if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 56.0); fPersistence = 1.5; }\n    else if(fTexture == TEX_STEP6) { vSize = vec2(32.0, 16.0); fPersistence = 0.9; }\n    else if(fTexture == TEX_SUPPORT2) { vSize = vec2(64.0, 128.0); }\n    else if(fTexture == TEX_DOORTRAK) { vSize = vec2(8.0, 128.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(23.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(57.0, 22.0); fPersistence = 1.0; }\n#endif\n\t\n#ifdef PREVIEW\n\t     if(fTexture == TEX_DOOR3) {\tvSize = vec2(128.0, 128.0); }\t\n\telse if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 64.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(32.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(64.0, 32.0); }\t\n#endif\n#endif\n\t\n\t\n#ifdef PREVIEW\n    vec2 vTexCoord = floor(fract(vUV) * vSize);\n#else\n    vec2 vTexCoord = fract(vUV \/ vSize) * vSize;\n    #ifdef PIXELATE_TEXTURES\n    vTexCoord = floor(vTexCoord);\n    #endif\n    vTexCoord.y = vSize.y - vTexCoord.y - 1.0;\n#endif\n\tfloat fRandom = fbm( vTexCoord, fPersistence );\n\tfloat fHRandom = noise1D(vTexCoord.x * fNoise2Freq) - ((vTexCoord.y) \/ vSize.y);\n    \n\t     if(fTexture == TEX_NUKAGE3) \tcol = TexNukage3( vTexCoord, fRandom );\n\telse if(fTexture == TEX_F_SKY1) \tcol = TexFSky1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_FLOOR7_1) \tcol = TexFloor7_1( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLAT5_5) \tcol = TexFlat5_5( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLOOR4_8) \tcol = TexFloor4_8( vTexCoord, fRandom );\n    else if(fTexture == TEX_CEIL3_5) \tcol = TexCeil3_5( vTexCoord, fRandom );\n\telse if(fTexture == TEX_FLAT14) \tcol = TexFlat14( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOOR3) \t\tcol = TexDoor3( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_LITE3) \t\tcol = TexLite3( vTexCoord );\n    else if(fTexture == TEX_STARTAN3) \tcol = TexStartan3( vTexCoord, fRandom );\n    else if(fTexture == TEX_BROWN1) \tcol = TexBrown1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_DOORSTOP) \tcol = TexDoorstop( vTexCoord, fRandom );\n    else if(fTexture == TEX_COMPUTE2) \tcol = TexCompute2( vTexCoord, fRandom );\n    else if(fTexture == TEX_STEP6) \t\tcol = TexStep6( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_SUPPORT2) \tcol = TexSupport2( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOORTRAK) \tcol = TexDoorTrak( vTexCoord, fRandom );\n\telse if(fTexture == TEX_BROWN144) \tcol = TexBrown144( vTexCoord, fRandom, fHRandom );\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) \t\tcol = TexBar1A( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_PLAYW) \t\tcol = TexPlayW( vTexCoord, fRandom, fHRandom );\t\n#endif\n\t\n    #ifdef QUANTIZE_TEXTURES\n    col = Quantize(col);\n    #endif\n\n    return col;\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define N(T,N) t+=float(T); if(x>t) r=vec2(N,t);\n#define L(T,N,X) t+=float(T); if((x>t) && (x<(t+float(X)))) r=vec2(N,t);\n\nvec2 GetTrack1Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(1628,40,8)N(24,40)N(28,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,12)N(28,40)N(24,47)N(26,48)L(26,40,4)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)N(28,48)L(24,40,10)N(26,40)N(26,46)L(126,40,10)N(26,40)N(24,52)L(28,40,8)N(24,40)N(26,50)L(26,40,10)N(24,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,8)N(24,40)N(28,47)N(24,48)L(26,40,8)N(26,40)N(24,52)L(26,40,10)N(26,40)N(24,50)L(26,40,8)N(26,40)L(24,63,14)L(14,60,14)L(14,59,12)L(12,63,12)L(12,66,12)L(12,64,14)L(14,63,12)L(12,59,14)L(14,63,12)L(12,64,12)L(12,66,12)L(12,67,14)L(14,66,14)L(14,64,12)L(12,63,12)L(12,59,12)L(12,40,8)N(26,40)N(26,52)L(24,40,8)N(28,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,8)N(26,40)N(24,46)L(26,40,10)N(26,40)N(24,47)N(28,48)L(24,40,4)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,10)N(28,40)N(24,46)L(128,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(28,50)L(24,40,10)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,8)N(26,40)N(26,47)N(24,48)L(28,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)L(26,67,14)L(14,64,12)L(12,59,12)L(12,64,12)L(12,67,14)L(14,64,14)L(14,67,12)L(12,71,12)L(12,67,12)L(12,64,14)\n    return r;\n}\n\nvec2 GetTrack2Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(0,40,8)N(24,40)N(26,52)L(26,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,12)N(26,40)N(26,47)N(26,48)L(26,40,4)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)N(26,48)L(26,40,10)N(26,40)N(26,46)L(126,40,10)N(26,40)N(24,52)L(26,40,10)N(26,40)N(26,50)L(26,40,10)N(24,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,8)N(24,40)N(26,47)N(26,48)L(26,40,8)N(26,40)N(24,52)L(26,40,10)N(26,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,10)N(26,40)N(26,46)L(126,40,8)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(26,40,8)N(26,40)N(24,48)L(26,40,8)N(26,40)N(24,46)L(26,40,10)N(26,40)N(24,47)N(26,48)L(26,40,4)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,10)N(26,40)N(26,46)L(128,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,10)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,8)N(26,40)N(26,47)N(24,48)L(26,40,10)N(26,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)L(26,66,14)L(14,64,12)L(12,63,12)L(12,66,12)L(12,69,14)L(14,67,12)L(12,66,14)L(14,63,12)L(12,66,12)L(12,67,14)L(14,69,12)L(12,71,14)L(14,69,12)L(12,67,12)L(12,66,12)L(12,63,14)L(14,40,6)N(26,40)N(24,52)L(26,40,8)N(26,40)N(24,50)L(26,40,10)N(26,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,10)N(24,40)N(26,47)N(26,48)L(24,40,6)N(26,40)N(26,52)L(26,40,8)N(26,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,10)N(26,40)N(24,46)L(128,40,8)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,12)N(26,40)N(26,48)L(26,40,8)N(26,40)N(24,46)L(26,40,8)N(26,40)N(24,47)N(26,48)L(26,40,8)N(24,40)N(26,52)L(26,40,8)N(26,40)N(26,50)L(24,40,8)L(26,40,14)L(26,71,12)L(12,67,12)L(12,64,14)L(14,67,12)L(12,71,14)L(14,67,12)L(12,71,12)L(12,76,12)L(12,71,14)L(14,67,12)\n    return r;\n}\n\nvec2 GetTrack3Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,40)N(406,40)N(406,40)N(408,40)N(408,40)N(408,40)N(406,40)N(408,40)N(406,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)\n    return r;\n}\n\nvec2 GetTrack4ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,36)N(406,36)N(406,36)N(408,36)N(408,36)L(38,49,8)N(370,36)L(36,49,10)N(370,36)L(38,49,8)N(370,36)L(38,49,8)L(164,36,12)L(28,36,10)L(24,36,12)L(26,36,14)L(26,36,10)L(24,36,12)L(26,36,10)L(26,36,12)N(24,36)N(2,46)N(50,40)N(2,46)L(50,36,12)N(2,46)N(22,36)N(26,40)N(2,46)N(48,36)N(2,46)N(50,40)N(4,46)L(46,36,14)N(2,46)N(24,36)N(24,40)N(4,46)N(48,36)N(2,46)N(50,40)N(2,46)L(48,36,14)N(6,46)N(20,36)N(24,40)N(4,46)N(48,36)N(52,40)N(48,46)L(2,36,14)N(26,36)N(24,40)N(2,46)N(48,46)N(2,36)N(50,46)N(50,46)L(28,36,14)N(24,46)N(52,36)N(50,40)N(2,46)N(48,36)N(52,40)N(2,46)N(50,36)N(48,46)N(2,40)N(50,46)N(26,36)N(26,40)L(50,36,6)L(2,50,8)L(24,36,8)L(24,36,8)L(4,40,6)L(24,36,8)L(24,36,8)L(4,45,8)L(2,40,6)\n    return r;\n}\n\nvec2 GetTrack4BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,40)N(406,40)N(406,40)N(408,40)N(408,40)L(38,57,8)N(370,40)L(36,57,10)N(370,40)L(38,57,8)N(370,40)L(38,57,8)L(164,40,12)L(28,40,8)L(24,40,14)L(26,40,12)L(26,40,12)L(24,40,12)L(26,40,14)L(26,40,12)N(636,46)N(52,46)N(202,40)N(50,36)N(52,40)N(52,46)N(100,46)N(104,46)L(100,36,14)N(52,46)L(52,40,8)L(52,47,8)\n    return r;\n}\n\nvec2 GetTrack4CNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,41)N(406,41)N(406,41)N(408,41)N(408,41)N(408,41)N(406,41)N(408,41)L(202,41,12)L(28,41,8)L(24,41,12)L(26,41,10)L(26,41,12)L(24,41,12)L(26,41,12)L(26,41,12)\n    return r;\n}\n\nvec2 GetTrack4DNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1628,49)N(408,49)N(406,49)N(408,49)\n    return r;\n}\n\nvec2 GetTrack4ENote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1628,57)N(408,57)L(406,57,14)L(408,57,14)\n    return r;\n}\n\n\n\/\/ ------------------- 8< ------------------- 8< ------------------- 8< -------------------\n\n#define PI radians(180.0)\n#define TWO_PI radians(360.0)\n\nfloat NoteToHz(float n)\n{  \t\n\treturn 440.0*pow( 2.0, (n-69.0)\/12.0 );\n}\n\nfloat Tri( float t )\n{\n\treturn abs(fract( t ) * 4.0 - 2.0) - 1.0;\n}\n\nfloat Saw( float t )\n{\n\treturn fract( t ) * 2.0 - 1.0;\n}\n\nvec4 Saw4( vec4 x )\n{\n\treturn fract( x ) * 2.0 - 1.0;\n}\n\nfloat Cos( float t )\n{\n\treturn cos( t * radians(360.0) );\n}\n\nvec4 Cos4( vec4 x )\n{\n\tx = abs(fract(x) * 2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn x2 * 6.0 - x2*x * 4.0  - 1.0;\n}\n\nfloat Square( float t )\n{\n\treturn step( fract(t), 0.5 ) * 2.0 - 1.0;\n}\n\n\/\/ Thanks to Dave_Hoskins for the hash\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat Noise( float x )\n{\n\treturn Hash( floor(x * 32.0) ) * 2.0 - 1.0;\n}\n\nfloat SmoothNoise( float t )\n{\n\tfloat noiset = t * 32.0;\n\tfloat tfloor = floor(noiset);\n\tfloat ffract = fract(noiset);\n\t\n\tfloat n0 = Hash(tfloor);\n\tfloat n1 = Hash(tfloor + 1.0);\n\tfloat blend = ffract*ffract*(3.0 - 2.0*ffract);\n\treturn mix(n0, n1, blend) * 2.0 - 1.0;\n}\n\nfloat FBM( float t, float persistence )\n{\n    float result = 0.0;\n    \n    float a = 1.0;\n    float tot = 0.0;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    tot += a; \n    return result \/ tot;\n}\n\n\nfloat StepNoise( float t, float freq )\n{\n\tfloat noiset = t * freq;\n\tfloat tfloor = floor(noiset);\n\t\n\tfloat n = Hash(tfloor);\n\treturn n * 2.0 - 1.0;\n}\n\nfloat Cos4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Cos4((x+phase) * freq), amp);\n}\n\nfloat Saw4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Saw4((x+phase) * freq), amp);\n}\n\n\nfloat Test( float t )\n{\n\treturn Saw4(t, vec4(0.0, 0.5, 0.1, 0.4), vec4(1.0, 1.50, 2.00, -3.00), vec4(1.0, 0.5, 0.25, 0.125));\n}\n\nfloat Envelope( float time, float decay )\n{\t\n\treturn exp2( -time * (5.0 \/ decay) );\n}\n\nfloat Envelope( float time, float attack, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time\/attack;\n\t}\n\n\ttime -= attack;\n\n\treturn Envelope( time, decay );\n}\n\nfloat Test2(float f)\n{\n    return Test(f) + Test(f - 0.0454) * 0.4 + Test(f - 0.1123) * 0.3 + Test(f - 0.1523) * 0.1;\n}\nfloat Instrument( const in vec2 vFreqTime )\n{\n    return Test2( vFreqTime.x * vFreqTime.y ) * Envelope( vFreqTime.y, 0.01, 1.0 );    \n}\n\nfloat Track1Instrument( const in vec2 vFreqTime )\n{\n    return Instrument( vFreqTime * vec2(2.0, 1.0) ) * 0.75;\n}\n\nfloat Track2Instrument( const in vec2 vFreqTime )\n{\n    return Instrument( vFreqTime );\n}\n\nfloat Track3Basic(float x)\n{\n    return FBM(x, 0.5);\n}\n\nfloat Track3Instrument( const in vec2 vFreqTime )\n{\n    return Track3Basic(vFreqTime.y * vFreqTime.x) * Envelope(vFreqTime.y, 0.4) * 2.0;\n}\n\nfloat kick(float freq, float fNoteTime){\n    float a = clamp(1.0-fNoteTime,0.0,1.0);\n    float osc = sin(pow(a,5.0)*freq);\n    return osc * pow(a, 2.0);\n}\n\nfloat Track4Instrument( const in vec2 vFreqTime )\n{\n    return FBM(vFreqTime.y * vFreqTime.x * 8.0, 2.0) * Envelope(vFreqTime.y, 0.5);\n}\n\n\nconst float kMidiTimebase = 200.0;\nconst float kInvMidiTimebase = 1.0 \/ kMidiTimebase;\n\nvec2 GetNoteData( const in vec2 vMidiResult, const in float fMidiTime )\n{\n    return vec2( NoteToHz(vMidiResult.x), (fMidiTime - vMidiResult.y) * kInvMidiTimebase );\n}\n\nfloat PlayMidi( const in float time )\n{\n    if(time < 0.0)\n\t\treturn 0.0;\n    \n    float fMidiTime = time * kMidiTimebase;\n    \n    float fResult = 0.0;\n    \n    fResult += Track1Instrument( GetNoteData( GetTrack1Note(fMidiTime), fMidiTime ) );\n    fResult += Track2Instrument( GetNoteData( GetTrack2Note(fMidiTime), fMidiTime ) );\n    fResult += Track3Instrument( GetNoteData( GetTrack3Note(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4ANote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4BNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4CNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4DNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4ENote(fMidiTime), fMidiTime ) );\n    \n    fResult = clamp(fResult * 0.1, -1.0, 1.0);\n    \n    float fFadeEnd = 20.0 * 240.0 \/ kMidiTimebase;\n    float fFadeTime = 5.0;\n    float fFade = (time - (fFadeEnd - fFadeTime)) \/ fFadeTime;    \n    fResult *= clamp(1.0 - fFade, 0.0, 1.0);\n    \n    return fResult;\n}\n\nvec2 mainSound(float time)\n{\n    return vec2( PlayMidi(time - 3.0) );\n}\n\n\/\/#define IMAGE_SHADER\n\n#ifdef IMAGE_SHADER\n\nfloat Function( float x )\n{\n\treturn mainSound( iGlobalTime + x \/ (44100.0 \/ 60.0) ).x * 0.5 + 0.5;\n}\n\nfloat Plot( vec2 uv )\n{\n\tfloat y = Function(uv.x);\n\t\n\treturn abs(y - uv.y) * iResolution.y;\t\n}\n\nvoid main()\n{\n\t\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n\t\n\tvec3 vResult = vec3(0.0);\n\t\n\tvResult += Plot(uv);\n\t\n\tgl_FragColor = vec4((vResult),1.0);\n}\n#endif\n\n","name":"","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"Xs2Xzm","date":"1410434257","viewed":69,"name":"Honeycomb Grid","username":"cybero","description":"Second shader ported to Shadertoy, repeated geometry","likes":0,"published":1,"tags":["repeatedgeometry"],"hasliked":0},"renderpass":[{"inputs":[{"id":35,"src":"\/presets\/mzk06.mp3","ctype":"music","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"float comb(vec2 pos) \n{\n\tpos.x=fract(pos.x+0.5)-.5;\n\tpos.y=fract(pos.y+0.5)-0.5;\n\t\n\tpos = abs(pos);\nfloat fm = 1.0 + 0.75*sin(iGlobalTime);\n\treturn (max(pos.x+pos.y*0.57735*fm,pos.y)-.5);\n\n}\n\nvoid main(void) \n{\n\tfloat aspect = (iResolution.x \/ iResolution.y)*0.5,iChannel0;\n\tvec2 unipos = (( gl_FragCoord.xy \/ iResolution.xy )+iChannel0);\n\tvec2 pos = unipos*10.0+iChannel0;\n\tpos.x *= aspect;\n\tfloat dist = comb(pos);\n\tfloat d = smoothstep( 0.03, 0.06, abs(dist));\n\t\n\t\n\tvec3 clr_a = vec3(0.9, 0.6, 0.2) * vec3(1.0 - abs(dist * 5.0));\n\tvec3 clr_b = vec3(0.3, 0.2, 0.0);\n\tfloat m = 0.5 + dist*6.0*(sin(iGlobalTime*1.125));\n\tvec3 clr_c = vec3( m, m*0.6, 0.15 );\n\t\n\tvec3 clr = mix(clr_a, clr_b, d);\n\tclr = mix(clr, clr_c, dist*-sin(d));\n\tgl_FragColor.rgb = clr;\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound(float time)\n{\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}","name":"","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"4s2XRm","date":"1410386381","viewed":70,"name":"Audio Wave","username":"sulami","description":"My first somewhat pretty shader, copies the iChannel audio wave but looks nicer.","likes":0,"published":1,"tags":["visualization","audio","waveform"],"hasliked":0},"renderpass":[{"inputs":[{"id":13,"src":"\/presets\/mzk00.mp3","ctype":"music","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"void main(void)\n{    \n    vec4 wave = texture2D(iChannel0, vec2(gl_FragCoord.x \/ iResolution.x, 0.0));\n    \n    vec4 alpha = vec4(clamp(iResolution.y \/ (wave.y - gl_FragCoord.y \/ iResolution.y), 0.0, 1.0));\n    \n    vec4 color = vec4(1.0 - gl_FragCoord.x \/ iResolution.x,\n        \t\t\t  sin(gl_FragCoord.x \/ iResolution.x * 3.14),\n                      gl_FragCoord.x \/ iResolution.x,        \t\t\t  \n                      0.0);\n            \n\tgl_FragColor = wave * alpha * color;\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsjXRm","date":"1410385033","viewed":284,"name":"Plasma Globe","username":"nimitz","description":"My first attempt at recreating a real world object.  I tried making the sphere glow based on ray position but it didn't look better and was much more expensive.\n\nMouse drag to rotate.","likes":19,"published":1,"tags":["3d","raymarching","rays","plasma","volumetric"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/Plasma Globe by nimitz (twitter: @stormoid)\n\n\/\/looks best with around 25 rays\n#define NUM_RAYS 13.\n\n#define VOLUMETRIC_STEPS 19\n\n#define MAX_ITER 35\n#define FAR 6.\n\n#define time iGlobalTime*1.1\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat noise( in float x ){return texture2D(iChannel0, vec2(x*.01,1.)).x;}\n\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\n\n\/\/iq's ubiquitous 3d noise\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\n\/\/See: https:\/\/www.shadertoy.com\/view\/XdfXRj\nfloat flow(in vec3 p, in float t)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i= 1.;i < 5.;i++ )\n\t{\n\t\tp += time*.1;\n\t\trz+= (sin(noise(p+t*0.8)*6.)*0.5+0.5) \/z;\n\t\tp = mix(bp,p,0.6);\n\t\tz *= 2.;\n\t\tp *= 2.01;\n        p*= m3;\n\t}\n\treturn rz;\t\n}\n\n\/\/could be improved\nfloat sins(in float x)\n{\n \tfloat rz = 0.;\n    float z = 2.;\n    for (float i= 0.;i < 3.;i++ )\n\t{\n        rz += abs(fract(x*1.4)-0.5)\/z;\n        x *= 1.3;\n        z *= 1.15;\n        x -= time*.65*z;\n    }\n    return rz;\n}\n\nfloat segm( vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1. );\t\n\treturn length( pa - ba*h )*.5;\n}\n\nvec3 path(in float i, in float d)\n{\n    vec3 en = vec3(0.,0.,1.);\n    float sns2 = sins(d+i*0.5)*0.22;\n    float sns = sins(d+i*.6)*0.21;\n    en.xz *= mm2((hash(i*10.569)-.5)*6.2+sns2);\n    en.xy *= mm2((hash(i*4.732)-.5)*6.2+sns);\n    return en;\n}\n\nvec2 map(vec3 p, float i)\n{\n\tfloat lp = length(p);\n    vec3 bg = vec3(0.);   \n    vec3 en = path(i,lp);\n    \n    float ins = smoothstep(0.11,.46,lp);\n    float outs = .15+smoothstep(.0,.15,abs(lp-1.));\n    p *= ins*outs;\n    float id = ins*outs;\n    \n    float rz = segm(p, bg, en)-0.011;\n    return vec2(rz,id);\n}\n\nfloat march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j)\n{\n\tfloat precis = 0.001;\n    float h=0.5;\n    float d = startf;\n    for( int i=0; i<MAX_ITER; i++ )\n    {\n        if( abs(h)<precis||d>maxd ) break;\n        d += h*1.2;\n\t    float res = map(ro+rd*d, j).x;\n        h = res;\n    }\n\treturn d;\n}\n\n\/\/volumetric marching\nvec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig)\n{   \n    vec3 p = ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    float w = 0.;\n    for( int i=0; i<VOLUMETRIC_STEPS; i++ )\n    {\n        r = map(p,j);\n        p += rd*.03;\n        float lp = length(p);\n        \n        vec3 col = sin(vec3(1.05,2.5,1.52)*3.94+r.y)*.85+0.4;\n        col.rgb *= smoothstep(.0,.015,-r.x);\n        col *= smoothstep(0.04,.2,abs(lp-1.1));\n        col *= smoothstep(0.1,.34,lp);\n        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+time*5.)*1.1) \/ (log(distance(p,orig)-2.)+.75);\n    }\n    return sum;\n}\n\n\/\/returns both collision dists of unit sphere\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(-1.);\n    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));\n}\n\nvoid main(void)\n{\t\n\tvec2 p = gl_FragCoord.xy\/iResolution.xy-0.5;\n\tp.x*=iResolution.x\/iResolution.y;\n\tvec2 um = iMouse.xy \/ iResolution.xy-.5;\n    \n\t\/\/camera\n\tvec3 ro = vec3(0.,0.,5.);\n    vec3 rd = normalize(vec3(p*.7,-1.5));\n    mat2 mx = mm2(time*.4+um.x*6.);\n    mat2 my = mm2(time*0.3+um.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec3 bro = ro;\n    vec3 brd = rd;\n\t\n    vec3 col = vec3(0.0125,0.,0.025);\n    #if 1\n    for (float j = 1.;j<NUM_RAYS+1.;j++)\n    {\n        ro = bro;\n        rd = brd;\n        mat2 mm = mm2((time*0.1+((j+1.)*5.1))*j*0.25);\n        ro.xy *= mm;rd.xy *= mm;\n        ro.xz *= mm;rd.xz *= mm;\n        float rz = march(ro,rd,2.5,FAR,j);\n\t\tif ( rz >= FAR)continue;\n    \tvec3 pos = ro+rz*rd;\n    \tcol = max(col,vmarch(pos,rd,j, bro));\n    }\n    #endif\n    \n    ro = bro;\n    rd = brd;\n    vec2 sph = iSphere2(ro,rd);\n    \n    if (sph.x > 0.)\n    {\n        vec3 pos = ro+rd*sph.x;\n        vec3 pos2 = ro+rd*sph.y;\n        vec3 rf = reflect( rd, pos );\n        vec3 rf2 = reflect( rd, pos2 );\n        float nz = (-log(abs(flow(rf*1.2,time)-.01)));\n        float nz2 = (-log(abs(flow(rf2*1.2,-time)-.01)));\n        col += (0.1*nz*nz* vec3(0.12,0.12,.5) + 0.05*nz2*nz2*vec3(0.55,0.2,.55))*0.8;\n    }\n    \n\tgl_FragColor = vec4(col*1.3, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4djSRm","date":"1410366830","viewed":52,"name":"Quantization transition","username":"Spaceoff","description":"Again just messing about and getting accustomed to GLSL.  Best viewed in full screen.","likes":0,"published":1,"tags":["animation","compression","quantization","image"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"vec4 texture2D_blurred(in sampler2D tex, vec2 uv);\nvec4 texture2D_blurred_quantized(in sampler2D tex, vec2 uv, vec3 q);\nvec4 texture2D_blurred2_quantized(in sampler2D tex, vec2 uv, vec3 q);\nvec4 texture2D_denoise(in sampler2D tex, vec2 uv, float threshold, vec3 q);\nvec4 quantize(vec4 vec, vec3 q);\n\nvoid main(void)\n{\n    \/\/ Vertically flip coord to right-way-around\n    vec2 xy = vec2(gl_FragCoord.x, iResolution.y - gl_FragCoord.y);\n    vec2 uv = xy\/iResolution.xy;\n    \n    float dx = 1.0\/iResolution.x;\n    float dy = 1.0\/iResolution.y;\n\t\n    float offset = 1.0+mod(iGlobalTime*1.0, 16.0);\n    vec3 quant = vec3(offset, offset, offset);\n    \/\/ vec4 col = texture2D(iChannel0, uv);\n    \/\/ vec4 col = texture2D_blurred_quantized(iChannel0, uv, quant);\n    \/\/ vec4 col = texture2D_denoise(iChannel0, uv, 0.1, quant);\n    vec4 col = quantize(texture2D(iChannel0, uv), quant);\n    \n    gl_FragColor = col;\n}\n\nvec4 texture2D_blurred(in sampler2D tex, vec2 uv)\n{\n    return (texture2D(iChannel0, uv)\n\t\t+ texture2D(iChannel0, vec2(uv.x+1.0, uv.y))\n\t\t+ texture2D(iChannel0, vec2(uv.x-1.0, uv.y))\n\t\t+ texture2D(iChannel0, vec2(uv.x, uv.y+1.0))\n\t\t+ texture2D(iChannel0, vec2(uv.x, uv.y-1.0)))\/5.0;\n}\n\nvec4 texture2D_blurred_quantized(in sampler2D tex, vec2 uv, vec3 q)\n{\n    return (quantize(texture2D(iChannel0, uv), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x+1.0, uv.y)), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x-1.0, uv.y)), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x, uv.y+1.0)), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x, uv.y-1.0)), q))\/5.0;\n}\n\nvec4 texture2D_blurred2_quantized(in sampler2D tex, vec2 uv, vec3 q)\n{\n    return (quantize(texture2D(iChannel0, uv), q)\n        + quantize(texture2D(iChannel0, vec2(uv.x+1.0, uv.y+1.0)), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x+1.0, uv.y-1.0)), q)\n        + quantize(texture2D(iChannel0, vec2(uv.x-1.0, uv.y+1.0)), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x-1.0, uv.y-1.0)), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x+1.0, uv.y)), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x-1.0, uv.y)), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x, uv.y+1.0)), q)\n\t\t+ quantize(texture2D(iChannel0, vec2(uv.x, uv.y-1.0)), q))\/9.0;\n}\n        \nvec4 texture2D_denoise(in sampler2D tex, vec2 uv, float threshold, vec3 q)\n{\n    vec4 col = texture2D(tex, uv),\n        blurred = texture2D_blurred_quantized(tex, uv, q);\n    \n    if (length(col-blurred) <= threshold)\n        return blurred;\n    else\n        return col;\n}\n\nvec4 quantize(vec4 vec, vec3 q)\n{\n    vec.r = floor(vec.r*q.r)\/q.r;\n    vec.g = floor(vec.g*q.g)\/q.g;\n    vec.b = floor(vec.b*q.b)\/q.b;\n    return vec;\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4d2Xzw","date":"1410362903","viewed":185,"name":"Bokeh disc","username":"Dave_Hoskins","description":"Uses evenly distributed samples from this idea:- http:\/\/blog.marmakoide.org\/?p=1 with a few changes, like not using square roots.\nChange iterations to suit size needed.\n","likes":12,"published":1,"tags":["2d","blur","bokeh"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0},{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":1}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ Bokeh disc.\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ITERATIONS 150.0\n\n#define ONEOVER_ITR  1.0 \/ ITERATIONS\n#define PI 3.141596\n\n\/\/ This is (3.-sqrt(5.0))*PI radians, which doesn't precompiled for some reason.\n\/\/ The compiler is a dunce I tells-ya!!\n#define GOLDEN_ANGLE 2.39996323\n\n\/\/-------------------------------------------------------------------------------------------\n\/\/ This creates the 2D offset for the next point.\n\/\/ (r-1.0) is the same as sqrt(0, 1,  2, 3...)\nvec2 Sample(in float theta, inout float r)\n{\n    r += 1.0 \/ r;\n\treturn (r-1.0) * vec2(cos(theta), sin(theta)) * .06;\n}\n\n\/\/-------------------------------------------------------------------------------------------\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius, float amount)\n{\n\tvec3 acc = vec3(0.0);\n\tvec3 div = vec3(0.0);\n    vec2 pixel = vec2(iResolution.y\/iResolution.x, 1.0) * radius * .025;\n    float r = 1.0;\n\tfor (float j = 0.0; j < GOLDEN_ANGLE * ITERATIONS; j += GOLDEN_ANGLE)\n    {\n       \t\n\t\tvec3 col = texture2D(tex, uv + pixel * Sample(j, r)).xyz;\n        col = col * col * 1.2; \/\/ ...contrast it for better highlights\n\t\tvec3 bokeh = vec3(.5) + pow(col, vec3(10.0)) * amount;\n\t\tacc += col * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn acc \/ div;\n}\n\n\/\/-------------------------------------------------------------------------------------------\nvoid main(void)\n{\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n    float time = iGlobalTime*.2 + .5;\n\tfloat r = .5 - .5*cos(time * PI * 2.0);\n       \n\tfloat a = 120.0;\n    if (iMouse.w >= 1.0)\n    {\n    \tr = (iMouse.x\/iResolution.x)*3.0;\n        a = iMouse.y\/iResolution.y * 80.0;\n    }\n    \n    if (mod(time-.5, 2.0) < 1.0)\n    {\n\t\tgl_FragColor = vec4(Bokeh(iChannel0, uv*vec2(1.0, -1.0), r, a), 1.0);\n    }else\n    {\n        gl_FragColor = vec4(Bokeh(iChannel1, uv*vec2(1.0, -1.0), r, a), 1.0);    \n    }\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dBXzw","date":"1410357276","viewed":171,"name":"Holographic","username":"TDM","description":"Inspired by Johnny Lee VR work. 3D effect on flat surface.","likes":9,"published":1,"tags":["projection","table","holographic","kinect"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ \"Holographic\" by Alexander Alekseev aka TDM - 2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/#define PIXELIZE\n#define CAMERA_CHANGE\n\nconst int NUM_STEPS = 64;\nconst int AO_SAMPLES = 4;\nconst float AO_RADIUS = 1.3;\nconst float AO_DARKNESS = 3.5;\nconst float INV_AO_SAMPLES = 1.0 \/ float(AO_SAMPLES);\nconst float TRESHOLD \t= 0.001;\nconst float EPSILON \t= 1e-5;\nconst float PI \t\t\t= 3.1415;\nconst float HPI \t\t= PI * 0.5;\nconst float LIGHT_INTENSITY = 0.37;\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\nconst vec3 WHITE \t= vec3(1.0,0.99,0.98) * LIGHT_INTENSITY;\nfloat WEIGHT \t\t\t= 2.0 \/ iResolution.x;\n\n\/\/ holo\nconst vec2 HOLO_SIZE \t= vec2(0.79,0.49);\nconst float HOLO_ASPECT = HOLO_SIZE.x \/ HOLO_SIZE.y;\nconst int HOLO_LINES \t= 8;\nconst vec2 dxdy \t\t= HOLO_SIZE \/ float(HOLO_LINES\/2);\nconst float HOLO_DEPTH \t= 5.0;\nconst float HOLO_DDEPTH = HOLO_DEPTH \/ float(HOLO_LINES-1);\n\n#ifdef PIXELIZE\nconst vec2 HOLO_RESOLUTION = vec2(20.0,16.0);\n#endif\n\n\/\/ math\nmat4 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat4 m;\n    m[0] = vec4(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x,0.0);\n\tm[1] = vec4(-a2.y*a1.x,a1.y*a2.y,a2.x,0.0);\n\tm[2] = vec4(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y,0.0);\n\tm[3] = vec4(0.0,0.0,0.0,1.0);\n\treturn m;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nvec3 rotate(vec3 v, mat4 m) {\n    return vec3(dot(v,m[0].xyz),dot(v,m[1].xyz),dot(v,m[2].xyz));\n}\nvec3 intersectPlane(vec3 o,vec3 d,vec4 p) {\n    float t = (dot(p.xyz,o)-p.w) \/ dot(p.xyz,d);\n    return o - d * t;    \n}\n\n\/\/ rasterize\nfloat line(vec2 p, vec2 p0, vec2 p1) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) \/ dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0\/dist*WEIGHT;\n    return min(dist*dist,1.0);\n}\n\n\/\/ lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * 0.4 + 0.6,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) \/ (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\/\/ distance functions\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\nfloat capsule(vec3 p,float r,float h) {\n    p.y -= clamp(p.y,-h,h);\n\treturn length(p)-r;\n}\nfloat cylinder(vec3 p,float r,float h) {\n\treturn max(abs(p.y\/h),capsule(p,r,h));\n}\nfloat box(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat quad(vec3 p,vec2 s) {\n\tp = abs(p) - vec3(s.x,0.0,s.y);\n    return max(max(p.x,p.y),p.z);\n}\n\n\/\/ boolean operations\nfloat boolUnion(float a,float b) { return min(a,b); }\nfloat boolIntersect(float a,float b) { return max(a,b); }\n\n\/\/ world\nfloat map(vec3 p) {\n    float d = plane(p,vec4(0.0,1.0,0.0,1.0));\n    d = boolUnion(d,plane(p,vec4(0.0,-1.0,0.0,4.0))); \n    d = boolUnion(d,plane(p,vec4(0.0,0.0,1.0,5.0)));\n    d = boolUnion(d,plane(p,vec4(0.0,0.0,-1.0,5.0)));  \n    d = boolUnion(d,plane(p,vec4(1.0,0.0,0.0,8.0)));\n    d = boolUnion(d,plane(p,vec4(-1.0,0.0,0.0,8.0)));  \n    \n    d = boolUnion(d,rbox(vec3(0.75,-0.51,0.45)-p,vec3(0.1,0.5,0.1)));    \n    d = boolUnion(d,rbox(vec3(0.75,-0.51,-0.45)-p,vec3(0.1,0.5,0.1)));\n    d = boolUnion(d,rbox(vec3(-0.75,-0.51,0.45)-p,vec3(0.1,0.5,0.1)));    \n    d = boolUnion(d,rbox(vec3(-0.75,-0.51,-0.45)-p,vec3(0.1,0.5,0.1)));\n    d = boolUnion(d,rbox(vec3(0.0,-0.06,0.0)-p,vec3(0.85,0.05,0.55)));\n    \n    d = boolUnion(d,quad(vec3(0.0,0.0,0.0)-p,HOLO_SIZE));\n    return d;\n}\n\n\/\/ tracing\nvec3 getNormal(vec3 p, float dens) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-dens);\n}\nfloat getAO(vec3 p,vec3 n) {\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.01+f*AO_RADIUS;\n        float d = map(p + n * h) - TRESHOLD;\n        r += clamp(h-d,0.0,1.0) * (1.0-f);\n    }    \n    return pow(clamp(1.0-r*INV_AO_SAMPLES*AO_DARKNESS,0.0,1.0),0.5);\n}\nfloat spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        d = map(p);\n        if(d < TRESHOLD) break;\n        t += max(d-TRESHOLD,EPSILON);\n    } \n    return d;\n}\n\n\/\/ holo\nfloat projectLine(vec3 o, vec2 uv, vec3 v0,vec3 v1) {\n    v0 = intersectPlane(o,v0-o,vec4(0.0,1.0,0.0,0.0));\n    v1 = intersectPlane(o,v1-o,vec4(0.0,1.0,0.0,0.0));\n    v0.xy = v0.xz \/ HOLO_SIZE; v1.xy = v1.xz \/ HOLO_SIZE;\n    v0.x *= HOLO_ASPECT; v1.x *= HOLO_ASPECT;\n    return line(uv,v0.xy,v1.xy);\n}\n\nvoid projectCircle(vec3 o,vec2 uv,vec3 v,inout vec3 c){\n    vec3 d = v-o;\n    v = intersectPlane(o,d,vec4(0.0,1.0,0.0,0.0));\n    v.xz \/= HOLO_SIZE; v.x *= HOLO_ASPECT;\n    \n    float r = length(uv-v.xz) * length(d) * 0.75;\n    float circle = clamp(sin(r*40.0) * 5.0 * 0.5 + 0.5, 0.0,1.0);\n    c = mix(c, vec3(1.0,circle,circle), smoothstep(0.50,0.48,r));\n}\n\nvec3 holoGetColor(mat4 head, vec2 p) {\n    float time = iGlobalTime * 0.3;\n    vec2 uv = p; uv.x *= HOLO_ASPECT;    \n    vec3 pos = vec3(head[0][3],head[1][3],head[2][3]);\n    \n#ifdef PIXELIZE\n    uv = floor(uv*HOLO_RESOLUTION) \/ HOLO_RESOLUTION;\n#endif\n    \n    float i = 0.0;    \n    for(int it = 0; it < HOLO_LINES; it++) {\n        \/\/ vertical\n        vec3 v0 = vec3(-HOLO_SIZE.x + dxdy.x * float(it+1),0.0,-HOLO_SIZE.y);\n        vec3 v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(-HOLO_SIZE.x + dxdy.x * float(it),0.0, HOLO_SIZE.y);\n        v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);      \n        \n        v0 = vec3(-HOLO_SIZE.x, 0.0, -HOLO_SIZE.y + dxdy.y * float(it));\n        v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);  \n        \n        v0 = vec3(HOLO_SIZE.x, 0.0, -HOLO_SIZE.y + dxdy.y * float(it+1));\n        v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        \/\/ horizontal\n        float h = -float(it)*HOLO_DDEPTH;\n        v0 = vec3(-HOLO_SIZE.x,h,-HOLO_SIZE.y);\n        v1 = vec3(-v0.x,v0.y,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(-HOLO_SIZE.x,h,HOLO_SIZE.y);\n        v1 = vec3(-v0.x,v0.y,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(-HOLO_SIZE.x,h,-HOLO_SIZE.y);\n        v1 = vec3(v0.x,v0.y,-v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(HOLO_SIZE.x,h,-HOLO_SIZE.y);\n        v1 = vec3(v0.x,v0.y,-v0.z);\n    \ti += projectLine(pos,uv,v0,v1);       \n    }\n    \n    vec3 color = vec3(min(i,1.0));    \n    projectCircle(pos,uv,vec3(-0.5,-3.0,0.0),color);\n    projectCircle(pos,uv,vec3( 0.5,-1.0,0.0),color);\n    projectCircle(pos,uv,vec3( 0.0, 1.0,0.0),color);\n    color += texture2D(iChannel0,uv*0.5).z * 0.3;\n    return color;\n}\n\nvec3 holoGetColor(mat4 head, vec3 p) {\n    return holoGetColor(head,p.xz \/ HOLO_SIZE);\n}\n\n\/\/ main\nvoid main(void) {\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;    \n    float time = iGlobalTime * 0.3;\n        \n    \/\/ ray\n    vec3 ang = vec3(0.0,0.7,time);\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,-0.3,PI),iMouse.x*0.01);\n\tmat4 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,0.0,2.0+sin(time)*0.5);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \n    ori = rotate(ori,rot);\n    dir = rotate(dir,rot);\n    mat4 head = rot * getPosMatrix(ori);\n    \n    \/\/ change camera\n#ifdef CAMERA_CHANGE\n    rot = fromEuler(vec3(0.0,1.0,0.0));\n    vec3 ori2 = vec3(0.0,0.0,2.0);\n    vec3 dir2 = normalize(vec3(uv.xy,-2.0));    \n    ori2 = rotate(ori2,rot);\n    dir2 = rotate(dir2,rot);\n    \n    float camera_change_factor = clamp((sin(time)-0.8)*10.0,-1.0,1.0) * 0.5 + 0.5;\n    ori = mix(ori,ori2,camera_change_factor);\n    dir = normalize(mix(dir,dir2,camera_change_factor));\n#endif\n    \n    \/\/ tracing\n    vec3 p;\n    float dens = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p,dens);\n    float ao = getAO(p,n);\n         \n    \/\/ color\n    vec3 color = vec3(0.6+texture2D(iChannel0,(p.xz+p.y*0.2)*0.1).x * 0.05);\n    if(p.y >= -EPSILON && dot(p.xz,p.xz) < 1.0) color = holoGetColor(head,p);\n    color *= 1.0-pow(dot(p,p)*0.01,0.4);\n    \n    \/\/ lighting\n    vec3 l0 = normalize(vec3(0.0,0.5,0.7));\n    vec3 l1 = normalize(vec3(0.5,0.5,-0.7));    \n    color += vec3((diffuse(n,l0,3.0) + specular(n,l0,dir,20.0)) * RED);\n    color += vec3((diffuse(n,l1,3.0) + specular(n,l1,dir,20.0)) * BLUE);    \n    color = clamp(color*ao*0.9,0.0,1.0);\n    color = mix(vec3(0.3),color,step(dens,1.0));\n        \n    \/\/color = vec3(ao);\n    \/\/color = n * 0.5 + 0.5;\n\t\n\tgl_FragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsB3DV","date":"1410331143","viewed":107,"name":"CRT Emulation","username":"Mattias","description":"Another go at a CRT effect.","likes":4,"published":1,"tags":["crt"],"hasliked":0},"renderpass":[{"inputs":[{"id":11,"src":"\/presets\/vid00.ogv","ctype":"video","channel":0}],"outputs":[{"channel":"0","dst":"-1"}],"code":"vec3 sample( sampler2D tex, vec2 tc )\n{\n\tvec3 s = pow(texture2D(tex,tc).rgb, vec3(2.2));\n\treturn s;\n}\n\n\nvec3 blur(sampler2D tex, vec2 tc, float offs)\n{\n\tvec4 xoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) \/ iResolution.x;\n\tvec4 yoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) \/ iResolution.y;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor += sample(tex,tc + vec2(xoffs.x, yoffs.x)) * 0.00366;\n\tcolor += sample(tex,tc + vec2(xoffs.y, yoffs.x)) * 0.01465;\n\tcolor += sample(tex,tc + vec2(    0.0, yoffs.x)) * 0.02564;\n\tcolor += sample(tex,tc + vec2(xoffs.z, yoffs.x)) * 0.01465;\n\tcolor += sample(tex,tc + vec2(xoffs.w, yoffs.x)) * 0.00366;\n\t\n\tcolor += sample(tex,tc + vec2(xoffs.x, yoffs.y)) * 0.01465;\n\tcolor += sample(tex,tc + vec2(xoffs.y, yoffs.y)) * 0.05861;\n\tcolor += sample(tex,tc + vec2(    0.0, yoffs.y)) * 0.09524;\n\tcolor += sample(tex,tc + vec2(xoffs.z, yoffs.y)) * 0.05861;\n\tcolor += sample(tex,tc + vec2(xoffs.w, yoffs.y)) * 0.01465;\n\t\n\tcolor += sample(tex,tc + vec2(xoffs.x, 0.0)) * 0.02564;\n\tcolor += sample(tex,tc + vec2(xoffs.y, 0.0)) * 0.09524;\n\tcolor += sample(tex,tc + vec2(    0.0, 0.0)) * 0.15018;\n\tcolor += sample(tex,tc + vec2(xoffs.z, 0.0)) * 0.09524;\n\tcolor += sample(tex,tc + vec2(xoffs.w, 0.0)) * 0.02564;\n\t\n\tcolor += sample(tex,tc + vec2(xoffs.x, yoffs.z)) * 0.01465;\n\tcolor += sample(tex,tc + vec2(xoffs.y, yoffs.z)) * 0.05861;\n\tcolor += sample(tex,tc + vec2(    0.0, yoffs.z)) * 0.09524;\n\tcolor += sample(tex,tc + vec2(xoffs.z, yoffs.z)) * 0.05861;\n\tcolor += sample(tex,tc + vec2(xoffs.w, yoffs.z)) * 0.01465;\n\t\n\tcolor += sample(tex,tc + vec2(xoffs.x, yoffs.w)) * 0.00366;\n\tcolor += sample(tex,tc + vec2(xoffs.y, yoffs.w)) * 0.01465;\n\tcolor += sample(tex,tc + vec2(    0.0, yoffs.w)) * 0.02564;\n\tcolor += sample(tex,tc + vec2(xoffs.z, yoffs.w)) * 0.01465;\n\tcolor += sample(tex,tc + vec2(xoffs.w, yoffs.w)) * 0.00366;\n\n\treturn color;\n}\n\n\/\/Credit: http:\/\/stackoverflow.com\/questions\/4200224\/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) \/ 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) \/ 4.0), 2.0);\n\tuv  = (uv \/ 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\nvoid main(void)\n{\n    vec2 q = gl_FragCoord.xy \/ iResolution.xy;\n    vec2 uv = q;\n    uv = mix( curve( uv ), uv, 0.5 );\n    vec3 oricol = texture2D( iChannel0, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n\tfloat x =  sin(0.1*iGlobalTime+uv.y*21.0)*sin(0.23*iGlobalTime+uv.y*29.0)*sin(0.3+0.11*iGlobalTime+uv.y*31.0)*0.0017;\n\tfloat o =2.0*mod(gl_FragCoord.y,2.0)\/iResolution.x;\n\tx+=o;\n    col.r = 1.0*blur(iChannel0,vec2(x+uv.x+0.0009,uv.y+0.0009),1.2).x+0.005;\n    col.g = 1.0*blur(iChannel0,vec2(x+uv.x+0.000,uv.y-0.0015),1.2).y+0.005;\n    col.b = 1.0*blur(iChannel0,vec2(x+uv.x-0.0015,uv.y+0.000),1.2).z+0.005;\n    col.r += 0.2*blur(iChannel0,vec2(x+uv.x+0.0009,uv.y+0.0009),2.25).x-0.005;\n    col.g += 0.2*blur(iChannel0,vec2(x+uv.x+0.000,uv.y-0.0015),1.75).y-0.005;\n    col.b += 0.2*blur(iChannel0,vec2(x+uv.x-0.0015,uv.y+0.000),1.25).z-0.005;\n    float ghs = 0.05;\n\tcol.r += ghs*(1.0-0.299)*blur(iChannel0,0.75*vec2(x-0.01, -0.027)+vec2(uv.x+0.001,uv.y+0.001),7.0).x;\n    col.g += ghs*(1.0-0.587)*blur(iChannel0,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002),5.0).y;\n    col.b += ghs*(1.0-0.114)*blur(iChannel0,0.75*vec2(x+-0.02, -0.0)+vec2(uv.x-0.002,uv.y+0.000),3.0).z;\n\n    col = clamp(col*0.4+0.6*col*col*1.0,0.0,1.0);\n\n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tvig = pow(vig,0.3);\n\tcol *= vec3(vig);\n\n    col *= vec3(0.95,1.05,0.95);\n\tcol = mix( col, col * col, 0.3) * 3.8;\n\n\tfloat scans = clamp( 0.35+0.15*sin(3.5*iGlobalTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.9);\n\tcol = col*vec3( s) ;\n\n    col *= 1.0+0.0015*sin(300.0*iGlobalTime);\n\t\n\tcol*=1.0-0.15*vec3(clamp((mod(gl_FragCoord.x+o, 2.0)-1.0)*2.0,0.0,1.0));\n\tcol *= vec3( 1.0 ) - 0.25*vec3( rand( uv+0.0001*iGlobalTime),  rand( uv+0.0001*iGlobalTime + 0.3 ),  rand( uv+0.0001*iGlobalTime+ 0.5 )  );\n\tcol = pow(col, vec3(0.45));\n\n\tif (uv.x < 0.0 || uv.x > 1.0)\n\t\tcol *= 0.0;\n\tif (uv.y < 0.0 || uv.y > 1.0)\n\t\tcol *= 0.0;\n\t\n\n    float comp = smoothstep( 0.1, 0.9, sin(iGlobalTime) );\n \n\t\/\/ Remove the next line to stop cross-fade between original and postprocess\n\tcol = mix( col, oricol, comp );\n\n    gl_FragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}]